= How to write a compiler for emuStudio
(c) Copyright 2006-2016, Peter JakubÄo
Version 0.39
:toc:
:numbered:

This tutorial will describe some basic knowledge about how to create a compiler to be used in emuStudio. The tutorial
does not aim to explain all the compiler theory, nor it is exhaustive. Fortunately, we have many tools which can
generate the hardest parts for us. All compilers in emuStudio use http://jflex.de/[JFlex] for generating the lexical
analyzer, and http://www2.cs.tum.edu/projects/cup/[Java cup] for generating parsers.

The tutorial focuses on how to use emuLib API in a compiler project so it can be used in emuStudio.

[[GETTING_STARTED]]
== Getting started

Before reading on, please read the "Introduction for writing virtual computers" document. It gives the information
needed for setting up the development environment and for basic understanding how the emuStudio/plug-ins lifecycle
work.

A compiler is just another plug-in, which means that it is enough to implement some API and that's it. The compiler
API can be found in `emulib.plugins.compiler` project package.

When implementing whole virtual computer, the compiler is usually an implementation of an assembler of the instruction
set used by CPU of the computer. In this tutorial, a simple assembler will be implemented for the world's very first
stored-program computer, https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine[SSEM], nicknamed
"Baby". It was a predecessor of Manchester Mark 1 which led to Ferranti Mark 1, the world's first commercially available
general-purpose computer.

In this tutorial, there won't be any deep description of the computer, rather the focus will be on the instruction set
itself, because it is very simple. The processor had only 7 instructions, each is 3-bit long. The instructions table
follows (modified from https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Programming[Wikipedia]):


[width="50%",cols=">2m,<m,<m,<",frame="topbot",options="header,footer"]
|===================================================================
|Binary code |Modern mnemonic |Action            |Operation
|000         |JMP S           | S(L) -> CI      |Jump to the instruction at the address obtained from the specified memory
                                                  address `S(L)` (absolute unconditional jump)
|100         |JRP S           | CI + S(L) -> CI |Jump to the instruction at the program counter (`CI`) plus the
                                                  relative value obtained from the specified memory address `S(L)`
                                                  (relative unconditional jump)
|010         |LDN S           |-S(L) -> A       |Take the number from the specified memory address `S(L)`, negate it,
                                                  and load it into the accumulator
|110         |STO S           |A -> S(L)        |Store the number in the accumulator to the specified memory address `S(L)`
|001 or 101  |SUB S           |A - S(L) -> A    |Subtract the number at the specified memory address `S(L)` from the
                                                  value in accumulator, and store the result in the accumulator
|011         |CMP             |if A<0 then CI+1->CI |Skip next instruction if the accumulator contains a negative value
|111         |STP             |Stop              |
|===================================================================

NOTE: The bit-representation was kind of reversed. E.g., value `3` was represented by binary `110`, rather than `011`.

The instruction format is as follows:

[width="50%",cols=">2s,<m,<m,<m,<m,<m,<m,<m,<m,<m,<m,<m",frame="topbot",options="footer"]
.SSEM Instruction Format
|===================================================================
| Bit:  | 00  | 01 | 02 | 03 | 04 | ... | 13 | 14 | 15 | ... | 31
| Use:  | L   | L  | L  | L  | L  |  0  | F  | F  | F  | 0   | 0
| Value:| 2^0 |    |    |    |    |     |    |    |    |     | 2^31
|===================================================================

where bits `LLLLL` denote address (instruction operand), and bits `FFF` specify the instruction opcode.


== Language specification

Each compiler is just a program which translates a language into another. Language itself can have many translators
(compiler implementations). It is similar to when there is English language on the one hand, and there are people which
speak English on the other hand.

The computer programming languages must be specified in very formal way. The SSEM assembler specification can be
started with informal expressing, what it will know:

1. New-line character (LF, CR, or CRLF) will be required as a delimiter of instructions. Several successibe empty new-line
   characters will be ignored.
2. Only modern representation of instructions will be supported by the assembler.
3. Only decimal literals (numbers) will be supported as instruction operands. Negative or floating-point numbers will
   not be supported.
4. One-line comments will be supported, which start with double-slash (`//`). Everything after the `//` will be ignored.

For example, simple `5+3` addition can be implemented as follows:

    LDN 5 // load negative X into the accumulator
    SUB 3 // subtract Y from the value in the accumulator
    STO S // store the result at address S
    LDN S // load negative value at address S into the accumulator

The accumulator should now contain value `8`.

=== Lexical symbols (terminals)

The following table shows which categories of lexical symbols will exist:

[horizontal]
Reserved words:: `JMP`, `JRP`, `LDN`, `STO`, `SUB`, `CMP`, `STP`
Literals::
 - `number = (\-)?[0-9]+`, range: `<0, 31)` (max. 2^5)
Comment::
 - `comment = //[^\r\n]*`
Separator::
 - `eol = \r|\n|\r\n`
 - `space = [\ \t]*` (will be ignored)

NOTE: Literals, comments and separator are described using regular expressions used in http://jflex.de/[JFlex], which
      is recommended for generating lexical analyzer.

These categories correspond to which compiler API supports. For all possible categories see class
https://github.com/vbmacher/emuLib/blob/branch-9_0/src/main/java/emulib/plugins/compiler/Token.java[Token.java].

[[GRAMMAR]]
=== Grammar for parser

The grammar presented here will be a deterministic context-free grammar, specifically LALR for bottom-up
parsing. It is because http://www2.cs.tum.edu/projects/cup/[Java cup] is used as parser generator, which produces only
LALR parsers. It has some implications to grammar design, when compared with LL grammars. The easiest way how to design
a LALR grammar is to put recursive non-terminals close to the end (right side), and terminals close to the beginning
(left side) of a grammar rule.

The complete grammar of presented SSEM assembler looks as follows:

[source,bison]
----
Program     : Statement Program | &Epsilon;
Statement   : Instruction Comment eol | eol

Instruction : JMP number | JRP number | LDN number | STO number | SUB number | CMP | STP
Comment     : comment | &Epsilon;
----

== Preparing the environment

In order to start developing the compiler, create new Java project. Here, Maven will be used for dependencies management.
The plug-in will be implemented as another standard emuStudio plug-in, so it will inherit Maven plug-in dependencies
from the main POM file.

The project should be located at `emuStudio/plugins/compilers/as-ssem`, and should contain the following structure:

    src/
      main/
        java/
        resources/
    test/
      java/
    pom.xml

NOTE: Note the naming of the plug-in. It follows the naming convention as described in the
      "Introduction for writing virtual computers" guide.

The POM file of the project might look as follows:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <parent>
    <artifactId>emustudio-parent</artifactId>
    <groupId>net.sf.emustudio</groupId>
    <version>0.39-SNAPSHOT</version>
    <relativePath>../../../pom.xml</relativePath>
  </parent>
  <modelVersion>4.0.0</modelVersion>

  <artifactId>as-ssem</artifactId>

  <name>SSEM assembler</name>
  <description>Assembler of SSEM processor language</description>

  <build>
    <finalName>as-ssem</finalName>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <configuration>
          <archive>
            <manifest>
              <addClasspath>false</addClasspath>
              <mainClass>net.sf.emustudio.ssem.assembler.CompilerImpl</mainClass>
              <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
              <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
            </manifest>
            <manifestEntries>
              <Class-Path>lib/java-cup-runtime-11b.jar</Class-Path>
            </manifestEntries>
          </archive>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>de.jflex</groupId>
        <artifactId>jflex-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>com.github.vbmacher</groupId>
        <artifactId>cup-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <className>ParserImpl</className>
          <symbolsName>Symbols</symbolsName>
        </configuration>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
    </dependency>
    <dependency>
      <groupId>net.sf.emustudio</groupId>
      <artifactId>emuLib</artifactId>
    </dependency>
    <dependency>
      <groupId>com.github.vbmacher</groupId>
      <artifactId>java-cup-runtime</artifactId>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
    </dependency>
    <dependency>
      <groupId>org.easymock</groupId>
      <artifactId>easymock</artifactId>
    </dependency>
  </dependencies>
</project>
----

And let's start with the first Java class, the main plug-in class. Let's put it to package
`net.sf.emustudio.ssem.assembler`, and call it `CompilerImpl`.

== Implementing basic stuff

Go to the `CompilerImpl` class source. Extend the class from `emulib.plugins.compiler.AbstractCompiler` class.
The class extends from `Compiler` interface and implements the most common methods, usable by all compilers.

It is also necessary to annotate the class with `emulib.annotations.PluginType` annotation, and pass the
one argument of the constructor to the super class. The code snippet looks as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CompilerImpl.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.annotations.PLUGIN_TYPE;
import emulib.annotations.PluginType;
import emulib.plugins.compiler.AbstractCompiler;
import emulib.runtime.ContextPool;

@PluginType(
        type = PLUGIN_TYPE.COMPILER,
        title = "SSEM Assembler",
        copyright = "\u00A9 Copyright 2016, YourName",
        description = "Assembler of SSEM processor language"
)
public class CompilerImpl extends AbstractCompiler {

    public CompilerImpl(Long pluginID, ContextPool contextPool) {
        super(pluginID);
    }

    // ... other methods ...
}
----

NOTE: The constructor presented here is mandatory. This is one of the behavioral contracts, emuStudio expects
      that a plug-in will have a constructor with two arguments: pluginID (assigned by emuStudio), and a context
      pool, which will be described later, in another type of plug-ins.

== Implement lexical analyzer

Now the time become to write the lexical analyzer. As it was mentioned before, http://jflex.de/[JFlex] will be
used for generating the Java code from `jflex` specification file. See the link of the JFlex for more information.

The usual place to put the specfile is at `src/main/jflex`. The file will be named `ssem.jflex` The file will be
automatically parsed, and the lexer generated using
http://jflex.sourceforge.net/maven-jflex-plugin/generate-mojo.html[JFlex Maven plugin] (see the POM file above).

Before the implementation of the specfile, we need to implement `TokenImpl` class. This class holds the basic
information about the parsed token, and it extends `java_cup.runtime.Symbol` class, and implements
`emulib.plugins.compiler.Token` and `Symbols` interface. We will talk about `Symbols` in parser section.

The content of the `net.sf.emustudio.ssem.assembler.TokenImpl` class is:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/TokenImpl.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.Token;
import java_cup.runtime.ComplexSymbolFactory;

public class TokenImpl extends ComplexSymbolFactory.ComplexSymbol implements Token, Symbols {
    private final int category;
    private final int cchar;

    public TokenImpl(int id, int category, String text, int line, int column, int cchar) {
        super(
            text, id, new ComplexSymbolFactory.Location(line, column), new ComplexSymbolFactory.Location(line, column)
        );
        this.category = category;
        this.cchar = cchar;
    }

    public TokenImpl(int id, int category, String text, int line, int column, int cchar, Object value) {
        super(
            text, id, new ComplexSymbolFactory.Location(line, column), new ComplexSymbolFactory.Location(line, column), value
        );
        this.category = category;
        this.cchar = cchar;
    }

    @Override
    public int getID() {
        return super.sym;
    }

    @Override
    public int getType() {
        return category;
    }

    @Override
    public int getLine() {
        return super.getLeft().getLine();
    }

    @Override
    public int getColumn() {
        return super.getLeft().getColumn();
    }

    @Override
    public int getOffset() {
        return cchar;
    }

    @Override
    public int getLength() {
        return cchar + getName().length();
    }

    @Override
    public String getErrorString() {
        return "Unknown token";
    }

    @Override
    public String getText() {
        return getName();
    }

    @Override
    public boolean isInitialLexicalState() {
        return true;
    }
}
----

Now, we can define the lexical analyzer:

[source,flex]
.`src/main/jflex/ssem.jflex`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.LexicalAnalyzer;
import emulib.plugins.compiler.Token;
import java.io.IOException;
import java.io.Reader;

%%

/* options */
%class LexerImpl
%cup
%public
%implements LexicalAnalyzer, Symbols
%line
%column
%char
%caseless
%unicode
%type TokenImpl

%{
    @Override
    public Token getSymbol() throws IOException {
        return next_token();
    }

    @Override
    public void reset(Reader in, int yyline, int yychar, int yycolumn) {
        yyreset(in);
        this.yyline = yyline;
        this.yychar = yychar;
        this.yycolumn = yycolumn;
    }

    @Override
    public void reset() {
        this.yyline = 0;
        this.yychar = 0;
        this.yycolumn = 0;
    }

    private TokenImpl token(int type, int category) {
        return new TokenImpl(type, category, yytext(), yyline, yycolumn, yychar);
    }

    private TokenImpl token(int type, int category, Object value) {
        return new TokenImpl(type, category, yytext(), yyline, yycolumn, yychar, value);
    }
%}

%eofval{
    return token(EOF, Token.TEOF);
%eofval}

comment = "//"[^\r\n]*
eol = \r|\n|\r\n
space = [ \t\f]+
number = \-?[0-9]+

%%

/* reserved words */
"jmp" {
    return token(JMP, Token.RESERVED);
}
"jrp" {
    return token(JRP, Token.RESERVED);
}
"ldn" {
    return token(LDN, Token.RESERVED);
}
"sto" {
    return token(STO, Token.RESERVED);
}
"sub" {
    return token(SUB, Token.RESERVED);
}
"cmp" {
    return token(CMP, Token.RESERVED);
}
"stp" {
    return token(STP, Token.RESERVED);
}

/* separators */
{eol} {
    return token(SEPARATOR_EOL, Token.SEPARATOR);
}
{space} { /* ignore white spaces */ }

/* comment */
{comment} {
    return token(TCOMMENT, Token.COMMENT);
}

/* literals */
{number} {
    int num = Integer.parseInt(yytext(), 10);
    return token(NUMBER, Token.LITERAL, (byte)(num & 0xFF));
}

/* error fallback */
[^] {
    return token(ERROR_UNKNOWN_TOKEN, Token.ERROR);
}
----

Token in emuStudio is very important also for syntax highlighting in the editor. For parsing, each token must have
its unique identification number (token ID), such as `JMP`, `SEPARATOR_EOL`, `NUMBER`, etc. from the above file.
However, for doing syntax highlighting, it wouldn't be that beneficial if the color of a token was based on its
ID, because for example each instruction would have different color. Rather, in emuLib there exist token categories,
which are used when considering token color. Token categories are defined in the class `emulib.plugins.compiler.Token`.

=== Test it!

It is now very required practice to write unit tests, this is especially useful when very concrete specification
is available. Here are some code snippets, which can be implemented right away for testing the lexer:

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/LexerTest.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.Token;
import org.junit.Test;

import java.io.IOException;
import java.io.StringReader;

import static org.junit.Assert.assertEquals;

public class LexerTest {

    LexerImpl lexer(String tokens) {
        return new LexerImpl(new StringReader(tokens));
    }

    @Test
    public void testNumberUpperBoundary() throws Exception {
        LexerImpl lexer = lexer("31");

        TokenImpl token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
        assertEquals((byte)31, token.value);
    }

    @Test
    public void testNumberLowerBoundary() throws Exception {
        LexerImpl lexer = lexer("0");

        TokenImpl token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
        assertEquals((byte)0, token.value);
    }

    @Test
    public void testNumber() throws Exception {
        LexerImpl lexer = lexer("22");

        TokenImpl token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
        assertEquals((byte)22, token.value);
    }

    private void checkInstruction(int id, LexerImpl lexer) throws IOException {
        TokenImpl token = lexer.next_token();
        assertEquals(Token.RESERVED, token.getType());
        assertEquals(id, token.getID());
    }

    private void checkInstructionWithOperand(int id, LexerImpl lexer) throws IOException {
        checkInstruction(id, lexer);

        TokenImpl token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
    }

    @Test
    public void testInstructionsWithOperand() throws Exception {
        checkInstructionWithOperand(TokenImpl.JMP, lexer("jmp 12"));
        checkInstructionWithOperand(TokenImpl.JRP, lexer("jrp 12"));
        checkInstructionWithOperand(TokenImpl.LDN, lexer("ldn 12"));
        checkInstructionWithOperand(TokenImpl.STO, lexer("sto 12"));
        checkInstructionWithOperand(TokenImpl.SUB, lexer("sub 12"));
    }

    @Test
    public void testInstructionsWithoutOperand() throws Exception {
        checkInstruction(TokenImpl.CMP, lexer("cmp"));
        checkInstruction(TokenImpl.STP, lexer("stp"));
    }

    @Test
    public void testInstructionInComment() throws Exception {
        LexerImpl lexer = lexer("// cmp");
        TokenImpl token = lexer.next_token();

        assertEquals(TokenImpl.TCOMMENT, token.getID());
        assertEquals(Token.COMMENT, token.getType());

        token = lexer.next_token();
        assertEquals(Token.TEOF, token.getType());
        assertEquals(TokenImpl.EOF, token.getID());
    }
}
----

Lexer and parser are very interconnected in this case, because Java Cup defines symbol table, which is used by
`TokenImpl` class. It does not yet exist when we have only lexer, so I guess the best way is to continue with parser
and then make it work together.

== Implement parser

The code won't compile so far. The reason is that there are not defined symbols used in the lexer (e.g. `JMP`,
`SEPARATOR_EOL`, etc.). However, the symbols will be generated when the parser (more formally, syntactic analyzer)
will be implemented. Let's do it.

As was mentioned before, the parser generator will be used, called http://www2.cs.tum.edu/projects/cup/[Java cup].
I have prepared Maven plug-in in order to be usable from Maven. This is called `cup-maven-plugin`, and you can see
the definition in the POM file.

There are more options of how to create the parser. The provided URL of Java cup contains lots of documentation. In
this tutorial, an abstract syntax tree will be implemented and created by the parser. Abstract Syntax Tree (or AST) is
a representation of the parsed program source code in a form plausible for further compilation process. It is different
from Parse Syntax Tree, which represents the tree of grammar derivations for the program.

For example, expression "2+2" can be represented using the following AST:

[graphviz]
---------------------------------------------------------------------
digraph ast {
  one [label="2"];
  two [label="2"];

  "+" -> one;
  "+" -> two;
}
---------------------------------------------------------------------

where each node of that tree, regardless if it is leaf or not, is an class in Java, like this example:

[source,java]
----
interface AST {
  int evaluate();
}

class PlusOperator implements AST {
  private final AST left;
  private final AST right;

  public PlusOperator(AST left, AST right) {
    this.left = left;
    this.right = right;
  }

  @Override
  int evaluate() {
    return left.evaluate() + right.evaluate();
  }
}

class Value implements AST {
  private final int value;

  public Value(int value) {
    this.value = value;
  }

  @Override
  public int evaluate() {
    return value;
  }
}
----

And these classes are assembled by the parser, like this imaginary example:

[source,java]
----
AST program = parser.parse("2+2"); // The parser returns: new PlusOperator(new Value(2), new Value(2))
System.out.println(program.evaluate()); // prints "4"
----

This is the basic idea of how parsing works. Now, it is needed to create:

1. Abstract syntax tree classes for our SSEM assembler program
2. Write parser definition file itself, which will contain the grammar and will build the AST for the program

=== Grammar file

Let's start with the parser definition file (or parser specfile). It will be put to `src/main/cup/parser.cup`.
The content is as follows:

[source]
.`src/main/cup/parser.cup`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.Message;
import emulib.plugins.compiler.Token;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;
import net.sf.emustudio.ssem.assembler.tree.Instruction;
import net.sf.emustudio.ssem.assembler.tree.Program;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

parser code {:
    private LexerImpl lexer;
    private boolean syntaxErrors;
    private CompilerImpl compiler;

    public ParserImpl(LexerImpl lex, ComplexSymbolFactory csf, CompilerImpl compiler) {
        super(lex, csf);
        lexer = Objects.requireNonNull(lex);
        compiler = Objects.requireNonNull(compiler);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        done_parsing();
        report_error(message, info);
        throw new Exception("Can\'t recover from previous error(s)");
    }

    @Override
    public void report_error(String messageText, Object current) {
        syntaxErrors = true;

        Token token = (Token)current;

        messageText += ":" + token.getErrorString() + " ('" + token.getText() + "')";

        List expectedTokenIds = expected_token_ids()
            .stream()
            .map(id -> symbl_name_from_id(id.intValue()))
            .collect(Collectors.toList());

        if (!expectedTokenIds.isEmpty()) {
            messageText += "\nExpected tokens: " + expectedTokenIds;
        }

        Message message = new Message(
            Message.MessageType.TYPE_ERROR, messageText, token.getLine()+1, token.getColumn(), null, 0
        );

        if (compiler != null) {
            compiler.notifyOnMessage(message);
        } else {
            System.err.println(message.getFormattedMessage());
        }
    }

    public boolean hasSyntaxErrors() {
        return syntaxErrors;
    }

:};

terminal JMP, JRP, LDN, STO, SUB, CMP, STP, SEPARATOR_EOL, TCOMMENT, ERROR_UNKNOWN_TOKEN;
terminal Byte NUMBER;

non terminal Program Program;
non terminal Instruction Statement;
non terminal Instruction Instruction;
non terminal Comment;

start with Program;

Program ::= Statement:s Program:p                       {: if (s != null) p.statement(s); RESULT = p;  :}
    | /* empty program */                               {: RESULT = new Program(); :}
    ;

Statement ::= Instruction:i Comment SEPARATOR_EOL       {: RESULT = i; :}
    | SEPARATOR_EOL
    ;

Instruction ::= JMP NUMBER:address                      {: RESULT = Instruction.jmp(address); :}
    | JRP NUMBER:address                                {: RESULT = Instruction.jrp(address); :}
    | LDN NUMBER:address                                {: RESULT = Instruction.ldn(address); :}
    | STO NUMBER:address                                {: RESULT = Instruction.sto(address); :}
    | SUB NUMBER:address                                {: RESULT = Instruction.sub(address); :}
    | CMP                                               {: RESULT = Instruction.cmp(); :}
    | STP                                               {: RESULT = Instruction.stp(); :}
    | error
    ;

Comment ::= TCOMMENT
    | /* no comment*/
    ;
----

More-less it is possible to recognize grammar which was defined in section <<GRAMMAR, Grammar for parser>>. The right
side, code snippets wrapped between `{:` and `:}` is Java code which will be executed when particular rule of the
grammar applies. There exist a special variable `RESULT`, which should return some Java object of type which the
non-terminal defines footnote:[For example, `non terminal Instruction Statement;` in the gramamr above defines a
non-terminal `Statement`, which should return an instance of `Instruction` class. The class `Instruction` must be
implemented manually - it is part of AST; there are no special requirements for the implementation.].
I suggest to read Java Cup documentation for more information, especially about the `error` symbol.

=== Abstract Syntax Tree

Classes which non-terminals use are in fact parts of abstract syntax tree of the compiler, namely only these two:

- `Program`
- `Instruction`

Both classes are part of AST. We already know that, but it is not useful information and we do not program this
explicitly if we don't need something which all AST nodes have in common. For now, it's not important to do it.
For now, these will be just normal classes, which will be put into package `net.sf.emustudio.ssem.assembler.tree`.

The initial implementation of the classes follows:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Program.java`
----
package net.sf.emustudio.ssem.assembler.tree;

import java.util.ArrayList;
import java.util.List;

public class Program {
    private final List<Instruction> instructions = new ArrayList<>();

    public void statement(Instruction instruction) {
        instructions.add(instruction);
    }

}
----

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Instruction.java`
----
package net.sf.emustudio.ssem.assembler.tree;

import java.util.Optional;

public class Instruction {
    private final static byte JMP = 0; // 000
    private final static byte JRP = 4; // 100
    private final static byte LDN = 2; // 010
    private final static byte STO = 6; // 110
    private final static byte SUB = 1; // 001
    private final static byte CMP = 3; // 011
    private final static byte STP = 7; // 111

    private final int opcode;
    private final Optional<Byte> operand;

    private Instruction(int opcode, byte operand) {
        this.operand = Optional.of(operand);
        this.opcode = opcode;
    }

    private Instruction(int opcode) {
        this.operand = Optional.empty();
        this.opcode = opcode;
    }

    public int getOpcode() {
        return opcode;
    }

    public Optional<Byte> getOperand() {
        return operand;
    }

    public static Instruction jmp(byte address) {
        return new Instruction(JMP, address);
    }

    public static Instruction jrp(byte address) {
        return new Instruction(JRP, address);
    }

    public static Instruction ldn(byte address) {
        return new Instruction(LDN, address);
    }

    public static Instruction sto(byte address) {
        return new Instruction(STO, address);
    }

    public static Instruction sub(byte address) {
        return new Instruction(SUB, address);
    }

    public static Instruction cmp() {
        return new Instruction(CMP);
    }

    public static Instruction stp() {
        return new Instruction(STP);
    }

}
----

Pay attention to the `Instruction` class. The constructor is private, so there's just impossible to create some
invalid `Instruction` object. The only possible way how to define it is using static factory methods, which represents
the machine instructions. These are called from the parser, please check the parser specfile in the section above.

=== Test it!

Again, it is now very required practice to write unit tests for parser. Here are some code snippets, which can be
implemented right away for testing the parser:

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/ParserTest.java`
----
package net.sf.emustudio.ssem.assembler;

import java_cup.runtime.ComplexSymbolFactory;
import net.sf.emustudio.ssem.assembler.tree.Instruction;
import net.sf.emustudio.ssem.assembler.tree.Program;
import org.junit.Test;

import java.io.StringReader;
import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

public class ParserTest {

    private ParserImpl program(String program) {
        return new ParserImpl(new LexerImpl(new StringReader(program)), new ComplexSymbolFactory());
    }

    @Test
    public void testInstructions() throws Exception {
        ParserImpl parser = program(
            "cmp // comment\n" +
            "stp\n" +
            "jmp 22\n" +
            "jrp 0\n" +
            "ldn 31\n" +
            "sto 10\n" +
            "sub 15\n"
        );

        Program program = (Program) parser.parse().value;
        assertFalse(parser.hasSyntaxErrors());

        Deque<Instruction> expectedInstructions = new LinkedList<>(Arrays.asList(
            Instruction.cmp(),
            Instruction.stp(),
            Instruction.jmp((byte)22),
            Instruction.jrp((byte)0),
            Instruction.ldn((byte)31),
            Instruction.sto((byte)10),
            Instruction.sub((byte)15)
        ));
        program.accept(instruction -> assertEquals(expectedInstructions.removeLast(), instruction));
    }


    @Test(expected = Exception.class)
    public void testInstructionWithoutEOL() throws Exception {
        ParserImpl parser = program("jmp 1");

        parser.parse();
    }

    @Test
    public void testInstructionWithoutProperArgument() throws Exception {
        ParserImpl parser = program("jmp ffff\n");

        parser.parse();
        assertTrue(parser.hasSyntaxErrors());
    }
}
----

== Generating code

It is sometimes very useful to separate algorithm and data representation class. In Java, data representation objects
are often called POJOs, or in database environment DAOs (data access objects). We can use this pattern also in our tree
of parsed program. The tree should contain just information about *what* the program contains. But we can treat the
program in many ways. For example, we can print it, we can check it for semantic errors, we can use it for generating
binary code from it, etc.

Specification of *how* to treat the program should be therefore put separately from the AST itself, in different classes.
There is a very useful design pattern from OOP called https://en.wikipedia.org/wiki/Visitor_pattern[Visitor pattern],
which is exactly what we need here. Within this pattern, our program-treating-algorithm (e.g. a code generator) we will
call a visitor, because of the way how it will work. The basic principle is that the visitor will traverse the program
in a bit tricky way, and when it encounters (visits) a node from AST, it will do something with it (e.g. generate a
code).

So, at first, it is necessary to define the vistor itself. Which AST nodes are useful for traversing? I think that
only `Instruction` node is worth of something. So the visitor interface will look as follows:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/ASTvisitor.java`
----
package net.sf.emustudio.ssem.assembler.tree;

@FunctionalInterface
public interface ASTvisitor {

    void visit(Instruction instruction) throws Exception;

}
----

Now, we can implement a code generator, which will be a visitor. For each encountered instruction it will generate
the binary code. But wait - we need the code for traversing the AST. And here's the trick. The AST itself will know
how to traverse it. This is probably the most tricky part about the Visitor pattern.

In order to define traversal of AST generally, we now need a common interface - `ASTnode` interface, which will define
method for traversing:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/ASTnode.java`
----
package net.sf.emustudio.ssem.assembler.tree;

import net.sf.emustudio.ssem.assembler.CodeGenerator;
import net.sf.emustudio.ssem.assembler.CompileException;

import java.io.IOException;

public interface ASTnode {

    void accept(ASTvisitor visitor) throws Exception;

}
----

This interface will be implemented by AST nodes. The weird `accept()` method implements the traversing. So it in fact
"accepts" a visitor and lets him "visit" current node in a way the visitor defines, taking into account also possible
children nodes. So, let's modify our AST nodes:


[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Program.java`
----
public class Program implements ASTnode {

    ....

    @Override
    public void accept(ASTvisitor visitor) throws Exception {
        for (Instruction instruction : instructions) {
            instruction.accept(visitor);
        }
    }
}
----


[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Instruction.java`
----
public class Instruction implements ASTnode {

    ....

    @Override
    public void accept(CodeGenerator codeGenerator) throws CompileException, IOException {
         codeGenerator.generate(this);
    }
}
----

Now back to the code generation. It is better if I/O classes work with I/O abstractions (streams, channels, etc.) rather
than specific objects, e.g. files. This code generator will be implemented in a similar fashion. The code is as follows:


[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CodeGenerator.java`
----
package net.sf.emustudio.ssem.assembler;

import net.sf.emustudio.ssem.assembler.tree.ASTvisitor;
import net.sf.emustudio.ssem.assembler.tree.Instruction;

import java.io.DataOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Objects;

public class CodeGenerator implements ASTvisitor, AutoCloseable {
    private final DataOutputStream writer;

    public CodeGenerator(OutputStream writer) {
        this.writer= new DataOutputStream(Objects.requireNonNull(writer));
    }

    @Override
    public void visit(Instruction instruction) throws CompileException, IOException {
        byte address = instruction.getOperand().orElse((byte)0);

        if (address < 0 || address > 31) {
            throw new CompileException("Operand must be between <0, 31>; it was " + address);
        }

        // Instruction has 32 bits, i.e. 4 bytes

        int addressSSEM = (((address >> 4) & 1)
            | ((address >> 3) & 1)
            | ((address >> 2) & 1)
            | ((address >> 1) & 1)
            | (address & 1)) << 3;

        writer.writeByte(addressSSEM); // address + 3 empty bits

        // next: 5 empty bits + 3 bit instruction
        int opcode = instruction.getOpcode();
        int opcodeSSEM =((opcode >> 2) & 1)
            | ((opcode >> 1) & 1)
            | (opcode & 1);

        writer.writeByte(opcodeSSEM);

        // 16 empty bits
        writer.write(new byte[2]);
    }

    @Override
    public void close() throws Exception {
        writer.close();
    }
}
----

What it does is basically creating a 4-byte SSEM instruction, its binary format. As was mentioned before, SSEM uses
"reversed" bits for number representations. This is the reason why the address number is twisted. Before that, it is
however necessary to check the address boundary, which is 2^5 (maximum). The rest should be clear, we're making
instruction with format specified in section <<GETTING_STARTED,Getting started>>.

=== Test it!

As being our practice, we must test it.

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/CodeGeneratorTest.java`
----
package net.sf.emustudio.ssem.assembler;

import net.sf.emustudio.ssem.assembler.tree.Instruction;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.ByteArrayOutputStream;

import static org.junit.Assert.assertArrayEquals;

public class CodeGeneratorTest {

    private ByteArrayOutputStream out;
    private CodeGenerator codeGenerator;

    @Before
    public void setUp() throws Exception {
        out = new ByteArrayOutputStream(32);
        codeGenerator = new CodeGenerator(out);
    }

    @After
    public void tearDown() throws Exception {
        codeGenerator.close();
    }

    @Test
    public void testCMP() throws Exception {
        codeGenerator.visit(Instruction.cmp());

        assertArrayEquals(new byte[] {0,Instruction.CMP,0,0}, out.toByteArray());
    }

    @Test
    public void testSTP() throws Exception {
        codeGenerator.visit(Instruction.stp());

        assertArrayEquals(new byte[] {0,Instruction.STP,0,0}, out.toByteArray());
    }

    @Test
    public void testJMP() throws Exception {
        codeGenerator.visit(Instruction.jmp((byte)6));

        assertArrayEquals(new byte[] {0x60,Instruction.JMP,0,0}, out.toByteArray());
    }

    @Test
    public void testJRP() throws Exception {
        codeGenerator.visit(Instruction.jrp((byte)23));

        assertArrayEquals(new byte[] {(byte)0xE8,Instruction.JRP,0,0}, out.toByteArray());
    }

    @Test
    public void testLDN() throws Exception {
        codeGenerator.visit(Instruction.ldn((byte)12));

        assertArrayEquals(new byte[] {(byte)0x30,Instruction.LDN,0,0}, out.toByteArray());
    }

    @Test
    public void testSTO() throws Exception {
        codeGenerator.visit(Instruction.sto((byte)30));

        assertArrayEquals(new byte[] {(byte)0x78,Instruction.STO,0,0}, out.toByteArray());
    }

    @Test
    public void testSUB() throws Exception {
        codeGenerator.visit(Instruction.sub((byte)18));

        assertArrayEquals(new byte[] {(byte)0x48,Instruction.SUB,0,0}, out.toByteArray());
    }

}
----

== Finalizing, implementing the rest

We're almost done now! What is missing so far is to finish implementation of the main `CompilerImpl` class.
Let's do it.

The most interesting is the `compile()` method. So let's begin with it first.

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CompilerImpl.java`
----
public class CompilerImpl extends AbstractCompiler {

    ....

    @Override
    public boolean compile(String inputFileName, String outputFileName) {

        notifyCompileStart();

        int errorCode = 0;
        try (Reader reader = new FileReader(inputFileName)) {
            try (CodeGenerator codeGenerator = new CodeGenerator(new FileOutputStream(outputFileName))) {
                LexerImpl lexer = new LexerImpl(reader);
                ParserImpl parser = new ParserImpl(lexer, new ComplexSymbolFactory(), this);

                Program program = (Program) parser.parse().value;
                if (program == null) {
                    throw new Exception("Unexpected end of file");
                }
                if (parser.hasSyntaxErrors()) {
                    throw new Exception("One or more errors has been found, cannot continue.");
                }

                program.accept(codeGenerator);
                notifyInfo("Compile was successful. Output: " + outputFileName);
            }
        } catch (Exception e) {
            errorCode = 1;
            return false;
        } finally {
            notifyCompileFinish(errorCode);
        }

        return true;
    }

    ....
}
----

As input, we have full path to the input file, and to the output file. It is good to use some Java 7 try-with-resources
statement for opening the files. The same approach can be used for the code generator, because the class implements
`AutoCloseable` interface.

We want to notify emuStudio about compilation progress, as we have already done in the parser, when dealing with
parsing errors. For this purpose, `emulib.plugins.compiler.AbstractCompiler` class offers several methods:

- `notifyCompileStart()`, which will inform emuStudio that the compilation has started,
- `notifyCompileFinish(errorCode)` will inform emuStudio that the compilation has finished, with given error code. footnote:[The
  error code should be defined by you, developer, if you want. It is a convention used also in other compilers that
  specific error has assigned a unique number. In our compiler, we do not use it.]
- `notifyOnMessage()` - notifies emuStudio about some general message, it can be either error, info, warning.
- `notifyWarning()` - compiler warning
- `notifyError()` - compilation error
- `notifyInfo()` - informational message

=== Loading compiler program into memory

The very last part I leave as an excercise. In provided source codes this functionality is ofcourse implemented,
but at the end - it is up to you if you'll use my solution or not.
