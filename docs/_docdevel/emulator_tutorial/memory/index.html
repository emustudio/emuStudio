<!--
  ~ This file is part of emuStudio.
  ~
  ~ Copyright (C) 2006-2020  Peter Jakubčo
  ~
  ~ This program is free software: you can redistribute it and/or modify
  ~ it under the terms of the GNU General Public License as published by
  ~ the Free Software Foundation, either version 3 of the License, or
  ~ (at your option) any later version.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ~ GNU General Public License for more details.
  ~
  ~ You should have received a copy of the GNU General Public License
  ~ along with this program.  If not, see <https://www.gnu.org/licenses/>.
  -->

<!DOCTYPE html>
<html lang="en">
<head>

    <!-- Meta -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <title>Memory &diams; emuStudio</title>
    <meta name="keywords"
          content="emulator-programming,emulation-platform,emulation-framework,altair8800,Z80,intel-8080,SSEM,RAM,RASP,random-access-machine,random-access-stored-program-machine">
    <meta name="description" content="Universal computer emulation platform and framework.">
    <meta name=”robots” content=”noindex,follow”>

    <meta property="og:title" content="Memory">
    <meta property="og:image" content="../../../img/logo-2.svg">
    <meta property="og:description" content="Universal computer emulation platform and framework.">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="emuStudio &diams; Computer emulation platform/framework"
          href="../../../feed.xml">
    <link rel="alternate" type="application/atom+xml" title="emuStudio &diams; Computer emulation platform/framework"
          href="../../../atom.xml">

    <!-- Favicons -->
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico?">
    <meta name="application-name" content="emuStudio &diams; Computer emulation platform/framework">
    <meta name="msapplication-TileColor" content="#ffffff">

    <!-- Fonts -->
    <link rel="stylesheet"
          href="//fonts.googleapis.com/css?family=Roboto+Condensed:300,300italic,400,400italic,700,700italic|Oswald:300,400,700">

    <!-- Styles -->
    <link rel="stylesheet" href="../../../css/style.css">


    <!-- Scripts -->

    <!--[if lt IE 9]>
        <script src="../../../js/html5shiv.min.js"></script>
        <script src="../../../js/respond.min.js"></script>
    [endif]-->

    <script src="../../../js/jquery-3.1.1.min.js"></script>
    <script src="../../../js/bootstrap.min.js"
            integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
            crossorigin="anonymous">
    </script>


    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-3492956-5"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-3492956-5');

    </script>

</head>


<body>


<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar"
                    aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/"><i><img alt="&diams;" style="margin: -5px;margin-right:2px;"
                                                     src="../../../img/logo-2.svg" width="30px"/></i>emuStudio</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <!--<form class="navbar-form navbar-left" role="search">-->
            <!--<div class="form-group">-->
            <!--<input type="text" class="form-control" placeholder="Search website">-->
            <!--</div>-->
            <!--<button type="submit" class="btn btn-default">Submit</button>-->
            <!--</form>-->
            <ul class="nav navbar-nav navbar-right">

                <li>
                    <a href="/">Home</a>
                </li>

                <li>
                    <a href="/download">Download</a>
                </li>

                <li>
                    <a href="/docs">Docs</a>
                </li>

                <li>
                    <a href="/devel">Developer</a>
                </li>

                <li>
                    <a href="/roadmap">Roadmap</a>
                </li>

                <li>
                    <a href="/about">About</a>
                </li>

            </ul>
        </div>
    </div>
</nav>


<div class="title-group">
    <h1 class="special" data-toc-skip>
      <span>
          
            Memory
          
      </span>
    </h1>


</div>


<div class="container">
    <div class="sect1">
        <h2 id="MEMORY_HOWTO">Writing a memory</h2>
        <div class="sectionbody">
            <div class="paragraph">
                <p>This tutorial will describe some basic knowledge about how to create an operating memory to be used
                    in emuStudio.
                    In emuStudio, virtual computers usually conform to von-Neumann architecture. In this architecture,
                    the memory is a
                    separate component. The tutorial focuses on how to use emuLib API in a memory for SSEM computer.</p>
            </div>
            <div class="sect2">
                <h3 id="MEMORY_GETTING_STARTED">Getting started</h3>
                <div class="paragraph">
                    <p>Before reading on, please read the <a href="#INTRODUCTION_PLUGINS">[INTRODUCTION_PLUGINS]</a>
                        chapter. It gives the information
                        needed for setting up the development environment and for basic understanding how the
                        emuStudio/plug-ins lifecycle
                        work.</p>
                </div>
                <div class="paragraph">
                    <p>Within this tutorial, we will implement a main store of SSEM "Baby" machine, to conform with
                        other tutorials for other
                        plug-ins. Before we start, here&#8217;s a few words about what purpose and capabilities memories
                        in emuStudio can have.</p>
                </div>
                <div class="paragraph">
                    <p>In first stored-program computers, operating memory was accessible only by CPU. It means that all
                        data between the memory and other devices had to be transferred through CPU. When data from
                        memory was required,
                        CPU "paused" the execution of instructions and accessed the memory in the meantime. This slowed
                        down CPU and consequently
                        the whole program. Later, DMA (direct memory access) capability was introduced, which allowed
                        devices
                        to directly access the memory, or be notified when the memory changes.</p>
                </div>
                <div class="paragraph">
                    <p>In emuStudio, you can connect the memory with devices, or even with a compiler. This is one
                        example of the versatility
                        and power of emuStudio.</p>
                </div>
                <div class="paragraph">
                    <p>There are three main behavioral contracts which need to be taken into account, when creating
                        memory plug-in:</p>
                </div>
                <div class="ulist">
                    <ul>
                        <li>
                            <p>Memory can be connected with none, one or more plug-ins of any type</p>
                        </li>
                        <li>
                            <p>Memory plug-in is necessary for creating a virtual machine (emuStudio requires it)</p>
                        </li>
                        <li>
                            <p>Operations of memory can be extended using special class called "context"</p>
                        </li>
                    </ul>
                </div>
                <div class="paragraph">
                    <p>The implication is that the memory can be shared across CPU and devices, and the communication
                        can be optimized with
                        custom operations. The context class is a customization which extends default context behavior.
                        This tutorial will
                        cover some basics in this topic.</p>
                </div>
                <div class="sect3">
                    <h4 id="ssem-memory">SSEM memory</h4>
                    <div class="paragraph">
                        <p>SSEM used the world&#8217;s first random-access memory called Williams or Williams-Kilburn
                            tube
                            <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1"
                                                      title="View footnote.">1</a>]</sup>. The
                            used principle was the same as in standard Cathode-Ray-Tubes (CRTs). Original EDSAC computer
                            (which introduced the
                            von Neumann architecture) did not have random-access memory.</p>
                    </div>
                    <div class="paragraph">
                        <p>The memory had 32 memory cells (called words), each had size of 32 bits. The memory could
                            contain instructions and
                            data. So, one SSEM instruction perfectly fits in the single memory word.</p>
                    </div>
                    <div class="paragraph">
                        <p>Within this tutorial, we will hardcode the word size and memory size. But we&#8217;ll also
                            implement a GUI for the memory,
                            which is often far more complicated than the emulated memory itself <sup
                                    class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2"
                                                         title="View footnote.">2</a>]</sup></p>
                    </div>
                </div>
            </div>
            <div class="sect2">
                <h3 id="preparing-the-environment">Preparing the environment</h3>
                <div class="paragraph">
                    <p>In order to start developing the memory, create new Java project. Here, Maven will be used for
                        dependencies management.
                        The plug-in will be implemented as another standard emuStudio plug-in, so it will inherit Maven
                        plug-in dependencies
                        from the main POM file.</p>
                </div>
                <div class="paragraph">
                    <p>The project should be located at <code>emuStudio/plugins/mem/ssem-mem</code>, and should contain
                        the following structure:</p>
                </div>
                <div class="literalblock">
                    <div class="content">
<pre>src/
  main/
    java/
    resources/
test/
  java/
pom.xml</pre>
                    </div>
                </div>
                <div class="admonitionblock note">
                    <table>
                        <tr>
                            <td class="icon">
                                <i class="fa icon-note" title="Note"></i>
                            </td>
                            <td class="content">
                                Note the naming of the plug-in. It follows the naming convention as described in the <a
                                    href="#INTRODUCTION_NAMING">[INTRODUCTION_NAMING]</a>
                                guide.
                            </td>
                        </tr>
                    </table>
                </div>
                <div class="paragraph">
                    <p>The POM file of the project might look as follows:</p>
                </div>
                <div class="listingblock">
                    <div class="title"><code>ssem-mem/pom.xml</code></div>
                    <div class="content">
                        <pre class="pygments highlight"><code data-lang="xml"><span></span>Unresolved directive in memory.adoc - include::{sourcedir}/plugins/mem/ssem-mem/pom.xml[]</code></pre>
                    </div>
                </div>
                <div class="paragraph">
                    <p>And let&#8217;s start with the first Java class, the main plug-in class. Let&#8217;s put it to
                        package
                        <code>net.sf.net.emustudio.ssem.memory</code>, and call it <code>MemoryImpl</code>.</p>
                </div>
            </div>
            <div class="sect2">
                <h3 id="MEMORY_BASIC_STUFF">The main class</h3>
                <div class="paragraph">
                    <p>Go to the <code>MemoryImpl</code> class source. Extend the class from <code>emulib.plugins.memory.AbstractMemory</code>
                        class.
                        The class extends from <code>Memory</code> interface and implements the most common methods,
                        usable by all memories.</p>
                </div>
                <div class="paragraph">
                    <p>It is also necessary to annotate the class with <code>emulib.annotations.PluginType</code>
                        annotation, which is required for every
                        main class of any emuStudio plug-in. The code snippet looks as follows:</p>
                </div>
                <div class="listingblock">
                    <div class="title"><code>src/main/java/net/sf/net.emustudio/ssem/memory/MemoryImpl.java</code></div>
                    <div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span style="color: #008000; font-weight: bold">package</span> <span
        style="color: #0000FF; font-weight: bold">net.sf.net.emustudio.ssem.memory</span><span
        style="color: #666666">;</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">emulib.annotations.PLUGIN_TYPE</span><span
            style="color: #666666">;</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">emulib.annotations.PluginType</span><span
            style="color: #666666">;</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">emulib.plugins.memory.AbstractMemory</span><span
            style="color: #666666">;</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">emulib.runtime.ContextPool</span><span
            style="color: #666666">;</span>

<span style="color: #AA22FF">@PluginType</span><span style="color: #666666">(</span>
        type <span style="color: #666666">=</span> PLUGIN_TYPE<span style="color: #666666">.</span><span
            style="color: #7D9029">MEMORY</span><span style="color: #666666">,</span>
        title <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;SSEM memory&quot;</span><span
            style="color: #666666">,</span>
        copyright <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;\u00A9 Copyright 2016, Peter Jakubčo&quot;</span><span
            style="color: #666666">,</span>
        description <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Main store for SSEM machine&quot;</span>
<span style="color: #666666">)</span>
<span style="color: #008000; font-weight: bold">public</span> <span
            style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">MemoryImpl</span> <span
            style="color: #008000; font-weight: bold">extends</span> AbstractMemory <span
            style="color: #666666">{</span>
    <span style="color: #008000; font-weight: bold">private</span> <span
            style="color: #008000; font-weight: bold">final</span> <span style="color: #008000; font-weight: bold">static</span> Logger LOGGER <span
            style="color: #666666">=</span> LoggerFactory<span style="color: #666666">.</span><span
            style="color: #7D9029">getLogger</span><span style="color: #666666">(</span>MemoryImpl<span
            style="color: #666666">.</span><span style="color: #7D9029">class</span><span
            style="color: #666666">);</span>

    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #0000FF">MemoryImpl</span><span
            style="color: #666666">(</span>Long pluginID<span
            style="color: #666666">,</span> ContextPool contextPoolImpl<span style="color: #666666">)</span> <span
            style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">super</span><span style="color: #666666">(</span>pluginID<span
            style="color: #666666">);</span>
    <span style="color: #666666">}</span>

    <span style="color: #408080; font-style: italic">// ... other methods ...</span>
<span style="color: #666666">}</span></code></pre>
                    </div>
                </div>
                <div class="admonitionblock note">
                    <table>
                        <tr>
                            <td class="icon">
                                <i class="fa icon-note" title="Note"></i>
                            </td>
                            <td class="content">
                                The constructor presented here is mandatory. This is one of the behavioral contracts,
                                emuStudio expects
                                that a plug-in will have a constructor with two arguments: <code>pluginID</code>
                                (assigned by emuStudio), and a context
                                pool, which is a storage or registrar of all plug-ins contexts.
                            </td>
                        </tr>
                    </table>
                </div>
            </div>
            <div class="sect2">
                <h3 id="few-notes-on-ssem-memory">Few notes on SSEM memory</h3>
                <div class="paragraph">
                    <p>When thinking about computer memory - what is it? During time, memory abstraction has evolved to
                        an idea of memory
                        as a collection of cells, equally-sized, which are ordered sequentially. This is the simplest
                        description, and I
                        would say that more-less all memories look like this. When emulating a computer memory in a
                        programming language like
                        Java, it would be then just a plain array.</p>
                </div>
                <div class="paragraph">
                    <p>SSEM had 32 so-called "lines", which represented cells in memory. Each line, or a cell, was 4
                        bytes long. It is therefore
                        tempting to implement SSEM memory as array of integers, because <code>int</code> type has 4
                        bytes.</p>
                </div>
                <div class="paragraph">
                    <p>It is indeed possible, but we will face to an unsolvable problem when implementing CPU, if we
                        want to use Edigen
                        <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3"
                                                  title="View footnote.">3</a>]</sup>.
                        Unfortunately, Edigen is so-far designed in a way that it expects the memory having cell size of
                        a byte, not more.
                        Therefore, we will keep that also for SSEM memory emulation, but visually try to present it as
                        having 4-byte cells. It
                        would require additional mathematics when working with memory (in the CPU tutorial you would
                        find it as well), but
                        not having impact on performance.</p>
                </div>
            </div>
            <div class="sect2">
                <h3 id="memory-context">Memory context</h3>
                <div class="paragraph">
                    <p>Abstracts are helping us to understand ideas and see how they can be composed into a whole. In
                        this fashion, memory
                        main interface, presented in section <a href="#MEMORY_BASIC_STUFF">The main class</a>, is the
                        communication point with emuStudio. The main module is
                        using methods in this interface. The communication with CPU and devices is done through another
                        concept, which is called
                        a context. The contexts differ for various plug-ins; and they can be customized.</p>
                </div>
                <div class="paragraph">
                    <p>Plug-ins which provide a context, must register it to the <code>ContextPool</code>, given in a
                        constructor in the main plugin class.
                        This registration should be performed as early as possible - in the constructor itself. After
                        all plug-ins are
                        instantiated, emuStudio expects that all contexts are already registered.</p>
                </div>
                <div class="paragraph">
                    <p>The next step, generally true for all plug-ins, is calling of <code>Plugin.initialize()</code>
                        method, in this case -
                        <code>Memory.initialize()</code>. The initialization can now use the context pool for different
                        purpose - for obtaining contexts,
                        if it requires some. More on this topic can be found in the <a href="#INTRODUCTION_BEHAVIORAL">[INTRODUCTION_BEHAVIORAL]</a>
                        section.</p>
                </div>
                <div class="paragraph">
                    <p>So, in our case - we must create a memory context, which will be used by SSEM CPU and SSEM CRT
                        display. We don&#8217;t need
                        special customized context, so we can comfortably extend from class
                        <code>AbstractMemoryContext</code>, which will implement some
                        methods of the <code>MemoryContext</code> interface for us. We will call the class <code>MemoryContextImpl</code>:
                    </p>
                </div>
                <div class="listingblock">
                    <div class="title">
                        <code>src/main/java/net/sf/net.emustudio/ssem/memory/impl/MemoryContextImpl.java</code></div>
                    <div class="content">
                        <pre class="pygments highlight"><code data-lang="java"><span></span>Unresolved directive in memory<span
                                style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span
                                style="color: #666666">-</span> include<span
                                style="color: #666666">::{</span>sourcedir<span
                                style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span
                                style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span
                                style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span
                                style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span
                                style="color: #666666">/</span>sf<span style="color: #666666">/</span>net.emustudio<span
                                style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span
                                style="color: #666666">/</span>impl<span style="color: #666666">/</span>MemoryContextImpl<span
                                style="color: #666666">.</span><span style="color: #7D9029">java</span><span
                                style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
                    </div>
                </div>
                <div class="paragraph">
                    <p>As you can see, SSEM memory is indeed an array of bytes. This is the "core" idea of a memory.
                        Ofcourse, it is possible
                        to use a <code>java.util.List</code> or another collection, but we should keep eye on
                        performance. Array is the simplest structure
                        with access time O(1). Therefore, we chose array.</p>
                </div>
                <div class="paragraph">
                    <p>Also notice that the class <code>AbstractMemoryContext</code>, and also interface <code>MemoryContext</code>
                        take a generic parameter
                        <code>T extends Number</code>. This parameter is saying of what type cell is. In our case,
                        <code>T</code> is a <code>Byte</code>. Due unhappy Java
                        limitation, primitive types cannot be used in generics, so we can&#8217;t have something like
                        <code>MemoryContext&lt;byte&gt;</code>.</p>
                </div>
            </div>
            <div class="sect2">
                <h3 id="gui">GUI</h3>
                <div class="paragraph">
                    <p>Since emuStudio is interactive application, GUIs are a natural thing. Each memory plug-in should
                        have its own GUI.
                        The supported features can be any, but keep in mind, that GUI control in Swing is done in
                        separate thread, often
                        called "UI Thread". On the other hand, emulation itself is running in different, dedicated,
                        thread, created in emuLib.</p>
                </div>
                <div class="paragraph">
                    <p>This means that the access to memory context should be synchronized. However, synchronization is
                        very slow.
                        Much better approach is to use a non-blocking algorithm for locking, if we really require
                        absolutely reliable
                        manipulation of memory cells in between threads. However, non-blocking algorithms are harder to
                        implement good.
                        In our tutorial we will do a trade-off, which we can afford - since we have final array of
                        bytes, we have the following
                        guarantees:</p>
                </div>
                <div class="olist arabic">
                    <ol class="arabic">
                        <li>
                            <p>the array itself will be always valid and visible to all accessing threads. Meaning -
                                reading is always safe.</p>
                        </li>
                        <li>
                            <p>we expect our host CPU can write a byte at once; therefore it is atomic. This does not
                                have to hold for all CPUs - don&#8217;t
                                worry, all x86 CPUs have it.</p>
                        </li>
                        <li>
                            <p>According to <a
                                    href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.6">Java
                                Language Specification, Chapter 17.6</a>:</p>
                            <div class="literalblock">
                                <div class="content">
<pre>two threads that update adjacent elements of a byte array separately must not interfere or interact and do not need
synchronization to ensure sequential consistency.</pre>
                                </div>
                            </div>
                        </li>
                    </ol>
                </div>
                <div class="paragraph">
                    <p>I consider these guarantees as good enough to leave the synchronization be. I guess the
                        probability of modifying
                        the same memory cells from both running emulation and by the user in GUI, is very small. What&#8217;s
                        more, you shouldn&#8217;t
                        modify memory cells at all when the emulation is running.</p>
                </div>
                <div class="paragraph">
                    <p>Now back to our GUI. It would be good if the GUI is looking good, so it&#8217;s up to you how you&#8217;ll
                        draw the main form. It
                        can be a class extending from a <code>javax.swing.JFrame</code> or
                        <code>javax.swing.JDialog</code>. The look might be as follows:</p>
                </div>
                <div class="imageblock">
                    <div class="content">
                        <img src="/docdevel/emulator_tutorial/images//ssem-memory.png"
                             alt="SSEM Memory GUI sample look">
                    </div>
                </div>
                <div class="paragraph">
                    <p>So, we will need a custom memory model, a custom memory table - which will have a row header (the
                        very first, gray-colored
                        column) and column header (the very first, gray-colored row).</p>
                </div>
                <div class="paragraph">
                    <p>As you can see in the picture, a row represents single SSEM memory cell - 32 scattered bits, and
                        the last few columns
                        show both the number the bits represent, and a raw ASCII value of the 4-byte sequence of
                        data.</p>
                </div>
                <div class="paragraph">
                    <p>Also, we would like to let user edit the cells manually - just by pointing to a bit, and pressing
                        either 1 or 0 - possibly
                        a DELETE key, committing the change immediately. We want to allow editing also for the value
                        itself, and for the data column
                        as well.</p>
                </div>
                <div class="paragraph">
                    <p>In addition, movement around cells should be possible with arrow keys.</p>
                </div>
                <div class="paragraph">
                    <p>For those "specifications", we will need to customize standard <code>javax.swing.JTable</code>,
                        create custom memory model, cell
                        editor, cell renderer and introduce row header renderer.</p>
                </div>
                <div class="paragraph">
                    <p>The source code of the main GUI class is here:</p>
                </div>
                <div class="listingblock">
                    <div class="title"><code>src/main/java/net/sf/net.emustudio/ssem/memory/gui/MemoryGUI.java</code></div>
                    <div class="content">
                        <pre class="pygments highlight"><code data-lang="java"><span></span>Unresolved directive in memory<span
                                style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span
                                style="color: #666666">-</span> include<span
                                style="color: #666666">::{</span>sourcedir<span
                                style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span
                                style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span
                                style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span
                                style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span
                                style="color: #666666">/</span>sf<span style="color: #666666">/</span>net.emustudio<span
                                style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span
                                style="color: #666666">/</span>gui<span style="color: #666666">/</span>MemoryGUI<span
                                style="color: #666666">.</span><span style="color: #7D9029">java</span><span
                                style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
                    </div>
                </div>
                <div class="paragraph">
                    <p>Note that in the constructor we create a memory listener, which implements <code>Memory.MemoryListener</code>
                        interface. The
                        listener will receive events about external memory changes - in our case, from CPU emulator. Our
                        reaction is - as
                        supposed to be - reflect the change in the memory GUI.</p>
                </div>
                <div class="admonitionblock note">
                    <table>
                        <tr>
                            <td class="icon">
                                <i class="fa icon-note" title="Note"></i>
                            </td>
                            <td class="content">
                                The caller thread of listener methods is the one who calls <code>Memory.write()</code>
                                on the other end. In our case, it
                                can be either the emulator dedicated thread, as described above, or the user itself,
                                doing changes in the UI
                                thread.
                            </td>
                        </tr>
                    </table>
                </div>
                <div class="paragraph">
                    <p>Also, we use custom memory table, which extends from <code>javax.swing.table.JTable</code>. We
                        will describe it now.</p>
                </div>
                <div class="sect3">
                    <h4 id="memory-table">Memory table</h4>
                    <div class="paragraph">
                        <p>Since we want "special" behavior, like custom cell renderer, custom row header, custom cell
                            editor and custom widths
                            of some columns, it will be good to wrap it up in a custom <code>JTable</code>. The code
                            looks as follows:</p>
                    </div>
                    <div class="listingblock">
                        <div class="title"><code>src/main/java/net/sf/net.emustudio/ssem/memory/gui/MemoryTable.java</code>
                        </div>
                        <div class="content">
                            <pre class="pygments highlight"><code data-lang="java"><span></span>Unresolved directive in memory<span
                                    style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span
                                    style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span
                                    style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span
                                    style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span
                                    style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span
                                    style="color: #666666">/</span>sf<span style="color: #666666">/</span>net.emustudio<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span
                                    style="color: #666666">/</span>gui<span
                                    style="color: #666666">/</span>MemoryTable<span style="color: #666666">.</span><span
                                    style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span
                                    style="color: #666666">=20..-1]</span></code></pre>
                        </div>
                    </div>
                    <div class="paragraph">
                        <p>Now, particular sub-components of the table will be implemented and described in more
                            detail.</p>
                    </div>
                </div>
                <div class="sect3">
                    <h4 id="memory-table-model">Memory table model</h4>
                    <div class="paragraph">
                        <p>Memory model is the "back-end" of the memory GUI. It means, the model provide data which
                            should be shown in the GUI.
                            You can think of any Swing component as a combination of a "view" and "model" subcomponents.
                            The "view" subcomponent
                            "asks" the model about which data should be shown. By default, almost all Swing components
                            use some default models,
                            accessible directly from the Swing component. Consequently, the components allow to set
                            custom models as well, which
                            is our case.</p>
                    </div>
                    <div class="paragraph">
                        <p>For a table, the model must implement <code>javax.swing.table.TableModel</code> interface. As
                            it is often a custom, Java implements
                            some general methods in an abstract class called
                            <code>javax.swing.table.AbstractTableModel</code> we can extend from.</p>
                    </div>
                    <div class="admonitionblock note">
                        <table>
                            <tr>
                                <td class="icon">
                                    <i class="fa icon-note" title="Note"></i>
                                </td>
                                <td class="content">
                                    The description of the table model can be found <a
                                        href="http://docs.oracle.com/javase/tutorial/uiswing/components/table.html#data">at
                                    this link</a>.
                                </td>
                            </tr>
                        </table>
                    </div>
                    <div class="paragraph">
                        <p>The model must provide data for every row and column. So here, we must do some math to
                            compute bits and also transform
                            the data to hex value, and raw ASCII value. The class is called
                            <code>MemoryTableModel</code> and it&#8217;s source code is here:</p>
                    </div>
                    <div class="listingblock">
                        <div class="title">
                            <code>src/main/java/net/sf/net.emustudio/ssem/memory/gui/MemoryTableModel.java</code></div>
                        <div class="content">
                            <pre class="pygments highlight"><code data-lang="java"><span></span>Unresolved directive in memory<span
                                    style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span
                                    style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span
                                    style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span
                                    style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span
                                    style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span
                                    style="color: #666666">/</span>sf<span style="color: #666666">/</span>net.emustudio<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span
                                    style="color: #666666">/</span>gui<span style="color: #666666">/</span>MemoryTableModel<span
                                    style="color: #666666">.</span><span style="color: #7D9029">java</span><span
                                    style="color: #666666">[</span>lines<span
                                    style="color: #666666">=20..-1]</span></code></pre>
                        </div>
                    </div>
                </div>
                <div class="sect3">
                    <h4 id="row-header-renderer">Row header renderer</h4>
                    <div class="paragraph">
                        <p>Programming a GUI in Java Swing can be tricky. If we want something non-standard, the way of
                            customization can be
                            very non-obvious = painful. This is the case when we want to do a "header"-like column in a
                            <code>JTable</code>. Long story
                            short - this trick lies in a use of <code>JScrollPane</code>. This component implements a
                            viewport, something as a virtual screen,
                            allowing to put there some other components, and make visible only a part of this screen.
                            Besides, it has a feature
                            which is called a "row header". It has a <a
                                    href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JScrollPane.html#setRowHeaderView-java.awt.Component-">dedicated
                                method</a>
                            for setting up a custom row header:</p>
                    </div>
                    <div class="literalblock">
                        <div class="content">
                            <pre>JScrollPane.setRowHeaderView(Component view)</pre>
                        </div>
                    </div>
                    <div class="paragraph">
                        <p>The trick is to set a <code>javax.swing.JList</code> as a component for the row header. So we
                            end up with the following class:</p>
                    </div>
                    <div class="listingblock">
                        <div class="title">
                            <code>src/main/java/net/sf/net.emustudio/ssem/memory/gui/RowHeaderRenderer.java</code></div>
                        <div class="content">
                            <pre class="pygments highlight"><code data-lang="java"><span></span>Unresolved directive in memory<span
                                    style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span
                                    style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span
                                    style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span
                                    style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span
                                    style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span
                                    style="color: #666666">/</span>sf<span style="color: #666666">/</span>net.emustudio<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span
                                    style="color: #666666">/</span>gui<span style="color: #666666">/</span>RowHeaderRenderer<span
                                    style="color: #666666">.</span><span style="color: #7D9029">java</span><span
                                    style="color: #666666">[</span>lines<span
                                    style="color: #666666">=20..-1]</span></code></pre>
                        </div>
                    </div>
                </div>
                <div class="sect3">
                    <h4 id="cell-renderer-editor">Cell renderer + editor</h4>
                    <div class="paragraph">
                        <p>The last two things we need is to display text using different fonts on certain cells. For
                            example, we want that line
                            and instruction bits have bold font, and others plain one. But - it is generally more
                            readable if the data are shown
                            in some monospaced font variant. These customizations are "big enough" to require custom
                            class - a cell renderer.</p>
                    </div>
                    <div class="admonitionblock note">
                        <table>
                            <tr>
                                <td class="icon">
                                    <i class="fa icon-note" title="Note"></i>
                                </td>
                                <td class="content">
                                    Official tutorial and description of custom renderers can be found
                                    <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/table.html#renderer">at
                                        this link</a>.
                                </td>
                            </tr>
                        </table>
                    </div>
                    <div class="paragraph">
                        <p>The cell renderer code looks as follows:</p>
                    </div>
                    <div class="listingblock">
                        <div class="title"><code>src/main/java/net/sf/net.emustudio/ssem/memory/gui/CellRenderer.java</code>
                        </div>
                        <div class="content">
                            <pre class="pygments highlight"><code data-lang="java"><span></span>Unresolved directive in memory<span
                                    style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span
                                    style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span
                                    style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span
                                    style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span
                                    style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span
                                    style="color: #666666">/</span>sf<span style="color: #666666">/</span>net.emustudio<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span
                                    style="color: #666666">/</span>gui<span
                                    style="color: #666666">/</span>CellRenderer<span
                                    style="color: #666666">.</span><span style="color: #7D9029">java</span><span
                                    style="color: #666666">[</span>lines<span
                                    style="color: #666666">=20..-1]</span></code></pre>
                        </div>
                    </div>
                    <div class="paragraph">
                        <p>Similarly, if we want to let user edit a value in a table, we must provide the editor as a
                            Swing component. The
                            "cell editor" is in fact plain <code>javax.swing.JTextField</code> with some customizations.
                            However if we want to use it,
                            we must wrap it in a separate class, which needs to extend <code>AbstractCellEditor</code>
                            and implement <code>TableCellEditor</code>.</p>
                    </div>
                    <div class="paragraph">
                        <p>Our customizations involve accommodating the width of the text field, and preparing the
                            initial value when the
                            editor shows up. User can activate the editor by double-clicking on a cell. The source code
                            of the cell editor is
                            as follows:</p>
                    </div>
                    <div class="listingblock">
                        <div class="title"><code>src/main/java/net/sf/net.emustudio/ssem/memory/gui/CellEditor.java</code>
                        </div>
                        <div class="content">
                            <pre class="pygments highlight"><code data-lang="java"><span></span>Unresolved directive in memory<span
                                    style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span
                                    style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span
                                    style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span
                                    style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span
                                    style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span
                                    style="color: #666666">/</span>sf<span style="color: #666666">/</span>net.emustudio<span
                                    style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span
                                    style="color: #666666">/</span>gui<span
                                    style="color: #666666">/</span>CellEditor<span style="color: #666666">.</span><span
                                    style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span
                                    style="color: #666666">=20..-1]</span></code></pre>
                        </div>
                    </div>
                </div>
            </div>
            <div class="sect2">
                <h3 id="wrapping-it-up">Wrapping it up</h3>
                <div class="paragraph">
                    <p>The final step is to finish the class <code>MemoryImpl</code>. We need to enable the use our GUI
                        in emuStudio. The
                        <code>emulib.plugins.Memory</code> interface has a method named <code>showSettings</code> which
                        is called when user clicks on the memory
                        icon in the debug tool bar in emuStudio emulation panel. This method is responsible for showing
                        the GUI of memory,
                        and will be called repeatedly, always when a user clicks on the mentioned icon.</p>
                </div>
                <div class="listingblock">
                    <div class="title"><code>src/main/java/net/sf/net.emustudio/ssem/memory/MemoryImpl.java</code></div>
                    <div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span style="color: #666666">...</span>

<span style="color: #008000; font-weight: bold">public</span> <span
            style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">MemoryImpl</span> <span
            style="color: #008000; font-weight: bold">extends</span> AbstractMemory <span
            style="color: #666666">{</span>
    <span style="color: #008000; font-weight: bold">private</span> <span
            style="color: #008000; font-weight: bold">final</span> <span style="color: #008000; font-weight: bold">static</span> Logger LOGGER <span
            style="color: #666666">=</span> LoggerFactory<span style="color: #666666">.</span><span
            style="color: #7D9029">getLogger</span><span style="color: #666666">(</span>MemoryImpl<span
            style="color: #666666">.</span><span style="color: #7D9029">class</span><span
            style="color: #666666">);</span>

    <span style="color: #008000; font-weight: bold">private</span> <span
            style="color: #008000; font-weight: bold">final</span> MemoryContextImpl memContext <span
            style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> MemoryContextImpl<span
            style="color: #666666">();</span>
    <span style="color: #008000; font-weight: bold">private</span> MemoryGUI memoryGUI<span
            style="color: #666666">;</span>

    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #0000FF">MemoryImpl</span><span
            style="color: #666666">(</span>Long pluginID<span
            style="color: #666666">,</span> ContextPool contextPoolImpl<span style="color: #666666">)</span> <span
            style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">super</span><span style="color: #666666">(</span>pluginID<span
            style="color: #666666">);</span>
        <span style="color: #008000; font-weight: bold">try</span> <span style="color: #666666">{</span>
            contextPoolImpl<span style="color: #666666">.</span><span style="color: #7D9029">register</span><span
            style="color: #666666">(</span>pluginID<span style="color: #666666">,</span> memContext<span
            style="color: #666666">,</span> MemoryContext<span style="color: #666666">.</span><span
            style="color: #7D9029">class</span><span style="color: #666666">);</span>
        <span style="color: #666666">}</span> <span style="color: #008000; font-weight: bold">catch</span> <span
            style="color: #666666">(</span>AlreadyRegisteredException <span style="color: #666666">|</span> InvalidContextException e<span
            style="color: #666666">)</span> <span style="color: #666666">{</span>
            StaticDialogs<span style="color: #666666">.</span><span style="color: #7D9029">showErrorMessage</span><span
            style="color: #666666">(</span><span
            style="color: #BA2121">&quot;Could not register SSEM memory&quot;</span><span
            style="color: #666666">,</span> getTitle<span style="color: #666666">());</span>
        <span style="color: #666666">}</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> String <span
            style="color: #0000FF">getVersion</span><span style="color: #666666">()</span> <span style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">return</span> <span
            style="color: #BA2121">&quot;1.0.0&quot;</span><span style="color: #666666">;</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">void</span> <span
            style="color: #0000FF">initialize</span><span style="color: #666666">(</span>SettingsManager settings<span
            style="color: #666666">)</span> <span style="color: #008000; font-weight: bold">throws</span> PluginInitializationException <span
            style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">(!</span>Boolean<span
            style="color: #666666">.</span><span style="color: #7D9029">parseBoolean</span><span style="color: #666666">(</span>settings<span
            style="color: #666666">.</span><span style="color: #7D9029">readSetting</span><span
            style="color: #666666">(</span>pluginID<span style="color: #666666">,</span> SettingsManager<span
            style="color: #666666">.</span><span style="color: #7D9029">NO_GUI</span><span
            style="color: #666666">)))</span> <span style="color: #666666">{</span>
            memoryGUI <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> MemoryGUI<span
            style="color: #666666">(</span>memContext<span style="color: #666666">);</span>
        <span style="color: #666666">}</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">void</span> <span
            style="color: #0000FF">destroy</span><span style="color: #666666">()</span> <span
            style="color: #666666">{</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">int</span> <span
            style="color: #0000FF">getSize</span><span style="color: #666666">()</span> <span
            style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">return</span> MemoryContextImpl<span
            style="color: #666666">.</span><span style="color: #7D9029">NUMBER_OF_CELLS</span><span
            style="color: #666666">;</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">boolean</span> <span
            style="color: #0000FF">isShowSettingsSupported</span><span style="color: #666666">()</span> <span
            style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">true</span><span
            style="color: #666666">;</span>
    <span style="color: #666666">}</span>

    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">void</span> <span
            style="color: #0000FF">showSettings</span><span style="color: #666666">()</span> <span
            style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">(</span>memoryGUI <span
            style="color: #666666">!=</span> <span style="color: #008000; font-weight: bold">null</span><span
            style="color: #666666">)</span> <span style="color: #666666">{</span>
            memoryGUI<span style="color: #666666">.</span><span style="color: #7D9029">setVisible</span><span
            style="color: #666666">(</span><span style="color: #008000; font-weight: bold">true</span><span
            style="color: #666666">);</span>
        <span style="color: #666666">}</span>
    <span style="color: #666666">}</span>
<span style="color: #666666">}</span></code></pre>
                    </div>
                </div>
                <div class="paragraph">
                    <p>As you can see from the code, there are several things to notice:</p>
                </div>
                <div class="ulist">
                    <ul>
                        <li>
                            <p>In constructor, we will register new instance of our memory context. Since we do not have
                                custom context, the
                                interface, passed as the second argument to call <code>contextPoolImpl.register()</code>
                                will be plain <code>MemoryContext.class</code>.
                                If we had custom context, it would require to be defined in separate interface which
                                will extend the standard
                                <code>MemoryContext</code>, and annotated with
                                <code>@emulib.annotations.ContextType</code> annotation.</p>
                        </li>
                        <li>
                            <p>In the <code>initialize()</code> method, we determine if we run in a "non-GUI" mode. We
                                use a <code>SettingsManager</code> object for
                                this purpose, which is an API for reading/writing plugin settings - key/value pairs from
                                the computer configuration
                                file. The "non-GUI", also called "headless" mode, means that the user who run emuStudio
                                did not want GUI to be
                                available. This is often useful when performing automatic emulation. See the user manual
                                for more details. For us,
                                developers, it means that we need to <strong>ignore</strong> all requests for showing
                                GUI. Therefore, we create the GUI only if
                                we are NOT in the "non-GUI" mode.</p>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="sect2">
                <h3 id="testing">Testing</h3>
                <div class="paragraph">
                    <p>It is not only a good practice, but often a safety net to perform automatic tests. They can save
                        a lot of debugging time
                        when something just does not work. Usually, tests should test the most important things - we
                        usually don&#8217;t test setters
                        or getters. In case of GUI, it also does not matter much for our case.</p>
                </div>
                <div class="paragraph">
                    <p>What should be tested is the context itself - since it&#8217;s the core part of the memory, and
                        also some interaction with
                        the main plugin class. For example, the automated unit test of the memory context can look as
                        follows:</p>
                </div>
                <div class="listingblock">
                    <div class="title">
                        <code>src/test/java/net/sf/net.emustudio/ssem/memory/impl/MemoryContextImplTest.java</code></div>
                    <div class="content">
                        <pre class="pygments highlight"><code data-lang="java"><span></span>Unresolved directive in memory<span
                                style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span
                                style="color: #666666">-</span> include<span
                                style="color: #666666">::{</span>sourcedir<span
                                style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span
                                style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span
                                style="color: #666666">/</span>src<span style="color: #666666">/</span>test<span
                                style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span
                                style="color: #666666">/</span>sf<span style="color: #666666">/</span>net.emustudio<span
                                style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span
                                style="color: #666666">/</span>impl<span style="color: #666666">/</span>MemoryContextImplTest<span
                                style="color: #666666">.</span><span style="color: #7D9029">java</span><span
                                style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="footnotes">
        <hr>
        <div class="footnote" id="_footnote_1">
            <a href="#_footnoteref_1">1</a>. See <a
                href="https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Williams-Kilburn_tube"
                class="bare">https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Williams-Kilburn_tube</a>
        </div>
        <div class="footnote" id="_footnote_2">
            <a href="#_footnoteref_2">2</a>. The code might seem generally complicated and bloated with a boiler-plate.
            I personally blame Java Swing or Java itself for it, since it is a "corporate" language, usually used for
            different purposes than writing an emulator :)
        </div>
        <div class="footnote" id="_footnote_3">
            <a href="#_footnoteref_3">3</a>. See <a href="#CPU_HOWTO">[CPU_HOWTO]</a> tutorial for more information
            about Edigen
        </div>
    </div>
</div>


<footer class="site-footer">
    <div class="container">
        <nav class="navbar">
            <div class="container">
                <ul class="nav navbar-nav">
                    <li><a href="https://github.com/vbmacher/emuStudio">GitHub</a></li>
                    <li><a href="https://sourceforge.net/p/net.emustudio/" rel="nofollow"><img alt="Download emuStudio"
                                                                                           src="https://sourceforge.net/sflogo.php?type=10&group_id=340604"></a>
                    </li>
                    <li class="navbar-text">&copy; Copyright 2006-2018, Peter Jakubčo</li>
                </ul>
            </div>
        </nav>
    </div>
</footer>

</body>
</html>

