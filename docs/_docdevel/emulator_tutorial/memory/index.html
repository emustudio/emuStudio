



<!DOCTYPE html>
<html lang="en">
<head>

    <!-- Meta -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <title>Memory &diams; emuStudio</title>
    <meta name="keywords" content="emulator,emulation,emustudio,programming emulator,debugging in emulator,computer emulation,altair emulation">

    <!-- RSS -->
    <link rel="alternate" type="application/rss+xml" title="emuStudio &diams; Computer emulation platform/framework" href="../../../feed.xml">
    <link rel="alternate" type="application/atom+xml" title="emuStudio &diams; Computer emulation platform/framework" href="../../../atom.xml">

    <!-- Favicons -->
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.ico?">
    <meta name="application-name" content="emuStudio &diams; Computer emulation platform/framework">
    <meta name="msapplication-TileColor" content="#ffffff">

    <!-- Fonts -->
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Roboto+Condensed:300,300italic,400,400italic,700,700italic|Oswald:300,400,700">

    <!-- Styles -->
    <link rel="stylesheet" href="../../../css/style.css">


    <!-- Scripts -->

    <!--[if lt IE 9]>
        <script src="../../../js/html5shiv.min.js"></script>
        <script src="../../../js/respond.min.js"></script>
    [endif]-->

    <script src="../../../js/jquery-3.1.1.min.js"></script>
    <script src="../../../js/bootstrap.min.js"
            integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
            crossorigin="anonymous">
    </script>


    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-3492956-5', 'auto');
        ga('send', 'pageview');

    </script>
</head>


<body>


<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/emuStudio/"><i><img alt="&diams;" style="margin: -5px;margin-right:2px;" src="../../../img/logo-2.svg" width="30px" /></i>emuStudio</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
            <!--<form class="navbar-form navbar-left" role="search">-->
                <!--<div class="form-group">-->
                    <!--<input type="text" class="form-control" placeholder="Search website">-->
                <!--</div>-->
                <!--<button type="submit" class="btn btn-default">Submit</button>-->
            <!--</form>-->
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/emuStudio/">Home</a>
                </li>
                
                <li>
                    <a href="/emuStudio/download">Download</a>
                </li>
                
                <li>
                    <a href="/emuStudio/docs">Docs</a>
                </li>
                
                <li>
                    <a href="/emuStudio/devel">Developer</a>
                </li>
                
                <li>
                    <a href="/emuStudio/roadmap">Roadmap</a>
                </li>
                
                <li>
                    <a href="/emuStudio/about">About</a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>


<div class="title-group">
    <h1 class="special" data-toc-skip>
      <span>
          
            Memory
          
      </span>
    </h1>
    
    
</div>


<div class="container">
    <div class="sect1">
<h2 id="MEMORY_HOWTO">Writing a memory</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This tutorial will describe some basic knowledge about how to create an operating memory to be used in emuStudio.
In emuStudio, virtual computers usually conform to von-Neumann architecture. In this architecture, the memory is a
separate component. The tutorial focuses on how to use emuLib API in a memory for SSEM computer.</p>
</div>
<div class="sect2">
<h3 id="MEMORY_GETTING_STARTED">Getting started</h3>
<div class="paragraph">
<p>Before reading on, please read the <a href="#INTRODUCTION_PLUGINS">[INTRODUCTION_PLUGINS]</a> chapter. It gives the information
needed for setting up the development environment and for basic understanding how the emuStudio/plug-ins lifecycle
work.</p>
</div>
<div class="paragraph">
<p>Within this tutorial, we will implement a main store of SSEM "Baby" machine, to conform with other tutorials for other
plug-ins. Before we start, here&#8217;s a few words about what purpose and capabilities memories in emuStudio can have.</p>
</div>
<div class="paragraph">
<p>In first stored-program computers, operating memory was accessible only by CPU. It means that all
data between the memory and other devices had to be transferred through CPU. When data from memory was required,
CPU "paused" the execution of instructions and accessed the memory in the meantime. This slowed down CPU and consequently
the whole program. Later, DMA (direct memory access) capability was introduced, which allowed devices
to directly access the memory, or be notified when the memory changes.</p>
</div>
<div class="paragraph">
<p>In emuStudio, you can connect the memory with devices, or even with a compiler. This is one example of the versatility
and power of emuStudio.</p>
</div>
<div class="paragraph">
<p>There are three main behavioral contracts which need to be taken into account, when creating memory plug-in:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Memory can be connected with none, one or more plug-ins of any type</p>
</li>
<li>
<p>Memory plug-in is necessary for creating a virtual machine (emuStudio requires it)</p>
</li>
<li>
<p>Operations of memory can be extended using special class called "context"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The implication is that the memory can be shared across CPU and devices, and the communication can be optimized with
custom operations. The context class is a customization which extends default context behavior. This tutorial will
cover some basics in this topic.</p>
</div>
<div class="sect3">
<h4 id="ssem-memory">SSEM memory</h4>
<div class="paragraph">
<p>SSEM used the world&#8217;s first random-access memory called Williams or Williams-Kilburn tube
<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote.">1</a>]</sup>. The
used principle was the same as in standard Cathode-Ray-Tubes (CRTs). Original EDSAC computer (which introduced the
von Neumann architecture) did not have random-access memory.</p>
</div>
<div class="paragraph">
<p>The memory had 32 memory cells (called words), each had size of 32 bits. The memory could contain instructions and
data. So, one SSEM instruction perfectly fits in the single memory word.</p>
</div>
<div class="paragraph">
<p>Within this tutorial, we will hardcode the word size and memory size. But we&#8217;ll also implement a GUI for the memory,
which is often far more complicated than the emulated memory itself <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote.">2</a>]</sup></p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="preparing-the-environment">Preparing the environment</h3>
<div class="paragraph">
<p>In order to start developing the memory, create new Java project. Here, Maven will be used for dependencies management.
The plug-in will be implemented as another standard emuStudio plug-in, so it will inherit Maven plug-in dependencies
from the main POM file.</p>
</div>
<div class="paragraph">
<p>The project should be located at <code>emuStudio/plugins/mem/ssem-mem</code>, and should contain the following structure:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>src/
  main/
    java/
    resources/
test/
  java/
pom.xml</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note the naming of the plug-in. It follows the naming convention as described in the <a href="#INTRODUCTION_NAMING">[INTRODUCTION_NAMING]</a>
      guide.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The POM file of the project might look as follows:</p>
</div>
<div class="listingblock">
<div class="title"><code>ssem-mem/pom.xml</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="xml">Unresolved directive in memory.adoc - include::{sourcedir}/plugins/mem/ssem-mem/pom.xml[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s start with the first Java class, the main plug-in class. Let&#8217;s put it to package
<code>net.sf.emustudio.ssem.memory</code>, and call it <code>MemoryImpl</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="MEMORY_BASIC_STUFF">The main class</h3>
<div class="paragraph">
<p>Go to the <code>MemoryImpl</code> class source. Extend the class from <code>emulib.plugins.memory.AbstractMemory</code> class.
The class extends from <code>Memory</code> interface and implements the most common methods, usable by all memories.</p>
</div>
<div class="paragraph">
<p>It is also necessary to annotate the class with <code>emulib.annotations.PluginType</code> annotation, which is required for every
main class of any emuStudio plug-in. The code snippet looks as follows:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/MemoryImpl.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span style="color: #008000; font-weight: bold">package</span> <span style="color: #0000FF; font-weight: bold">net.sf.emustudio.ssem.memory</span><span style="color: #666666">;</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">emulib.annotations.PLUGIN_TYPE</span><span style="color: #666666">;</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">emulib.annotations.PluginType</span><span style="color: #666666">;</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">emulib.plugins.memory.AbstractMemory</span><span style="color: #666666">;</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">emulib.runtime.ContextPool</span><span style="color: #666666">;</span>

<span style="color: #AA22FF">@PluginType</span><span style="color: #666666">(</span>
        type <span style="color: #666666">=</span> PLUGIN_TYPE<span style="color: #666666">.</span><span style="color: #7D9029">MEMORY</span><span style="color: #666666">,</span>
        title <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;SSEM memory&quot;</span><span style="color: #666666">,</span>
        copyright <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;\u00A9 Copyright 2016, Peter Jakubčo&quot;</span><span style="color: #666666">,</span>
        description <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;Main store for SSEM machine&quot;</span>
<span style="color: #666666">)</span>
<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">MemoryImpl</span> <span style="color: #008000; font-weight: bold">extends</span> AbstractMemory <span style="color: #666666">{</span>
    <span style="color: #008000; font-weight: bold">private</span> <span style="color: #008000; font-weight: bold">final</span> <span style="color: #008000; font-weight: bold">static</span> Logger LOGGER <span style="color: #666666">=</span> LoggerFactory<span style="color: #666666">.</span><span style="color: #7D9029">getLogger</span><span style="color: #666666">(</span>MemoryImpl<span style="color: #666666">.</span><span style="color: #7D9029">class</span><span style="color: #666666">);</span>

    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #0000FF">MemoryImpl</span><span style="color: #666666">(</span>Long pluginID<span style="color: #666666">,</span> ContextPool contextPool<span style="color: #666666">)</span> <span style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">super</span><span style="color: #666666">(</span>pluginID<span style="color: #666666">);</span>
    <span style="color: #666666">}</span>

    <span style="color: #408080; font-style: italic">// ... other methods ...</span>
<span style="color: #666666">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The constructor presented here is mandatory. This is one of the behavioral contracts, emuStudio expects
      that a plug-in will have a constructor with two arguments: <code>pluginID</code> (assigned by emuStudio), and a context
      pool, which is a storage or registrar of all plug-ins contexts.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="few-notes-on-ssem-memory">Few notes on SSEM memory</h3>
<div class="paragraph">
<p>When thinking about computer memory - what is it? During time, memory abstraction has evolved to an idea of memory
as a collection of cells, equally-sized, which are ordered sequentially. This is the simplest description, and I
would say that more-less all memories look like this. When emulating a computer memory in a programming language like
Java, it would be then just a plain array.</p>
</div>
<div class="paragraph">
<p>SSEM had 32 so-called "lines", which represented cells in memory. Each line, or a cell, was 4 bytes long. It is therefore
tempting to implement SSEM memory as array of integers, because <code>int</code> type has 4 bytes.</p>
</div>
<div class="paragraph">
<p>It is indeed possible, but we will face to an unsolvable problem when implementing CPU, if we want to use Edigen
<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote.">3</a>]</sup>.
Unfortunately, Edigen is so-far designed in a way that it expects the memory having cell size of a byte, not more.
Therefore, we will keep that also for SSEM memory emulation, but visually try to present it as having 4-byte cells. It
would require additional mathematics when working with memory (in the CPU tutorial you would find it as well), but
not having impact on performance.</p>
</div>
</div>
<div class="sect2">
<h3 id="memory-context">Memory context</h3>
<div class="paragraph">
<p>Abstracts are helping us to understand ideas and see how they can be composed into a whole. In this fashion, memory
main interface, presented in section <a href="#MEMORY_BASIC_STUFF">The main class</a>, is the communication point with emuStudio. The main module is
using methods in this interface. The communication with CPU and devices is done through another concept, which is called
a context. The contexts differ for various plug-ins; and they can be customized.</p>
</div>
<div class="paragraph">
<p>Plug-ins which provide a context, must register it to the <code>ContextPool</code>, given in a constructor in the main plugin class.
This registration should be performed as early as possible - in the constructor itself. After all plug-ins are
instantiated, emuStudio expects that all contexts are already registered.</p>
</div>
<div class="paragraph">
<p>The next step, generally true for all plug-ins, is calling of <code>Plugin.initialize()</code> method, in this case -
<code>Memory.initialize()</code>. The initialization can now use the context pool for different purpose - for obtaining contexts,
if it requires some. More on this topic can be found in the <a href="#INTRODUCTION_BEHAVIORAL">[INTRODUCTION_BEHAVIORAL]</a> section.</p>
</div>
<div class="paragraph">
<p>So, in our case - we must create a memory context, which will be used by SSEM CPU and SSEM CRT display. We don&#8217;t need
special customized context, so we can comfortably extend from class <code>AbstractMemoryContext</code>, which will implement some
methods of the <code>MemoryContext</code> interface for us. We will call the class <code>MemoryContextImpl</code>:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/impl/MemoryContextImpl.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java">Unresolved directive in memory<span style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span style="color: #666666">/</span>sf<span style="color: #666666">/</span>emustudio<span style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span style="color: #666666">/</span>impl<span style="color: #666666">/</span>MemoryContextImpl<span style="color: #666666">.</span><span style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, SSEM memory is indeed an array of bytes. This is the "core" idea of a memory. Ofcourse, it is possible
to use a <code>java.util.List</code> or another collection, but we should keep eye on performance. Array is the simplest structure
with access time O(1). Therefore, we chose array.</p>
</div>
<div class="paragraph">
<p>Also notice that the class <code>AbstractMemoryContext</code>, and also interface <code>MemoryContext</code> take a generic parameter
<code>T extends Number</code>. This parameter is saying of what type cell is. In our case, <code>T</code> is a <code>Byte</code>. Due unhappy Java
limitation, primitive types cannot be used in generics, so we can&#8217;t have something like <code>MemoryContext&lt;byte&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="gui">GUI</h3>
<div class="paragraph">
<p>Since emuStudio is interactive application, GUIs are a natural thing. Each memory plug-in should have its own GUI.
The supported features can be any, but keep in mind, that GUI control in Swing is done in separate thread, often
called "UI Thread". On the other hand, emulation itself is running in different, dedicated, thread, created in emuLib.</p>
</div>
<div class="paragraph">
<p>This means that the access to memory context should be synchronized. However, synchronization is very slow.
Much better approach is to use a non-blocking algorithm for locking, if we really require absolutely reliable
manipulation of memory cells in between threads. However, non-blocking algorithms are harder to implement good.
In our tutorial we will do a trade-off, which we can afford - since we have final array of bytes, we have the following
guarantees:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the array itself will be always valid and visible to all accessing threads. Meaning - reading is always safe.</p>
</li>
<li>
<p>we expect our host CPU can write a byte at once; therefore it is atomic. This does not have to hold for all CPUs - don&#8217;t
worry, all x86 CPUs have it.</p>
</li>
<li>
<p>According to <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.6">Java Language Specification, Chapter 17.6</a>:</p>
<div class="literalblock">
<div class="content">
<pre>two threads that update adjacent elements of a byte array separately must not interfere or interact and do not need
synchronization to ensure sequential consistency.</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>I consider these guarantees as good enough to leave the synchronization be. I guess the probability of modifying
the same memory cells from both running emulation and by the user in GUI, is very small. What&#8217;s more, you shouldn&#8217;t
modify memory cells at all when the emulation is running.</p>
</div>
<div class="paragraph">
<p>Now back to our GUI. It would be good if the GUI is looking good, so it&#8217;s up to you how you&#8217;ll draw the main form. It
can be a class extending from a <code>javax.swing.JFrame</code> or <code>javax.swing.JDialog</code>. The look might be as follows:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://vbmacher.github.io/emuStudio/docdevel/emulator_tutorial/images//ssem-memory.png" alt="SSEM Memory GUI sample look">
</div>
</div>
<div class="paragraph">
<p>So, we will need a custom memory model, a custom memory table - which will have a row header (the very first, gray-colored
column) and column header (the very first, gray-colored row).</p>
</div>
<div class="paragraph">
<p>As you can see in the picture, a row represents single SSEM memory cell - 32 scattered bits, and the last few columns
show both the number the bits represent, and a raw ASCII value of the 4-byte sequence of data.</p>
</div>
<div class="paragraph">
<p>Also, we would like to let user edit the cells manually - just by pointing to a bit, and pressing either 1 or 0 - possibly
a DELETE key, committing the change immediately. We want to allow editing also for the value itself, and for the data column
as well.</p>
</div>
<div class="paragraph">
<p>In addition, movement around cells should be possible with arrow keys.</p>
</div>
<div class="paragraph">
<p>For those "specifications", we will need to customize standard <code>javax.swing.JTable</code>, create custom memory model, cell
editor, cell renderer and introduce row header renderer.</p>
</div>
<div class="paragraph">
<p>The source code of the main GUI class is here:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/gui/MemoryGUI.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java">Unresolved directive in memory<span style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span style="color: #666666">/</span>sf<span style="color: #666666">/</span>emustudio<span style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span style="color: #666666">/</span>gui<span style="color: #666666">/</span>MemoryGUI<span style="color: #666666">.</span><span style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in the constructor we create a memory listener, which implements <code>Memory.MemoryListener</code> interface. The
listener will receive events about external memory changes - in our case, from CPU emulator. Our reaction is - as
supposed to be - reflect the change in the memory GUI.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The caller thread of listener methods is the one who calls <code>Memory.write()</code> on the other end. In our case, it
      can be either the emulator dedicated thread, as described above, or the user itself, doing changes in the UI
      thread.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Also, we use custom memory table, which extends from <code>javax.swing.table.JTable</code>. We will describe it now.</p>
</div>
<div class="sect3">
<h4 id="memory-table">Memory table</h4>
<div class="paragraph">
<p>Since we want "special" behavior, like custom cell renderer, custom row header, custom cell editor and custom widths
of some columns, it will be good to wrap it up in a custom <code>JTable</code>. The code looks as follows:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/gui/MemoryTable.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java">Unresolved directive in memory<span style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span style="color: #666666">/</span>sf<span style="color: #666666">/</span>emustudio<span style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span style="color: #666666">/</span>gui<span style="color: #666666">/</span>MemoryTable<span style="color: #666666">.</span><span style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, particular sub-components of the table will be implemented and described in more detail.</p>
</div>
</div>
<div class="sect3">
<h4 id="memory-table-model">Memory table model</h4>
<div class="paragraph">
<p>Memory model is the "back-end" of the memory GUI. It means, the model provide data which should be shown in the GUI.
You can think of any Swing component as a combination of a "view" and "model" subcomponents. The "view" subcomponent
"asks" the model about which data should be shown. By default, almost all Swing components use some default models,
accessible directly from the Swing component. Consequently, the components allow to set custom models as well, which
is our case.</p>
</div>
<div class="paragraph">
<p>For a table, the model must implement <code>javax.swing.table.TableModel</code> interface. As it is often a custom, Java implements
some general methods in an abstract class called <code>javax.swing.table.AbstractTableModel</code> we can extend from.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The description of the table model can be found <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/table.html#data">at this link</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The model must provide data for every row and column. So here, we must do some math to compute bits and also transform
the data to hex value, and raw ASCII value. The class is called <code>MemoryTableModel</code> and it&#8217;s source code is here:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/gui/MemoryTableModel.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java">Unresolved directive in memory<span style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span style="color: #666666">/</span>sf<span style="color: #666666">/</span>emustudio<span style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span style="color: #666666">/</span>gui<span style="color: #666666">/</span>MemoryTableModel<span style="color: #666666">.</span><span style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="row-header-renderer">Row header renderer</h4>
<div class="paragraph">
<p>Programming a GUI in Java Swing can be tricky. If we want something non-standard, the way of customization can be
very non-obvious = painful. This is the case when we want to do a "header"-like column in a <code>JTable</code>. Long story
short - this trick lies in a use of <code>JScrollPane</code>. This component implements a viewport, something as a virtual screen,
allowing to put there some other components, and make visible only a part of this screen. Besides, it has a feature
which is called a "row header". It has a <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JScrollPane.html#setRowHeaderView-java.awt.Component-">dedicated method</a>
for setting up a custom row header:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>JScrollPane.setRowHeaderView(Component view)</pre>
</div>
</div>
<div class="paragraph">
<p>The trick is to set a <code>javax.swing.JList</code> as a component for the row header. So we end up with the following class:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/gui/RowHeaderRenderer.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java">Unresolved directive in memory<span style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span style="color: #666666">/</span>sf<span style="color: #666666">/</span>emustudio<span style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span style="color: #666666">/</span>gui<span style="color: #666666">/</span>RowHeaderRenderer<span style="color: #666666">.</span><span style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cell-renderer-editor">Cell renderer + editor</h4>
<div class="paragraph">
<p>The last two things we need is to display text using different fonts on certain cells. For example, we want that line
and instruction bits have bold font, and others plain one. But - it is generally more readable if the data are shown
in some monospaced font variant. These customizations are "big enough" to require custom class - a cell renderer.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Official tutorial and description of custom renderers can be found
      <a href="http://docs.oracle.com/javase/tutorial/uiswing/components/table.html#renderer">at this link</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The cell renderer code looks as follows:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/gui/CellRenderer.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java">Unresolved directive in memory<span style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span style="color: #666666">/</span>sf<span style="color: #666666">/</span>emustudio<span style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span style="color: #666666">/</span>gui<span style="color: #666666">/</span>CellRenderer<span style="color: #666666">.</span><span style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, if we want to let user edit a value in a table, we must provide the editor as a Swing component. The
"cell editor" is in fact plain <code>javax.swing.JTextField</code> with some customizations. However if we want to use it,
we must wrap it in a separate class, which needs to extend <code>AbstractCellEditor</code> and implement <code>TableCellEditor</code>.</p>
</div>
<div class="paragraph">
<p>Our customizations involve accommodating the width of the text field, and preparing the initial value when the
editor shows up. User can activate the editor by double-clicking on a cell. The source code of the cell editor is
as follows:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/gui/CellEditor.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java">Unresolved directive in memory<span style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span style="color: #666666">/</span>src<span style="color: #666666">/</span>main<span style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span style="color: #666666">/</span>sf<span style="color: #666666">/</span>emustudio<span style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span style="color: #666666">/</span>gui<span style="color: #666666">/</span>CellEditor<span style="color: #666666">.</span><span style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wrapping-it-up">Wrapping it up</h3>
<div class="paragraph">
<p>The final step is to finish the class <code>MemoryImpl</code>. We need to enable the use our GUI in emuStudio. The
<code>emulib.plugins.Memory</code> interface has a method named <code>showSettings</code> which is called when user clicks on the memory
icon in the debug tool bar in emuStudio emulation panel. This method is responsible for showing the GUI of memory,
and will be called repeatedly, always when a user clicks on the mentioned icon.</p>
</div>
<div class="listingblock">
<div class="title"><code>src/main/java/net/sf/emustudio/ssem/memory/MemoryImpl.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span style="color: #666666">...</span>

<span style="color: #008000; font-weight: bold">public</span> <span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">MemoryImpl</span> <span style="color: #008000; font-weight: bold">extends</span> AbstractMemory <span style="color: #666666">{</span>
    <span style="color: #008000; font-weight: bold">private</span> <span style="color: #008000; font-weight: bold">final</span> <span style="color: #008000; font-weight: bold">static</span> Logger LOGGER <span style="color: #666666">=</span> LoggerFactory<span style="color: #666666">.</span><span style="color: #7D9029">getLogger</span><span style="color: #666666">(</span>MemoryImpl<span style="color: #666666">.</span><span style="color: #7D9029">class</span><span style="color: #666666">);</span>

    <span style="color: #008000; font-weight: bold">private</span> <span style="color: #008000; font-weight: bold">final</span> MemoryContextImpl memContext <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> MemoryContextImpl<span style="color: #666666">();</span>
    <span style="color: #008000; font-weight: bold">private</span> MemoryGUI memoryGUI<span style="color: #666666">;</span>

    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #0000FF">MemoryImpl</span><span style="color: #666666">(</span>Long pluginID<span style="color: #666666">,</span> ContextPool contextPool<span style="color: #666666">)</span> <span style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">super</span><span style="color: #666666">(</span>pluginID<span style="color: #666666">);</span>
        <span style="color: #008000; font-weight: bold">try</span> <span style="color: #666666">{</span>
            contextPool<span style="color: #666666">.</span><span style="color: #7D9029">register</span><span style="color: #666666">(</span>pluginID<span style="color: #666666">,</span> memContext<span style="color: #666666">,</span> MemoryContext<span style="color: #666666">.</span><span style="color: #7D9029">class</span><span style="color: #666666">);</span>
        <span style="color: #666666">}</span> <span style="color: #008000; font-weight: bold">catch</span> <span style="color: #666666">(</span>AlreadyRegisteredException <span style="color: #666666">|</span> InvalidContextException e<span style="color: #666666">)</span> <span style="color: #666666">{</span>
            StaticDialogs<span style="color: #666666">.</span><span style="color: #7D9029">showErrorMessage</span><span style="color: #666666">(</span><span style="color: #BA2121">&quot;Could not register SSEM memory&quot;</span><span style="color: #666666">,</span> getTitle<span style="color: #666666">());</span>
        <span style="color: #666666">}</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> String <span style="color: #0000FF">getVersion</span><span style="color: #666666">()</span> <span style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #BA2121">&quot;1.0.0&quot;</span><span style="color: #666666">;</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">void</span> <span style="color: #0000FF">initialize</span><span style="color: #666666">(</span>SettingsManager settings<span style="color: #666666">)</span> <span style="color: #008000; font-weight: bold">throws</span> PluginInitializationException <span style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">(!</span>Boolean<span style="color: #666666">.</span><span style="color: #7D9029">parseBoolean</span><span style="color: #666666">(</span>settings<span style="color: #666666">.</span><span style="color: #7D9029">readSetting</span><span style="color: #666666">(</span>pluginID<span style="color: #666666">,</span> SettingsManager<span style="color: #666666">.</span><span style="color: #7D9029">NO_GUI</span><span style="color: #666666">)))</span> <span style="color: #666666">{</span>
            memoryGUI <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">new</span> MemoryGUI<span style="color: #666666">(</span>memContext<span style="color: #666666">);</span>
        <span style="color: #666666">}</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">void</span> <span style="color: #0000FF">destroy</span><span style="color: #666666">()</span> <span style="color: #666666">{</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">int</span> <span style="color: #0000FF">getSize</span><span style="color: #666666">()</span> <span style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">return</span> MemoryContextImpl<span style="color: #666666">.</span><span style="color: #7D9029">NUMBER_OF_CELLS</span><span style="color: #666666">;</span>
    <span style="color: #666666">}</span>

    <span style="color: #AA22FF">@Override</span>
    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">boolean</span> <span style="color: #0000FF">isShowSettingsSupported</span><span style="color: #666666">()</span> <span style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000; font-weight: bold">true</span><span style="color: #666666">;</span>
    <span style="color: #666666">}</span>

    <span style="color: #008000; font-weight: bold">public</span> <span style="color: #B00040">void</span> <span style="color: #0000FF">showSettings</span><span style="color: #666666">()</span> <span style="color: #666666">{</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">(</span>memoryGUI <span style="color: #666666">!=</span> <span style="color: #008000; font-weight: bold">null</span><span style="color: #666666">)</span> <span style="color: #666666">{</span>
            memoryGUI<span style="color: #666666">.</span><span style="color: #7D9029">setVisible</span><span style="color: #666666">(</span><span style="color: #008000; font-weight: bold">true</span><span style="color: #666666">);</span>
        <span style="color: #666666">}</span>
    <span style="color: #666666">}</span>
<span style="color: #666666">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see from the code, there are several things to notice:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In constructor, we will register new instance of our memory context. Since we do not have custom context, the
interface, passed as the second argument to call <code>contextPool.register()</code> will be plain <code>MemoryContext.class</code>.
If we had custom context, it would require to be defined in separate interface which will extend the standard
<code>MemoryContext</code>, and annotated with <code>@emulib.annotations.ContextType</code> annotation.</p>
</li>
<li>
<p>In the <code>initialize()</code> method, we determine if we run in a "non-GUI" mode. We use a <code>SettingsManager</code> object for
this purpose, which is an API for reading/writing plugin settings - key/value pairs from the computer configuration
file. The "non-GUI", also called "headless" mode, means that the user who run emuStudio did not want GUI to be
available. This is often useful when performing automatic emulation. See the user manual for more details. For us,
developers, it means that we need to <strong>ignore</strong> all requests for showing GUI. Therefore, we create the GUI only if
we are NOT in the "non-GUI" mode.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="testing">Testing</h3>
<div class="paragraph">
<p>It is not only a good practice, but often a safety net to perform automatic tests. They can save a lot of debugging time
when something just does not work. Usually, tests should test the most important things - we usually don&#8217;t test setters
or getters. In case of GUI, it also does not matter much for our case.</p>
</div>
<div class="paragraph">
<p>What should be tested is the context itself - since it&#8217;s the core part of the memory, and also some interaction with
the main plugin class. For example, the automated unit test of the memory context can look as follows:</p>
</div>
<div class="listingblock">
<div class="title"><code>src/test/java/net/sf/emustudio/ssem/memory/impl/MemoryContextImplTest.java</code></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="java">Unresolved directive in memory<span style="color: #666666">.</span><span style="color: #7D9029">adoc</span> <span style="color: #666666">-</span> include<span style="color: #666666">::{</span>sourcedir<span style="color: #666666">}/</span>plugins<span style="color: #666666">/</span>mem<span style="color: #666666">/</span>ssem<span style="color: #666666">-</span>mem<span style="color: #666666">/</span>src<span style="color: #666666">/</span>test<span style="color: #666666">/</span>java<span style="color: #666666">/</span>net<span style="color: #666666">/</span>sf<span style="color: #666666">/</span>emustudio<span style="color: #666666">/</span>ssem<span style="color: #666666">/</span>memory<span style="color: #666666">/</span>impl<span style="color: #666666">/</span>MemoryContextImplTest<span style="color: #666666">.</span><span style="color: #7D9029">java</span><span style="color: #666666">[</span>lines<span style="color: #666666">=20..-1]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnote_1">
<a href="#_footnoteref_1">1</a>. See <a href="https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Williams-Kilburn_tube" class="bare">https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Williams-Kilburn_tube</a>
</div>
<div class="footnote" id="_footnote_2">
<a href="#_footnoteref_2">2</a>. The code might seem generally complicated and bloated with a boiler-plate. I personally blame Java Swing or Java itself for it, since it is a "corporate" language, usually used for different purposes than writing an emulator :)
</div>
<div class="footnote" id="_footnote_3">
<a href="#_footnoteref_3">3</a>. See <a href="#CPU_HOWTO">[CPU_HOWTO]</a> tutorial for more information about Edigen
</div>
</div>
</div>


    <footer class="site-footer">
        <div class="container">
            <nav class="navbar">
                <div class="container">
                    <ul class="nav navbar-nav">
                        <li><a href="https://github.com/vbmacher/emuStudio">GitHub</a></li>
                        <li><a href="https://sourceforge.net/p/emustudio/" rel="nofollow"><img alt="Download emuStudio" src="https://sourceforge.net/sflogo.php?type=10&group_id=340604"></a></li>
                        <li class="navbar-text">&copy; Copyright 2006-2017, Peter Jakubčo</li>
                    </ul>
                </div>
            </nav>
        </div>
    </footer>

    </body>
</html>

