---
layout: default
title: Writing a compiler
nav_order: 2
---

== Writing a compiler

This tutorial will guide you to how to create a compiler for emuStudio. It focuses on things around
emuStudio, emuLib and some common practices. It will not dig deep into the compiler theory, only what will be required
on the way.

In present days, general scheme of compiler's work is parsing, semantic analysis, optimalization and code generation.
Quite tedious and error-prone work of parsing can be generated automatically with parser generators. All emuStudio
compilers use such tools; and they will be also used in this tutorial:

- http://jflex.de/[JFlex] for generating the lexical analyzer, or lexer for short,
- http://www2.cs.tum.edu/projects/cup/[Java cup] for generating LR(k) parsers.

Before reading on, please read the <<INTRODUCTION_PLUGINS>> chapter. It provides the information
needed for setting up the development environment and explains how emuStudio plug-ins' lifecycle work.

[[COMPILER_GETTING_STARTED]]
=== Getting started

In the context of the whole emulator, the compiler is usually an assembler which produces binary instructions for
the emulated CPU. However, it does not have to be assembler; it really can be any language compiler. The output of
the compiler is often loaded directly into emulated operating memory, so the program can be run in emuStudio in a
single click. This is one of the great features of emuStudio.

A compiler is a plug-in, which means that it requires to implement an API. The API for compilers is defined in the form
of Java interfaces and some classes in emuLib, in package `emulib.plugins.compiler`. This tutorial will guide
you with implementing the API and the whole compiler.

[[COMPILER_SSEM_ASM]]
=== Assembler for SSEM

In this tutorial, we will implement an assembler for the world's very first stored-program computer,
https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine[SSEM], nicknamed "Baby". It was a predecessor
of Manchester Mark 1 which led to Ferranti Mark 1, the world's first commercially available general-purpose computer.

It it very simple computer, which can run only 7 instructions. The instructions table
follows (modified from https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Programming[Wikipedia]):

[frame="topbot",options="header,footer",role="table table-striped table-condensed"]
|===================================================================
|Binary code |Mnemonic        |Action            |Operation
|000         |JMP S           | S(L) -> CI       |Jump to the instruction at the address obtained from the specified memory
                                                  address `S(L)` (absolute unconditional jump)
|100         |JRP / JPR / JMR S | CI + S(L) -> CI |Jump to the instruction at the program counter (`CI`) plus the
                                                  relative value obtained from the specified memory address `S(L)`
                                                  (relative unconditional jump)
|010         |LDN S           |-S(L) -> A       |Take the number from the specified memory address `S(L)`, negate it,
                                                  and load it into the accumulator
|110         |STO S           |A -> S(L)        |Store the number in the accumulator to the specified memory address `S(L)`
|001 or 101  |SUB S           |A - S(L) -> A    |Subtract the number at the specified memory address `S(L)` from the
                                                  value in accumulator, and store the result in the accumulator
|011         |CMP / SKN       |if A<0 then CI+1->CI |Skip next instruction if the accumulator contains a negative value
|111         |STP  / HLT      |Stop              |
|===================================================================

The instructions are stored in a memory, which had 32 cells. Each cell was 32 bits long, and each instruction fit into
exactly one cell. So each instruction has 32 bits. The bit representation was reversed, so the most and the least
significant bits were put on opposite sides. For example, value `3`, in common personal computers represented as `011`,
was in SSEM represented as `110`.

The instruction format is as follows:

.SSEM Instruction Format
[frame="topbot",options="footer",role="table table-striped table-condensed"]
|===================================================================
| *Bit:*  | 00  | 01 | 02 | 03 | 04 | ... | 13 | 14 | 15 | ... | 31
| *Use:*  | L   | L  | L  | L  | L  |  0  | I  | I  | I  | 0   | 0
| *Value:*| 2^0 |    |    |    |    |     |    |    |    |     | 2^31
|===================================================================

where bits `LLLLL` denote a "line", which is basically the memory address - index of a memory cell. It can be understood
as instruction operand. Bits `III` specify the instruction opcode (3 bits are enough for 7 instructions).

=== Language specification

Each compiler is just a program which translates an input source code into output code. Usually, the input language is
more high level than the output language, and often offers some features, which are not supported by the output language.
For example, assembler source codes often support comments, various formats of number literals, labels, or macros. These
are features, which are not supported by the instruction set itself, and they must be translated to it by compiler.

SSEM assembler specification can be started with informal expressing, what it will know:

[[COMPILER_TOKEN_CATEGORIES]]
==== Token categories

Tokens, parsed by lexical analyzer have assigned a so-called category. The category is useful mainly for syntax
highlighter in emuStudio editor. For example, reserved words are colored differently than e.g. numeric constants, or
comments.

The list of all categories can be seen in the following class:
https://github.com/vbmacher/emuLib/blob/branch-9_0/src/main/java/emulib/plugins/compiler/Token.java[Token.java].


==== New-lines

New-line character (LF, CR, or CRLF) will be required as a delimiter of instructions, and as the last character.
Successive empty new-line characters will be ignored.

==== Instructions

Assembler will support all forms of instructions shown in the table in section <<COMPILER_SSEM_ASM>>. All instructions must
start with a line number. For example:

    01 LDN 20

Instructions belong to token category called "reserved words".

==== Literals / constants

Raw number constants can be defined in separate lines using special preprocessor keywords. The first one is `NUM xxx`,
where `xxx` is a number in either decimal or hexadecimal form. Hexadecimal format must start with prefix `0x`. For example:

    00 NUM 0x20
    01 NUM 1207943145

Another keyword is `BNUM xxx`, where `xxx` can be only a binary number. For example:

    01 BNUM 10011011111000101111110000111111

It means that the number will be stored untouched to the memory in the format as it appears in the binary form.

There exists also a third keyword, `BINS xxx`, with the exact meaning as `BNUM`. The reason for its presence is to
be compatible with most of the programs http://www.cs.ubc.ca/~hilpert/e/SSEM/programs/noodle.html[found on internet].

For all constants, the following rules hold. Only integral constants are supported, and the allowed range is from 0 - 31
(maximum is 2^5).

Word `NUM`, `BNUM` and `BINS` keywords belong to "preprocessor" category, but number constants to the category called
"literals".

==== Comments

Only one-line comments will be supported, but of various forms. Generally, comment will be everything starting with
some prefix until the end of the line. Comment prefixes are:

- Double-slash (`//`)
- Semi-colon (`;`)
- Double-dash (`--`)

The token category of comments is "comments".

==== Full example

For example, simple `5+3` addition can be implemented as follows:

    0 LDN 7 // load negative X into the accumulator
    1 SUB 8 // subtract Y from the value in the accumulator
    2 STO 9 // store the sum at address 7
    3 LDN 9 // A = -(-Sum)
    4 STO 9 // store sum
    5 HLT

    7 NUM 3 // X
    8 NUM 5 // Y
    9       // here will be the result

The accumulator should now contain value `8`, as well as memory cell at index 9.

=== Preparing the environment

In order to start developing the compiler, create new Java project in your favorite IDE. In emuStudio, Maven is used for
dependencies management. If you're not familiar with Maven, you can start
https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html[here].

The compiler will be implemented as another standard emuStudio plug-in in standard path
`plugins/compilers/as-ssem`. It will inherit all Maven plug-in dependencies from the main POM file.

The directory structure is "dictated" by Maven, so it should look as follows:

    src/
      main/
        java/
        resources/
    test/
      java/
    pom.xml

NOTE: Note the naming of the plug-in. We are following the naming convention as described in the <<INTRODUCTION_NAMING>>
      guide.

The POM file of the project looks as follows:

[source,xml]
.`pom.xml`
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <parent>
    <artifactId>emustudio-parent</artifactId>
    <groupId>net.sf.emustudio</groupId>
    <version>0.39</version>
    <relativePath>../../../pom.xml</relativePath>
  </parent>
  <modelVersion>4.0.0</modelVersion>

  <artifactId>as-ssem</artifactId>

  <name>SSEM Assembler</name>
  <description>Assembler of SSEM processor language</description>

  <build>
    <finalName>as-ssem</finalName>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <configuration>
          <archive>
            <manifest>
              <addClasspath>false</addClasspath>
              <mainClass>net.sf.emustudio.ssem.assembler.Main</mainClass>
              <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
              <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
            </manifest>
            <manifestEntries>
              <!-- DO NOT REMOVE THESE DEPENDENCIES; COMMAND LINE THEN WON'T WORK -->
              <Class-Path>lib/java-cup-runtime-${javacup.version}.jar lib/emuLib-${emulib.version}.jar lib/slf4j-api-${slf4j.version}.jar</Class-Path>
            </manifestEntries>
          </archive>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>de.jflex</groupId>
        <artifactId>jflex-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>com.github.vbmacher</groupId>
        <artifactId>cup-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <className>ParserImpl</className>
          <symbolsName>Symbols</symbolsName>
        </configuration>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
    </dependency>
    <dependency>
      <groupId>net.sf.emustudio</groupId>
      <artifactId>emuLib</artifactId>
    </dependency>
    <dependency>
      <groupId>com.github.vbmacher</groupId>
      <artifactId>java-cup-runtime</artifactId>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
    </dependency>
    <dependency>
      <groupId>org.easymock</groupId>
      <artifactId>easymock</artifactId>
    </dependency>
    <dependency>
      <groupId>net.sf.emustudio</groupId>
      <artifactId>cpu-testsuite</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>
</project>
----

=== Lexical analyzer (lexer)

We will start with definition of the lexer specfile. It is a special file, which will be given to http://jflex.de/[JFlex]
during project compilation. Jflex will generate a Java class - the lexer - which will be used by the parser later, and
by emuStudio editor, too. The specification file has special place in the directory structure:

    src/
      main/
        jflex/
          lexer.jflex

NOTE: Note that the specfile is not put into resources directory. If it was so, then it would be included in the final
      JAR file.


JFlex will be called during compilation of the assembler by the
http://jflex.sourceforge.net/maven-jflex-plugin/generate-mojo.html[JFlex Maven plugin] (see the POM file above).
The content of the specfile is as follows:

[source,flex]
.`src/main/jflex/ssem.jflex`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.LexicalAnalyzer;
import emulib.plugins.compiler.Token;
import emulib.runtime.NumberUtils;
import emulib.runtime.RadixUtils;

import java.io.IOException;
import java.io.Reader;
import java.util.Arrays;

%%

/* options */
%class LexerImpl
%cup
%public
%implements LexicalAnalyzer, Symbols
%line
%column
%char
%caseless
%unicode
%type TokenImpl

%{
    @Override
    public Token getSymbol() throws IOException {
        return next_token();
    }

    @Override
    public void reset(Reader in, int yyline, int yychar, int yycolumn) {
        yyreset(in);
        this.yyline = yyline;
        this.yychar = yychar;
        this.yycolumn = yycolumn;
    }

    @Override
    public void reset() {
        this.yyline = 0;
        this.yychar = 0;
        this.yycolumn = 0;
    }

    private TokenImpl token(int type, int category) {
        return new TokenImpl(type, category, yytext(), yyline, yycolumn, yychar);
    }

    private TokenImpl token(int type, int category, Object value) {
        return new TokenImpl(type, category, yytext(), yyline, yycolumn, yychar, value);
    }
%}

%eofval{
    return token(EOF, Token.TEOF);
%eofval}

comment = "//"[^\r\n]*
comment2 = "--"[^\r\n]*
comment3 = ";"[^\r\n]*
eol = \r|\n|\r\n
space = [ \t\f]+
number = \-?[0-9]+
hexnumber = \-?0x[0-9a-fA-F]+
binnumber = [01]+

%xstate BIN

%%

<YYINITIAL> {
    /* reserved words */
    "jmp" {
        return token(JMP, Token.RESERVED);
    }
    "jrp" {
        return token(JPR, Token.RESERVED);
    }
    "jpr" {
        return token(JPR, Token.RESERVED);
    }
    "jmr" {
        return token(JPR, Token.RESERVED);
    }
    "ldn" {
        return token(LDN, Token.RESERVED);
    }
    "sto" {
        return token(STO, Token.RESERVED);
    }
    "sub" {
        return token(SUB, Token.RESERVED);
    }
    "cmp" {
        return token(CMP, Token.RESERVED);
    }
    "skn" {
        return token(CMP, Token.RESERVED);
    }
    "stp" {
        return token(STP, Token.RESERVED);
    }
    "hlt" {
        return token(STP, Token.RESERVED);
    }

    /* special */
    "start:" {
        return token(START, Token.PREPROCESSOR);
    }
    "num" {
        return token(NUM, Token.PREPROCESSOR);
    }
    "bnum" {
        yybegin(BIN);
        return token(BNUM, Token.PREPROCESSOR);
    }
    "bins" {
        yybegin(BIN);
        return token(BNUM, Token.PREPROCESSOR);
    }

    /* comment */
    {comment} {
        return token(TCOMMENT, Token.COMMENT);
    }
    {comment2} {
        return token(TCOMMENT, Token.COMMENT);
    }
    {comment3} {
        return token(TCOMMENT, Token.COMMENT);
    }

    /* literals */
    {number} {
        int num = Integer.parseInt(yytext(), 10);
        return token(NUMBER, Token.LITERAL, num);
    }

    {hexnumber} {
        int num = Integer.decode(yytext());
        return token(NUMBER, Token.LITERAL, num);
    }
}

/* separators */
<YYINITIAL, BIN> {eol} {
    return token(SEPARATOR_EOL, Token.SEPARATOR);
}
<YYINITIAL, BIN> {space} { /* ignore white spaces */ }

<BIN> {

    {binnumber} {
        yybegin(YYINITIAL);

        byte[] numberArray = RadixUtils.convertToNumber(yytext(), 2, 4);
        int num = NumberUtils.reverseBits(
            NumberUtils.readInt(
                NumberUtils.toObjectArray(numberArray), NumberUtils.Strategy.LITTLE_ENDIAN
            ), 32
        );

        return token(NUMBER, Token.LITERAL, num);
    }

    [^] {
        yybegin(YYINITIAL);
    }

}

/* error fallback */
[^] {
    return token(ERROR_UNKNOWN_TOKEN, Token.ERROR);
}
----

As you can notice, the specfile uses special class named `TokenImpl`. We must implement this class by ourselves. It
holds the basic information about the parsed token, like offset, length, type, etc. There are several requirements
when implementing the class:

- It must extend `java_cup.runtime.Symbol` class, for JFlex - cup interoperability.
- It must implement `emulib.plugins.compiler.Token` interface, for being able to use this class in emuStudio syntax
  highlighter
- It's now a secret, but it would have to implement also special `Symbols` interface, which will be generated by
  parser, described in section below.

Syntax highlighter in emuStudio represents the source code in a dynamic "lexical tree". It scans regularly required text
blocks in the editor and translates them into the symbolic representation - into tokens, which are arranged in a tree
structure. Tokens are parsed by the lexer, provided by us. And `Token` interface is the shared API known by our specific
lexer and general syntax highlighter in emuStudio.

Tokens are assigned into categories, as was already mentioned in section <<COMPILER_TOKEN_CATEGORIES>>. Token categories have
assigned their specific editor style, like color or font.

The content of the `net.sf.emustudio.ssem.assembler.TokenImpl` class is as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/TokenImpl.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.Token;
import java_cup.runtime.ComplexSymbolFactory;

public class TokenImpl extends ComplexSymbolFactory.ComplexSymbol implements Token, Symbols {
    private final int category;
    private final int cchar;

    public TokenImpl(int id, int category, String text, int line, int column, int cchar) {
        super(
            text, id, new ComplexSymbolFactory.Location(line, column), new ComplexSymbolFactory.Location(line, column)
        );
        this.category = category;
        this.cchar = cchar;
    }

    public TokenImpl(int id, int category, String text, int line, int column, int cchar, Object value) {
        super(
            text, id, new ComplexSymbolFactory.Location(line, column), new ComplexSymbolFactory.Location(line, column), value
        );
        this.category = category;
        this.cchar = cchar;
    }

    @Override
    public int getID() {
        return super.sym;
    }

    @Override
    public int getType() {
        return category;
    }

    @Override
    public int getLine() {
        return super.getLeft().getLine();
    }

    @Override
    public int getColumn() {
        return super.getLeft().getColumn();
    }

    @Override
    public int getOffset() {
        return cchar;
    }

    @Override
    public int getLength() {
        return getName().length();
    }

    @Override
    public String getErrorString() {
        return "Unknown token";
    }

    @Override
    public String getText() {
        return getName();
    }

    @Override
    public boolean isInitialLexicalState() {
        return super.sym != BNUM;
    }
}
----

[[COMPILER_GRAMMAR]]
=== Syntax analyzer (parser)

Next, we define the grammar file. It is also a special file, which will be given to cup during project
compilation. Cup will generate Java classes - the parser - which we will use in our code. The specfile
has special place in the directory structure:

    src/
      main/
        cup/
          parser.cup

Grammar type and form we use depends on the parsing algorithm we choose. In emuStudio, all compilers use
http://www2.cs.tum.edu/projects/cup/[Java cup] parser generator, which does bottom-up parsing, and supported grammars
are of type LALR.

The main difference between LL and LALR grammars is that in LALR you can freely use left-recursion, but not right
recursion. Otherwise you would get shift/reduce conflicts. For more information, see for example
https://lambda.uta.edu/cse5317/notes/node21.html[this site].

The grammar specfile of SSEM assembler parser follows:

[source]
.`src/main/cup/parser.cup`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.Message;
import emulib.plugins.compiler.Token;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.Symbol;
import net.sf.emustudio.ssem.assembler.tree.ASTnode;
import net.sf.emustudio.ssem.assembler.tree.Constant;
import net.sf.emustudio.ssem.assembler.tree.Instruction;
import net.sf.emustudio.ssem.assembler.tree.Program;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

parser code {:
    private LexerImpl lexer;
    private boolean syntaxErrors;
    private CompilerImpl compiler;

    public ParserImpl(LexerImpl lex, ComplexSymbolFactory csf, CompilerImpl compiler) {
        super(lex, csf);
        lexer = Objects.requireNonNull(lex);
        this.compiler = Objects.requireNonNull(compiler);
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        done_parsing();
        report_error(message, info);
        throw new Exception("Can\'t recover from previous error(s)");
    }

    @Override
    public void report_error(String messageText, Object current) {
        syntaxErrors = true;

        Token token = (Token)current;

        messageText += ":" + token.getErrorString() + " ('" + token.getText() + "')";

        List expectedTokenIds = expected_token_ids()
            .stream()
            .map(id -> symbl_name_from_id(id.intValue()))
            .collect(Collectors.toList());

        if (!expectedTokenIds.isEmpty()) {
            messageText += "\nExpected tokens: " + expectedTokenIds;
        }

        Message message = new Message(
            Message.MessageType.TYPE_ERROR, messageText, token.getLine()+1, token.getColumn(), null, 0
        );

        if (compiler != null) {
            compiler.notifyOnMessage(message);
        } else {
            System.err.println(message.getFormattedMessage());
        }
    }

    public boolean hasSyntaxErrors() {
        return syntaxErrors;
    }

:};

terminal JMP, JPR, LDN, STO, SUB, CMP, STP, NUM, BNUM;
terminal SEPARATOR_EOL, TCOMMENT, ERROR_UNKNOWN_TOKEN;
terminal Integer NUMBER;
terminal START;

non terminal Program Program;
non terminal ASTnode Statement;
non terminal Instruction Instruction;
non terminal Constant Constant;
non terminal Comment;

start with Program;

Program ::= NUMBER:c Statement:s Program:p              {: if (s != null) p.statement(c, s); RESULT = p;  :}
    | NUMBER:c Comment SEPARATOR_EOL Program:p          {: RESULT = p; :}
    | Comment SEPARATOR_EOL Program:p                   {: RESULT = p; :}
    | START SEPARATOR_EOL Program:p                     {: p.nextLineStarts(); RESULT = p; :}
    | /* empty program */                               {: RESULT = new Program(); :}
    ;

Statement ::= Instruction:i Comment SEPARATOR_EOL       {: RESULT = i; :}
    | Constant:c Comment SEPARATOR_EOL                  {: RESULT = c; :}
    ;

Instruction ::= JMP NUMBER:line             {: RESULT = Instruction.jmp(line); :}
    | JPR NUMBER:line                       {: RESULT = Instruction.jrp(line); :}
    | LDN NUMBER:line                       {: RESULT = Instruction.ldn(line); :}
    | STO NUMBER:line                       {: RESULT = Instruction.sto(line); :}
    | SUB NUMBER:line                       {: RESULT = Instruction.sub(line); :}
    | CMP                                   {: RESULT = Instruction.cmp(); :}
    | STP                                   {: RESULT = Instruction.stp(); :}
    | error
    ;

Constant ::= NUM NUMBER:raw                 {: RESULT = new Constant(raw); :}
    | BNUM NUMBER:raw                       {: RESULT = new Constant(raw); :}
    ;

Comment ::= TCOMMENT
    | /* no comment*/
    ;
----

The right sides - code snippets wrapped between `{:` and `:}` - is Java code which will be executed when particular rule
of the grammar is applied. Remember, that they will be applied in reverse - first will be applied the right-most rules.

There exist a special variable `RESULT`, which should return some Java object of type which the
non-terminal defines for it footnote:[For example, `non terminal Instruction Statement;` in the gramamr above defines a
non-terminal `Statement`, which should return an instance of `Instruction` class. The class `Instruction` must be
implemented manually - it is part of AST; there are no special requirements for the implementation.].

For more information, especially about the `error` symbol, please read http://www2.cs.tum.edu/projects/cup/[cup]
documentation.

[[COMPILER_AST]]
=== Introducing AST

The code won't compile so far. The reason is that the parser strangely uses some undefined classes, such as `Program`,
`ASTnode`, `Instruction` and `Constant`. They are defined in the grammar file as follows (see above):

    non terminal Program Program;
    non terminal ASTnode Statement;
    non terminal Instruction Instruction;
    non terminal Constant Constant;

These classes are part of so-called abstract syntax tree, and they wait for our implementation. Abstract Syntax Tree
(or AST) is a "symbolic" representation of the parsed program source code. The parser creates one as a side-effect of
parsing. It is different from Parse Syntax Tree (PST), which represents a tree of true grammar derivations which were
"detected" by the parser for given source code of a program.

AST is something more artificial, ie. not all grammar rules need to be taken into account when representing the program.
For this reason, we define only some "nodes" of the derivation tree. In our case, it is `Program`, representing the
"root" of the tree, which has children - `Statement`s. Statements have `Instruction`s or `Constant`s as its children.

Do you remember those code snippets in the grammar specfile wrapped in `{: ... :}` ? This code snippets create the
AST, just follow them.

It's now time to implement them. Since we know all nodes are just nodes of our AST, we should define common `ASTnode`
interface first:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/ASTnode.java`
----
package net.sf.emustudio.ssem.assembler.tree;

public interface ASTnode {

    void accept(ASTvisitor visitor) throws Exception;

}
----

This interface will be useful when we will traverse the tree. For tree traversal it is very well-suited the
https://sourcemaking.com/design_patterns/visitor[Visitor pattern]. The idea of traversing a tree using visitor pattern
is to have the "visitor" object - which represents an object which wants to go through all nodes of the tree and do
something. The algorithm of visiting is based on a premise that each node of the AST implements the `accept()` method.
That way, each node is responsible for calling the visitor for each its children and itself.
So the effect is that the "visitor" will "get" the all tree node objects, when the `accept()` method is called on the
root of the tree.

We can now define the visitor interface as follows:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/ASTvisitor.java`
----
package net.sf.emustudio.ssem.assembler.tree;

public interface ASTvisitor {

    void setCurrentLine(int line);

    void visit(Instruction instruction) throws Exception;

    void visit(Constant constant) throws Exception;

}
----

The methods of the visitor will be implemented by some visitor, for example a code generator. However, we need to
finish implementation of the AST first.

==== 'Program' node

The root node of the AST is the `Program` class. According to the grammar, it contains all the statements, which are
either `Instruction` or `Constant`. Notice how we implemented traversing of the node:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Program.java`
----
package net.sf.emustudio.ssem.assembler.tree;

import java.util.HashMap;
import java.util.Map;

public class Program implements ASTnode {
    private final Map<Integer, ASTnode> nodes = new HashMap<>();
    private int startLine = 0;
    private int previousLine = 0;

    public void statement(int line, ASTnode node) {
        previousLine = line;
        nodes.put(line, node);
    }

    public void nextLineStarts() {
        this.startLine = previousLine;
    }

    public int getStartLine() {
        return startLine;
    }

    @Override
    public void accept(ASTvisitor visitor) throws Exception {
        for (Map.Entry<Integer, ASTnode> node : nodes.entrySet()) {
            visitor.setCurrentLine(node.getKey());
            node.getValue().accept(visitor);
        }
    }
}
----

The important note is that how the statements are stored. They are in fact the children of the program node. For this
purpose a key-value map is used. Key has type `Integer` and it represents the line - or memory cell index, or address -
on which the statement will be located. That way we can write several instructions which lie on the same line, e.g.:

    01 LDN 15
    01 STO 06

which will be translated into two statements, but the program node will contain just the last one. The reason is that
they share the line - `01` - which is the key in the map of statements, so the first statement will be "overwritten"
by the second one.

It is for a debate if we want this behavior to happen. For simplicity, we allow it. Otherwise we would throw some
compiler exception.

==== 'Instruction' node

Instruction node represents the instruction. If you remember, each instruction except `STP` and `CMP` has a parameter,
or better - operand - which is a "line" - index of a memory cell. It would be possible to represent specific
instructions by separate classes, but since the required operations would be shared, it would be much easier to have
just one class for all the instructions. Generally, instructions with same number and type of parameters are usually
implemented in one AST node.

Here's the source code:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Instruction.java`
----
package net.sf.emustudio.ssem.assembler.tree;

import net.sf.emustudio.ssem.assembler.CompileException;

import java.util.Optional;

public class Instruction implements ASTnode {
    public final static byte JMP = 0; // 000
    public final static byte JRP = 4; // 100
    public final static byte LDN = 2; // 010
    public final static byte STO = 6; // 110
    public final static byte SUB = 1; // 001
    public final static byte CMP = 3; // 011
    public final static byte STP = 7; // 111
    private final static String[] INSTRUCTION_STRING = new String[] {
        "JMP", "SUB", "LDN", "CMP", "JRP", null, "STO", "STP"
    };

    private final int opcode;
    private final Optional<Byte> operand;

    private Instruction(int opcode, int operand) throws CompileException {
        if (operand > 31 || operand < 0) {
            throw new CompileException("Instruction operand must be in range <0,31>!");
        }
        this.operand = Optional.of((byte)(operand & 0xFF));
        this.opcode = opcode;
    }

    private Instruction(int opcode) {
        this.operand = Optional.empty();
        this.opcode = opcode;
    }

    public int getOpcode() {
        return opcode;
    }

    public Optional<Byte> getOperand() {
        return operand;
    }

    public static Instruction jmp(int address) throws CompileException {
        return new Instruction(JMP, address);
    }

    public static Instruction jrp(int address) throws CompileException {
        return new Instruction(JRP, address);
    }

    public static Instruction ldn(int address) throws CompileException {
        return new Instruction(LDN, address);
    }

    public static Instruction sto(int address) throws CompileException {
        return new Instruction(STO, address);
    }

    public static Instruction sub(int address) throws CompileException {
        return new Instruction(SUB, address);
    }

    public static Instruction cmp() {
        return new Instruction(CMP);
    }

    public static Instruction stp() {
        return new Instruction(STP);
    }

    @Override
    public void accept(ASTvisitor visitor) throws Exception {
         visitor.visit(this);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Instruction that = (Instruction) o;
        return opcode == that.opcode && operand.equals(that.operand);
    }

    @Override
    public int hashCode() {
        int result = opcode;
        result = 31 * result + operand.hashCode();
        return result;
    }

    @Override
    public String toString() {
        return INSTRUCTION_STRING[opcode] + " " + operand;
    }
}
----

Note that the constructor is private. The implication is that it is just impossible to create some invalid `Instruction`
object. The only possible way how to define it is using static factory methods, which represent the instructions
themselves. These are called from the parser - check the grammar specfile in the section <<COMPILER_GRAMMAR>>.

Also, note that we can compare instructions based on opcode and operand. This is allowed by custom implementations of
methods `hashCode()` and `equals()`.

==== 'Constant' node

Another kind of statement is a constant. The constant is just a number, and the node class is very simple:

[source,java]
----
package net.sf.emustudio.ssem.assembler.tree;

public class Constant implements ASTnode {
    private final int number;

    public Constant(int number) {
        this.number = number;
    }

    @Override
    public void accept(ASTvisitor visitor) throws Exception {
        visitor.visit(this);
    }

    public int getNumber() {
        return number;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Constant constant = (Constant) o;

        return number == constant.number;
    }

    @Override
    public int hashCode() {
        return number;
    }
}
----

Comparing `Constant` instances is based on comparing the numbers they represent.

=== Testing

It is very good practice to write automated tests. These will give us some level of confidence that what we did so far
is actually working. It is the earliest feedback we can get on our work, which consequently improves the speed of
creating sofware which actually works.

A unit test is just a normal class which contains test methods. A test method generally creates the testing object, does
the testing operation and finally check if the operation did what it should. Each test method should test just one thing
and should be short and clear. It is good practice to name test method according to the test case, possibly resulting
in a whole sentence, in camel case.

Java projects use some unit testing framework for that, e.g. JUnit or TestNG, which recognizes those classes
automatically and runs the test methods during the compilation of the project. If a test fails, the whole compilation
is stopped as failed.

For lexer and parser we create unit test classes, which will be placed here (following to Maven directory structure):

    src/
      test/
        java/
          net/
            sf/
              emustudio/
                ssem/
                  assembler/
                    LexerTest.java
                    ParserTest.java

The content of the test classes are as follows:

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/LexerTest.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.Token;
import org.junit.Test;

import java.io.IOException;
import java.io.StringReader;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;

public class LexerTest {

    LexerImpl lexer(String tokens) {
        return new LexerImpl(new StringReader(tokens));
    }

    @Test
    public void testNumberUpperBoundary() throws Exception {
        LexerImpl lexer = lexer("31");

        TokenImpl token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
        assertEquals(31, token.value);
    }

    @Test
    public void testNumberLowerBoundary() throws Exception {
        LexerImpl lexer = lexer("0");

        TokenImpl token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
        assertEquals(0, token.value);
    }

    @Test
    public void testNumber() throws Exception {
        LexerImpl lexer = lexer("22");

        TokenImpl token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
        assertEquals(22, token.value);
    }

    private void checkInstruction(int id, LexerImpl lexer) throws IOException {
        TokenImpl token = lexer.next_token();
        assertEquals(Token.RESERVED, token.getType());
        assertEquals(id, token.getID());
    }

    private void checkInstructionWithOperand(int id, LexerImpl lexer) throws IOException {
        checkInstruction(id, lexer);

        TokenImpl token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
    }

    @Test
    public void testInstructionsWithOperand() throws Exception {
        checkInstructionWithOperand(TokenImpl.JMP, lexer("jmp 12"));
        checkInstructionWithOperand(TokenImpl.JPR, lexer("jrp 12"));
        checkInstructionWithOperand(TokenImpl.JPR, lexer("jpr 12"));
        checkInstructionWithOperand(TokenImpl.JPR, lexer("jmr 12"));
        checkInstructionWithOperand(TokenImpl.LDN, lexer("ldn 12"));
        checkInstructionWithOperand(TokenImpl.STO, lexer("sto 12"));
        checkInstructionWithOperand(TokenImpl.SUB, lexer("sub 12"));
    }

    @Test
    public void testInstructionsWithoutOperand() throws Exception {
        checkInstruction(TokenImpl.CMP, lexer("cmp"));
        checkInstruction(TokenImpl.CMP, lexer("skn"));
        checkInstruction(TokenImpl.STP, lexer("stp"));
    }

    @Test
    public void testInstructionInComment() throws Exception {
        LexerImpl lexer = lexer("// cmp");
        TokenImpl token = lexer.next_token();

        assertEquals(TokenImpl.TCOMMENT, token.getID());
        assertEquals(Token.COMMENT, token.getType());

        token = lexer.next_token();
        assertEquals(Token.TEOF, token.getType());
        assertEquals(TokenImpl.EOF, token.getID());
    }

    @Test
    public void testBinaryNumber() throws Exception {
        LexerImpl lexer = lexer("BNUM 10011011111000101111110000111111\n");

        TokenImpl token = lexer.next_token();
        assertEquals(Token.PREPROCESSOR, token.getType());
        assertEquals(TokenImpl.BNUM, token.getID());
        assertFalse(token.isInitialLexicalState());

        token = lexer.next_token();
        assertEquals(Token.LITERAL, token.getType());
        assertEquals(TokenImpl.NUMBER, token.getID());
    }
}
----

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/ParserTest.java`
----
package net.sf.emustudio.ssem.assembler;

import java_cup.runtime.ComplexSymbolFactory;
import net.sf.emustudio.ssem.assembler.tree.ASTvisitor;
import net.sf.emustudio.ssem.assembler.tree.Constant;
import net.sf.emustudio.ssem.assembler.tree.Instruction;
import net.sf.emustudio.ssem.assembler.tree.Program;
import org.junit.Test;

import java.io.StringReader;
import java.util.Arrays;
import java.util.Deque;
import java.util.LinkedList;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

public class ParserTest {

    private ParserImpl program(String program) {
        return new ParserImpl(new LexerImpl(new StringReader(program)), new ComplexSymbolFactory());
    }

    @Test
    public void testInstructions() throws Exception {
        ParserImpl parser = program(
            "0 cmp // comment\n" +
            "1 stp\n" +
            "2 jmp 22\n" +
            "3 jrp 0\n" +
            "4 ldn 31\n" +
            "5 sto 10\n" +
            "6 sub 15\n"
        );

        Program program = (Program) parser.parse().value;
        assertFalse(parser.hasSyntaxErrors());

        Deque<Instruction> expectedInstructions = new LinkedList<>(Arrays.asList(
            Instruction.cmp(),
            Instruction.stp(),
            Instruction.jmp((byte)22),
            Instruction.jrp((byte)0),
            Instruction.ldn((byte)31),
            Instruction.sto((byte)10),
            Instruction.sub((byte)15)
        ));
        program.accept(new ASTvisitor() {

            @Override
            public void setCurrentLine(int line) {

            }

            @Override
            public void visit(Instruction instruction) throws Exception {
                assertEquals(expectedInstructions.removeFirst(), instruction);
            }

            @Override
            public void visit(Constant constant) throws Exception {
                fail("Didn't expect a constant");
            }
        });
    }


    @Test(expected = Exception.class)
    public void testInstructionWithoutEOL() throws Exception {
        ParserImpl parser = program("0 jmp 1");

        parser.parse();
    }

    @Test
    public void testInstructionWithoutProperArgument() throws Exception {
        ParserImpl parser = program("0 jmp ffff\n");

        parser.parse();
        assertTrue(parser.hasSyntaxErrors());
    }

    @Test
    public void testConstantIsTranslatedCorrectly() throws Exception {
        ParserImpl parser = program(
            "0 NUM 5\n"
        );

        Program program = (Program) parser.parse().value;

        assertFalse(parser.hasSyntaxErrors());
        assertConstant(program, 5);
    }

    @Test
    public void testHexadecimalConstant() throws Exception {
        ParserImpl parser = program(
            "0 NUM -0x20\n"
        );

        Program program = (Program) parser.parse().value;
        assertFalse(parser.hasSyntaxErrors());

        assertConstant(program, -32);
    }

    @Test
    public void testStartingPointIsAccepted() throws Exception {
        ParserImpl parser = program("0 jmp 1\nstart:\n3 cmp\n");

        Program program = (Program) parser.parse().value;
        assertFalse(parser.hasSyntaxErrors());
        assertEquals(3, program.getStartLine());
    }

    @Test
    public void testIndexOfLineThenCommentWorks() throws Exception {
        ParserImpl parser = program("0 --comment\n");

        Program program = (Program) parser.parse().value;
        assertFalse(parser.hasSyntaxErrors());
    }

    private void assertConstant(Program program, int value) throws Exception {
        program.accept(new ASTvisitor() {

            @Override
            public void setCurrentLine(int line) {

            }

            @Override
            public void visit(Instruction instruction) throws Exception {
                fail("Didn't expect an instruction");
            }

            @Override
            public void visit(Constant constant) throws Exception {
                assertEquals(new Constant(value), constant);
            }
        });
    }
}
----

NOTE: The tests of parser are based on comparing `Instruction` and `Constant` instances with JUnit's `assertEquals()`
      method. This is possible only because of overriden `equals()` and `hashCode()` methods in the classes, since
      they are used directly by Java when it is comparing the instances.

=== The main class

The time has come for implementing the main plug-in class. It will be placed in a package
`net.sf.emustudio.ssem.assembler`, and the class will be named `CompilerImpl`.

There are several requirements (behavioral contracts) put on the compiler main class:

- It must implement `emulib.plugins.compiler.Compiler` interface. There already exists helper abstract class called
  `emulib.plugins.compiler.AbstractCompiler`, which implements some fundamental and general methods. We will use that
  class.
- It must be annotated with `emulib.annotations.PluginType` annotation.
- The constructor gets two arguments: unique plugin ID (`Long`) and `emulib.runtime.ContextPool` object. Both values
  are created by emuStudio, and we will talk about them later.

Now, the "skeleton" of the class follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CompilerImpl.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.annotations.PLUGIN_TYPE;
import emulib.annotations.PluginType;
import emulib.plugins.compiler.AbstractCompiler;
import emulib.plugins.compiler.LexicalAnalyzer;
import emulib.plugins.compiler.SourceFileExtension;
import emulib.runtime.ContextPool;

import java.io.IOException;
import java.io.Reader;
import java.util.Objects;

@PluginType(
    type = PLUGIN_TYPE.COMPILER,
    title = "SSEM Assembler",
    copyright = "\u00A9 Copyright 2016, YourName",
    description = "Assembler of SSEM processor language"
)
public class CompilerImpl extends AbstractCompiler {
    private static final SourceFileExtension[] SOURCE_FILE_EXTENSIONS = new SourceFileExtension[]{
        new SourceFileExtension("ssem", "SSEM source file")
    };
    private final ContextPool contextPoolImpl;

    public CompilerImpl(Long pluginID, ContextPool contextPoolImpl) {
        super(pluginID);
        this.contextPoolImpl = Objects.requireNonNull(contextPoolImpl);
    }

    @Override
    public boolean compile(String inputFileName, String outputFileName) {
        // TODO !!
        return false;
    }

    @Override
    public boolean compile(String inputFileName) {
        String outputFileName = Objects.requireNonNull(inputFileName);
        SourceFileExtension srcExtension = SOURCE_FILE_EXTENSIONS[0];

        int i = inputFileName.lastIndexOf("." + srcExtension.getExtension());
        if (i >= 0) {
            outputFileName = outputFileName.substring(0, i);
        }
        return compile(inputFileName, outputFileName + ".bin");
    }

    @Override
    public LexicalAnalyzer getLexer(Reader reader) {
        return new LexerImpl(reader);
    }

    @Override
    public SourceFileExtension[] getSourceSuffixList() {
        return SOURCE_FILE_EXTENSIONS;
    }

    @Override
    public void destroy() {

    }

    @Override
    public void showSettings() {

    }

    @Override
    public boolean isShowSettingsSupported() {
        return false;
    }

    @Override
    public String getVersion() {
        return "1.0";
    }
}
----

Some things are obvious, some maybe not. For example, method `getLexer()` is called by emuStudio for the syntax
highlighter. It is very straightforward - just return new `LexerImpl()` which was generated by JFlex from our
specfile.

Method `compile(String)` might seem complex at first look. It is "ugly" Java code which tries to check if the given
file name ends with our supported file suffix, which is ".ssem". We chose it as the suffix of SSEM source code file.
We could chose ".asm" or other extension as well. Then, the "real" `compile()` method is called with the input file
and the output file name, which has suffix ".bin".

Method `getSourceSuffixList()` returns all supported extensions, and will be used in the file filter in the open file
dialog shown in emuStudio.

Compiler can have it's own settings dialog (GUI window) which can be shown. This is reflected by the methods
`isShowSettingsSupported()` and `showSettings()`. Our assembler will not support the dialog.

The "real" `compile()` method is left to be done in the last section.

=== Generating code

So far, we have implemented a parser which creates our AST. Next operations which compilers do are semantic analysis,
optimization and code generation. These three phases are performed on the AST. The algorithms traverse the tree and
update some own internal state, or state of the AST based on visited nodes. Code generator at the end take the results,
and again - by traversing AST - generates the code.

In our case, we don't need any semantic analysis, like type-checks or so, because we have simple machine instructions,
which do not require it. We could optimize them, but for the simplicity we will omit this step as well. We will rather
focus on the final step - code generation.

You might remember the section <<COMPILER_AST>>, which talked about AST traversal. We already have `ASTnode` and `ASTvisitor`
interfaces. The traversal is already implemented, according to the Visitor pattern, by the nodes themselves. One thing
which is left to do is to implement the visitor itself - the code generator class.

For each encountered instruction, the code generator will generate a binary code. Our code generator will write the
binary representation into a file. However, it is generally better if I/O classes work with I/O abstractions
(streams, channels, etc.) rather than specific objects, e.g. files. Out code generator will be implemented in a
similar fashion. The code is as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CodeGenerator.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.runtime.NumberUtils;
import emulib.runtime.NumberUtils.Strategy;
import java.io.IOException;
import java.util.Objects;
import net.sf.emustudio.ssem.assembler.tree.ASTvisitor;
import net.sf.emustudio.ssem.assembler.tree.Constant;
import net.sf.emustudio.ssem.assembler.tree.Instruction;

public class CodeGenerator implements ASTvisitor, AutoCloseable {
    private final SeekableOutputStream writer;
    private int currentLine;

    public CodeGenerator(SeekableOutputStream writer) {
        this.writer= Objects.requireNonNull(writer);
    }

    @Override
    public void setCurrentLine(int line) {
        this.currentLine = line;
    }

    @Override
    public void visit(Instruction instruction) throws CompileException, IOException {
        byte address = instruction.getOperand().orElse((byte)0);

        if (address < 0 || address > 31) {
            throw new CompileException("Operand must be between <0, 31>; it was " + address);
        }

        // Instruction has 32 bits, i.e. 4 bytes
        int addressSSEM = NumberUtils.reverseBits(address, 8) & 0xF8;
        writer.seek(4 * currentLine);

        writer.write(addressSSEM); // address + 3 empty bits

        // next: 5 empty bits + 3 bit instruction
        int opcode = instruction.getOpcode() & 7;
        writer.write(opcode);

        // 16 empty bits
        writer.write(new byte[2]);
    }

    @Override
    public void visit(Constant constant) throws Exception {
        int number = constant.getNumber();

        writer.seek(4 * currentLine);
        writeInt(number);
    }

    private void writeInt(int value) throws IOException {
        Byte[] word = new Byte[4];
        NumberUtils.writeInt(value, word, Strategy.REVERSE_BITS);

        writer.write(word[0]);
        writer.write(word[1]);
        writer.write(word[2]);
        writer.write(word[3]);
    }

    @Override
    public void close() throws Exception {
        writer.close();
    }
}
----

There are several things to notice:

- Output code is written into class `SeekableOutputStream`. Wi will define this class later.
- `CodeGenerator` is a visitor, which has separate methods for code generation of `Constant` and `Instruction`.
- `CodeGenerator` can be "closed" - so it handles closing of the writer (our `SeekableOutputStream`).
- Generated code is binary

The code generation is not that complex. There is some complexity caused by a fact, that the binary representations
are reversed, when comparing to our present-time PCs/laptops.

The idea of generating code for instruction is to prepare 4 bytes, 32 bits, which are then written into the "writer"
as one `Integer`, which has also 32 bits. The instruction format is explained in section <<COMPILER_SSEM_ASM>>. First 5 bits from
the left represent the "line" - instruction operand. It must be reversed.
Then, bits 13,14,15 represent the instruction opcode. It does not have to be reversed here, since the instructions are
already encoded properly in the `Instruction` class. Last two bytes are just empty.

Code generation for constant is much easier - it's just retrieving the value and writing it in the reversed fashion as
`Integer`.

Code generator uses a "seekable" output stream, which allows to seek in the output. It is a separate class, which is
actually an abstract class, extending `OutputStream`. The reason is easier testing:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/SeekableOutputStream.java`
----
package net.sf.emustudio.ssem.assembler;

import java.io.IOException;
import java.io.OutputStream;

public abstract class SeekableOutputStream extends OutputStream {

    public abstract void seek(int position) throws IOException;

}
----

and here's the implementation:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/MemoryAndFileOutput.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.memory.MemoryContext;
import net.jcip.annotations.NotThreadSafe;

import java.io.IOException;
import java.io.RandomAccessFile;

@NotThreadSafe
public class MemoryAndFileOutput extends SeekableOutputStream {
    private final RandomAccessFile file;
    private final MemoryContext<Byte> memoryContext;
    private int position = 0;

    public MemoryAndFileOutput(String filename, MemoryContext<Byte> memoryContext) throws IOException {
        this.file = new RandomAccessFile(filename, "rw");
        this.memoryContext = memoryContext;
    }

    @Override
    public void write(int b) throws IOException {
        if (memoryContext != null) {
            memoryContext.write(position, (byte) (b & 0xFF));
        }
        file.write(b);
        position++;
    }

    @Override
    public void seek(int position) throws IOException {
        this.position = position;
        file.seek(position);
    }

    @Override
    public void close() throws IOException {
        try {
            file.close();
        } finally {
            super.close();
        }
    }
}
----

The "seeking" capability is required, because, as you remember, it's possible to write something like this:

    06 STO 05
    05 LDN 06
    07 STP

It's not quite common, but it's possible.


==== Testing

As being our practice, we must test it.

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/CodeGeneratorTest.java`
----
package net.sf.emustudio.ssem.assembler;

import net.sf.emustudio.ssem.assembler.tree.Instruction;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;

import static org.junit.Assert.assertArrayEquals;

public class CodeGeneratorTest {

    private SeekableByteArrayOutputStream out;
    private CodeGenerator codeGenerator;

    @Before
    public void setUp() throws Exception {
        out = new SeekableByteArrayOutputStream(32);
        codeGenerator = new CodeGenerator(out);
    }

    @After
    public void tearDown() throws Exception {
        codeGenerator.close();
    }

    @Test
    public void testCMP() throws Exception {
        codeGenerator.visit(Instruction.cmp());

        assertArrayEquals(new byte[] {0,Instruction.CMP,0,0}, out.toArray());
    }

    @Test
    public void testSTP() throws Exception {
        codeGenerator.visit(Instruction.stp());

        assertArrayEquals(new byte[] {0,Instruction.STP,0,0}, out.toArray());
    }

    @Test
    public void testJMP() throws Exception {
        codeGenerator.visit(Instruction.jmp((byte)6));

        assertArrayEquals(new byte[] {0x60,Instruction.JMP,0,0}, out.toArray());
    }

    @Test
    public void testJRP() throws Exception {
        codeGenerator.visit(Instruction.jrp((byte)23));

        assertArrayEquals(new byte[] {(byte)0xE8,Instruction.JRP,0,0}, out.toArray());
    }

    @Test
    public void testLDN() throws Exception {
        codeGenerator.visit(Instruction.ldn((byte)12));

        assertArrayEquals(new byte[] {(byte)0x30,Instruction.LDN,0,0}, out.toArray());
    }

    @Test
    public void testSTO() throws Exception {
        codeGenerator.visit(Instruction.sto((byte)30));

        assertArrayEquals(new byte[] {(byte)0x78,Instruction.STO,0,0}, out.toArray());
    }

    @Test
    public void testSUB() throws Exception {
        codeGenerator.visit(Instruction.sub((byte)18));

        assertArrayEquals(new byte[] {(byte)0x48,Instruction.SUB,0,0}, out.toArray());
    }

    private static class SeekableByteArrayOutputStream extends SeekableOutputStream {
        private final byte[] array;
        private int pos;
        private int length;

        public SeekableByteArrayOutputStream(int count) {
            this.array = new byte[count];
        }

        @Override
        public void seek(int position) throws IOException {
            length = Math.max(position, pos);
            pos = position;
        }

        @Override
        public void write(int b) throws IOException {
            array[pos] = (byte)b;
            pos++;
            length = Math.max(pos, length);
        }

        public byte[] toArray() {
            byte[] tmp = new byte[length];
            System.arraycopy(array, 0, tmp, 0, length);
            return tmp;
        }
    }
}
----

=== Finalizing

We're almost done now! What is missing so far is to finish implementation of the main `CompilerImpl.compile()`  method.
Let's begin with it first.

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CompilerImpl.java`
----
public class CompilerImpl extends AbstractCompiler {

    ...

    @Override
    public boolean compile(String inputFileName, String outputFileName) {
        notifyCompileStart();

        int errorCode = 0;
        try (Reader reader = new FileReader(inputFileName)) {
            MemoryContext<Byte> memory = contextPoolImpl.getMemoryContext(pluginID, MemoryContext.class);

            try (CodeGenerator codeGenerator = new CodeGenerator(new MemoryAndFileOutput(outputFileName, memory))) {
                LexerImpl lexer = new LexerImpl(reader);
                ParserImpl parser = new ParserImpl(lexer, new ComplexSymbolFactory(), this);

                Program program = (Program) parser.parse().value;
                if (program == null) {
                    throw new Exception("Unexpected end of file");
                }
                if (parser.hasSyntaxErrors()) {
                    throw new Exception("One or more errors has been found, cannot continue.");
                }

                program.accept(codeGenerator);
                programStart = program.getStartLine() * 4;
                notifyInfo("Compile was successful. Output: " + outputFileName);
            }
        } catch (Exception e) {
            errorCode = 1;
            LOGGER.error("Compilation error.", e);
            notifyError("Compilation error.");

            return false;
        } finally {
            notifyCompileFinish(errorCode);
        }

        return true;
    }

    ...
}
----

As input, we have full path to the input file, and to the output file. It is good to use Java
https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html[try-with-resources]
statement for opening the files. The same approach can be used for the code generator, because the class implements
`AutoCloseable` interface.

We want to notify emuStudio about compilation progress, as we have already done in the parser, when dealing with
parsing errors. For this purpose, `emulib.plugins.compiler.AbstractCompiler` class offers several methods:

- `notifyCompileStart()`, which will inform emuStudio that the compilation has started,
- `notifyCompileFinish(errorCode)` will inform emuStudio that the compilation has finished, with given error code. footnote:[The
  error code should be defined by you, developer, if you want. It is a convention used also in other compilers that
  specific error has assigned a unique number. In our compiler, we do not use it.]
- `notifyOnMessage()` - notifies emuStudio about some general message, it can be either error, info, warning.
- `notifyWarning()` - compiler warning
- `notifyError()` - compilation error
- `notifyInfo()` - informational message

=== Command-line interface (CLI)

It might be sometimes useful to being able to run the compiler from the command line. We can add the implementation
in the `Main` class, as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/Main.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.Compiler;
import emulib.plugins.compiler.Message;
import emulib.runtime.ContextPool;

public class Main {

    public static void main(String... args) {
        String inputFile;
        String outputFile = null;

        int i;
        for (i = 0; i < args.length; i++) {
            String arg = args[i].toLowerCase();
            if ((arg.equals("--output") || arg.equals("-o")) && ((i + 1) < args.length)) {
                outputFile = args[++i];
            } else if (arg.equals("--help") || arg.equals("-h")) {
                printHelp();
                return;
            } else if (arg.equals("--version") || arg.equals("-v")) {
                System.out.println(new CompilerImpl(0L, new ContextPool()).getVersion());
                return;
            } else {
                break;
            }
        }
        if (i >= args.length) {
            System.err.println("Error: expected input file name");
            return;
        }
        inputFile = args[i];
        if (outputFile == null) {
            int index = inputFile.lastIndexOf('.');
            if (index != -1) {
                outputFile = inputFile.substring(0, index);
            } else {
                outputFile = inputFile;
            }
            outputFile += ".bin";
        }

        CompilerImpl compiler = new CompilerImpl(0L, new ContextPool());
        compiler.addCompilerListener(new Compiler.CompilerListener() {
            @Override
            public void onStart() {
            }

            @Override
            public void onMessage(Message message) {
                System.err.println(message.toString());
            }

            @Override
            public void onFinish(int errorCode) {
                System.err.println("Compilation finished (error code: " + errorCode + ")");

            }
        });
        try {
            compiler.compile(inputFile, outputFile);
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }
    }

    private static void printHelp() {
        System.out.println("Syntax: java -jar as-ssem.jar [-o outputFile] inputFile\nOptions:");
        System.out.println("\t--output, -o\tfile: name of the output file");
        System.out.println("\t--version, -v\t: print version");
        System.out.println("\t--help, -h\t: this help");
    }

}
----

And that was the very last thing, now you have SSEM compiler ready :)
