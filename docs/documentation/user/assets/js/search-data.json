{
  
  "0": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "/documentation/user/404.html",
    "relUrl": "/404.html"
  }
  ,"1": {
    "title": "CPU 8080-cpu",
    "content": "Intel 8080 CPU emulator . Altair 8800 originally came with processor Intel 8080. It is 8-bit microprocessor, from 1974. Initial clock frequency was 2 MHZ. This processor was one of the first general-purpose and widespread processors, used not only in calculators but also in first personal computers. One of the key roles why this CPU become so popular is that Gary Killdall targeted his CP/M to this CPU; and CP/M was de facto a “standard” in personal computers those days. . Main features of the emulator include: . Threaded-dispatch combined with interpretation as emulation technique, | Correct real timing of instructions, | Ability to set clock frequency manually at run-time, | Emulation of all instructions including interrupts, | Disassembler implementation, | Ability to “dump” instruction history to console at run-time, | Support of breakpoints, | Ability of communication with up to 256 I/O devices, | Status window shows all registers, flags, and run-time frequency. | . Configuration file . The following table shows all the possible settings of Intel 8080 CPU plugin: . Name Default value Valid values Description . printCode | false | true / false | Whether the emulator should print executed instructions, and its internal state to console (dump) | . printCodeUseCache | false | true / false | If printCode is set to true, then a cache will be used which remembers already visited blocks of code so the instruction dump will not be bloated with infinite loops | . Dumping executed instructions . The CPU offers a quite unique feature, which is the ability to dump executed instructions as a sequence to the console. When enabled, then each executed instruction - together with content of flags and registers values after the execution are printed. This feature might be extremely useful in two cases: . Reverse engineering of some unknown software | It allows to build tools for automatic checking of register values during the emulation, when performing automatic emulation. | In order to enable this feature, please see the section “Configuration file”. . For example, let’s take one of the examples which computes a reverse text: . ; Print reversed text org 1000 dcx sp ; stack initialization (0FFFFh) lxi h,text1 call putstr ; print text1 lxi d,input ; address for string input call getline ; read from keyboard lxi b,input mvi d,0 ; chars counter char_loop: ldax b inx b ; bc = bc+1 cpi 10 ; end of input? jz char_end cpi 13 jz char_end inr d ; d =d+1 jmp char_loop char_end: dcx b ; bc = bc-1 dcx b call newline char2_loop: ldax b call putchar dcx b dcr d jz char2_end jmp char2_loop char2_end: hlt include &#39;include getchar.inc&#39; include &#39;include getline.inc&#39; include &#39;include putstr.inc&#39; include &#39;include putchar.inc&#39; include &#39;include newline.inc&#39; text1: db &#39;Reversed text ...&#39;,10,13,&#39;Enter text: &#39;,0 text2: db 10,13,&#39;Reversed: &#39;,0 input: ds 30 . When the program is being run, and the dump instructions feature is turned on, on console you can see the following output: . 0000 | PC=03e8 | dcx SP | 3B || regs=00 00 00 00 00 00 00 00 | flags= | SP=ffff | PC=03e9 0001 | PC=03e9 | lxi HL, 485 | 21 85 04 || regs=00 00 00 00 04 85 00 00 | flags= | SP=ffff | PC=03ec 0001 | PC=03ec | call 46D | CD 6D 04 || regs=00 00 00 00 04 85 00 00 | flags= | SP=fffd | PC=046d 0002 | PC=046d | mov A, M | 7E || regs=00 00 00 00 04 85 00 52 | flags= | SP=fffd | PC=046e 0002 | PC=046e | inx HL | 23 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=046f 0003 | PC=046f | cpi 0 | FE 00 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0471 0004 | PC=0471 | rz | C8 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0472 0005 | PC=0472 | out 11 | D3 11 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0474 0006 | PC=0474 | jmp 46D | C3 6D 04 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=046d 0006 | PC=046d | mov A, M | 7E || regs=00 00 00 00 04 86 00 65 | flags= | SP=fffd | PC=046e 0024 | Block from 0474 to 03EF; count=184 0024 | PC=03ef | lxi DE, 4B2 | 11 B2 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=ffff | PC=03f2 0025 | PC=03f2 | call 428 | CD 28 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=0428 0025 | PC=0428 | mvi C, 0 | 0E 00 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042a 0025 | PC=042a | in 10 | DB 10 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042c 0026 | PC=042c | ani 1 | E6 01 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042e 0026 | PC=042e | jz 42A | CA 2A 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042a 0027 | PC=042a | in 10 | DB 10 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042c 1548 | Block from 042E to 0431; count=181125 1548 | PC=0431 | in 11 | DB 11 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0433 1548 | PC=0433 | cpi D | FE 0D || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0435 1548 | PC=0435 | jz 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0438 1548 | PC=0438 | cpi A | FE 0A || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=043a 1549 | PC=043a | jz 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=043d 1549 | PC=043d | cpi 8 | FE 08 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=043f 1549 | PC=043f | jnz 459 | C2 59 04 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=0459 1549 | PC=0459 | out 11 | D3 11 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=045b 1549 | PC=045b | stax DE | 12 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=045c 1549 | PC=045c | inx DE | 13 || regs=00 00 04 b3 04 a5 00 68 | flags= AP | SP=fffd | PC=045d 1549 | PC=045d | inr C | 0C || regs=00 01 04 b3 04 a5 00 68 | flags= | SP=fffd | PC=045e 1549 | PC=045e | jmp 42A | C3 2A 04 || regs=00 01 04 b3 04 a5 00 68 | flags= | SP=fffd | PC=042a 1550 | PC=042a | in 10 | DB 10 || regs=00 01 04 b3 04 a5 00 00 | flags= | SP=fffd | PC=042c 2940 | Block from 045E to 0461; count=267777 2940 | PC=0461 | mvi A, A | 3E 0A || regs=00 05 04 b7 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0463 2940 | PC=0463 | stax DE | 12 || regs=00 05 04 b7 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0464 2940 | PC=0464 | inx DE | 13 || regs=00 05 04 b8 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0465 2940 | PC=0465 | mvi A, D | 3E 0D || regs=00 05 04 b8 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0467 2940 | PC=0467 | stax DE | 12 || regs=00 05 04 b8 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0468 2940 | PC=0468 | inx DE | 13 || regs=00 05 04 b9 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0469 2940 | PC=0469 | mvi A, 0 | 3E 00 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=fffd | PC=046b 2941 | PC=046b | stax DE | 12 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=fffd | PC=046c 2941 | PC=046c | ret | C9 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03f5 2941 | PC=03f5 | lxi BC, 4B2 | 01 B2 04 || regs=04 b2 04 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03f8 2941 | PC=03f8 | mvi D, 0 | 16 00 || regs=04 b2 00 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03fa 2941 | PC=03fa | ldax BC | 0A || regs=04 b2 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=03fb 2941 | PC=03fb | inx BC | 03 || regs=04 b3 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=03fc 2941 | PC=03fc | cpi A | FE 0A || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=03fe 2941 | PC=03fe | jz 40A | CA 0A 04 || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0401 2942 | PC=0401 | cpi D | FE 0D || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0403 2942 | PC=0403 | jz 40A | CA 0A 04 || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0406 2942 | PC=0406 | inr D | 14 || regs=04 b3 01 b9 04 a5 00 68 | flags= | SP=ffff | PC=0407 2942 | PC=0407 | jmp 3FA | C3 FA 03 || regs=04 b3 01 b9 04 a5 00 68 | flags= | SP=ffff | PC=03fa 2942 | PC=03fa | ldax BC | 0A || regs=04 b3 01 b9 04 a5 00 65 | flags= | SP=ffff | PC=03fb 2942 | Block from 0407 to 040A; count=36 2942 | PC=040a | dcx BC | 0B || regs=04 b7 05 b9 04 a5 00 0a | flags= ZAP | SP=ffff | PC=040b 2943 | PC=040b | dcx BC | 0B || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=ffff | PC=040c 2943 | PC=040c | call 47A | CD 7A 04 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047a 2943 | PC=047a | mvi A, A | 3E 0A || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047c 2943 | PC=047c | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffb | PC=0477 2943 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffb | PC=0479 2943 | PC=0479 | ret | C9 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047f 2943 | PC=047f | mvi A, D | 3E 0D || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0481 2943 | PC=0481 | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffb | PC=0477 2943 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffb | PC=0479 2943 | Block from 0481 to 0484; count=2 2943 | PC=0484 | ret | C9 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=ffff | PC=040f 2944 | PC=040f | ldax BC | 0A || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=ffff | PC=0410 2944 | PC=0410 | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=fffd | PC=0477 2944 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=fffd | PC=0479 2944 | Block from 0410 to 0413; count=2 2944 | PC=0413 | dcx BC | 0B || regs=04 b5 05 b9 04 a5 00 6f | flags= ZAP | SP=ffff | PC=0414 2944 | PC=0414 | dcr D | 15 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=0415 2944 | PC=0415 | jz 41B | CA 1B 04 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=0418 2944 | PC=0418 | jmp 40F | C3 0F 04 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=040f 2944 | PC=040f | ldax BC | 0A || regs=04 b5 04 b9 04 a5 00 6c | flags= A | SP=ffff | PC=0410 2945 | Block from 0418 to 041B; count=31 2945 | PC=041b | hlt | 76 || regs=04 b1 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=041c . The dump format consists of lines, each line represents one instruction execution. The line is separated by | chars, splitting it into so-called sections. Sections before the sequence || represent state before instruction execution, and sections after it represent the state after instruction execution. Particular sections are described in the following table. . Column Description . 1 | Timestamp from program start (seconds) | . 2 | Program counter before instruction execution | . 3 | Disassembled instruction | . 4 | Instruction opcodes | .   | Now follows the state after instruction execution | . 5 | Register values (B,C,D,E,H,L, reserved (always 0), A) | . 6 | Flags | . 7 | Stack pointer register (SP) | . 8 | Program counter after instruction execution | .",
    "url": "/documentation/user/altair8800/8080-cpu",
    "relUrl": "/altair8800/8080-cpu"
  }
  ,"2": {
    "title": "Device 88-disk",
    "content": "Disk controller “88-disk” . Altair Disk offered the advantage of fixed memory including relatively fast access to data. The speed of data transfer was 250 Kb/s (The plugin does not emulate this). Disk was connected with disk controller (or board), and the data were transferred in serial fashion, bit after bit. . Disk controller, on the other hand communicated with CPU. It transformed these serial data into 8-bit words which were stored/read by CPU into/from operating memory. . MITS 88-DISK offered to connect up to 16 disk devices (one can be seen in the front image in the Introduction section). . Original manual can be downloaded at this link. . Features . A plugin emulates basic functionality of the whole disk system for Altair 8800 computer. It is not only disk controller, but also the disk drive. . The features include: . allows to mount up to 16 disk images | CPU ports can be set manually | images can be saved for automatic mount at startup | GUI | . Interrupts are not supported yet. . Mounting disk images . In order to mount DISK images to the device, please open device settings: . . A: Select drive (A - P) | B: Choosing the image file | C: Set sectors count and sector length for the current drive. (NOTE: Be cautious with the settings. Incorrect values can result in disk image file damage. Default values are used for classic Altair8800 image files used by simh). | D: Set default values for sector count and sector length for the current drive. | E: Mount/unmount the image file onto/from the selected drive. Mount operation: If there is any disk mounted already, the new image will be re-mounted. | F: Check box for saving the settings into the computer configuration file. If checked, the settings will be loaded after start. | . CPU Ports settings . MITS 88-DISK board communicates with CPU using its ports. There are three ports overall, each for different function. By default, the ports used by 88-DISK are: . port 1: 0x08 | port 2: 0x09 | port 3: 0x0A | . These numbers can be changed in the Settings window, tab “CPU Ports”: . . Configuration file . The following table shows all the possible settings of MITS 88-DISK plugin: . Name Default value Valid values Description . port1CPU | 0x08 | &gt; 0 and &lt; 256 | Number of Port 1 | . port2CPU | 0x09 | &gt; 0 and &lt; 256 | Number of Port 2 | . port3CPU | 0x0A | &gt; 0 and &lt; 256 | Number of Port 3 | . sectorsPerTrack | 32 | &gt; 0 | Count of sectors in a disk image | . sectorLength | 137 | &gt; 0 | Size of one sector in bytes | . image0 | N/A | Path to existing file | File name to mount on disk A (0) | . … | … | … | … | . image15 | N/A | Path to existing file | File name to mount on disk P (15) | . Programming . Data are written onto or read from disk in a serial fashion. The position in the floppy disk is uniquely set by the track number, sector number and the offset in the sector. It is rudimentary to know how many tracks are available, so as how many sectors per track and the sector size. . In Altair8800, drive Pertec FD400 used 8” diskettes. Each had 77 tracks. The track had 32 sectors with 137 bytes long. Capacity was therefore 77 * 32 * 137 = 337568 B = 330 kB. Software used less capacity, because 9 bytes from each sector were used for the integrity checksum. . Setting the position . Track number and sector number can be set only incrementally, not directly. Setting the offset within the sector is more challenging. . After track and sector were set, programmer must “poll” the status port which tells him when the disk position is set to the beginning of the sector. Then, programmer must read data until he gets to the position where he wanted. . CPU Ports . Controller communicates with CPU using three I/O ports at addresses (by default) 0x08, 0x09 and 0x0A. The following table shows the CPU ports and how they are used. . Port Address Input Output . 1 | 0x08 | Disk and controller status | Select disk | . 2 | 0x09 | Get number of sector | Disk settings | . 3 | 0x0A | Read data | Write data | . Now, detailed description of the ports follow. Bits are ordered in a byte as follows: . D7 D6 D5 D4 D3 D2 D1 D0 . where D7 is the most significant bit, and D0 the least significant bit. . Port 1 (default address: 0x08) . WRITE: . Selects and enables one of 16 disk devices. By selecting a drive, all further operations will be performed on that drive. If the disk has not mounted any disk image, all further operations will be ignored. The previously selected device will be disabled. . D7 : if the value is 1, disable the drive. If the value is 0, select and enable the drive. | D6 D5 D4 : unused bits | D3 D2 D1 D0: index of the drive to be selected. From 0-15. | . READ: . Read disk status of the selected drive. . D7 : New read data available. Indicates if there is at least 1 byte available for reading from Port 3 (value=0). It will be reset after data are read (value=1). If the value is 1, data read from Port 3 will be invalid or no new data is available. | D6 : Track 0. Indicates if the head is positioned at track 0 (value=0). | D5 : Interrupt Enabled. Indicates if interrupts are used (value=0). The plugin does not support interrupts, therefore the value will be always 1. | D4 D3 : Unused bits; they are always 0. | D2 : Head Status. Indicates the correctness of the head setting. If the value is 0, reading sector number from Port 2 will be valid. | D1 : Move head. Indicates if the movement of the disk head is allowed. If the value is 1, all track number changes will be ignored. | D0 : Enter new write data. Indicates if the device is ready for writing data. If the value is 1, all written data will be ignored. | . Initial values of the bits are: 11100111. . Port 2 (default address: 0x09) . WRITE: . Control the disk head, and other settings if a disk drive is selected. . D7 : Write Enable. Initializes write sequence (enables writing to the disk; value=1). The plugin sets the sector number to 0 and also value 0 to bit D0 of Port 1 (Enter new write data). According to manual the write sequence holds only for short time, maximally until the end of sector is reached. The plugin does not limit the sequence period, it is deactivated only when the end of the sector is reached. In addition each first byte and the last byte of a sector should have set its MSB (7th bit) to 1. It was called the “sync bit” for easier identification of start or end of a sector. However, the plugin does not require it. | D6 : Head Current Switch. On real disks the bit should be set to 1 when a program is writting data to tracks from 43-76. The plugin the bit is ignored. | D5 : Interrupt Disable. Setting is ignored sicne plugin does not support interrupts. | D4 : Interrupt Enable. Setting is ignored sicne plugin does not support interrupts. | D3 : Head unload. Removes head from the disk surface. Reading sector number will now become invalid. In addition, value of bit D7 from Port 1 (New read data available) become 1 (no new data). | D2 : Head load. Sets the disk head onto disk surface. Reading sector number now becomes valid. If additionally the bit D7 from Port 1 (New data available) is set, it is possible to read data from the disk. | D1 : Step Out. Move the disk head back by 1 track (the track number is decremented). It is required to check bit D1 of Port 1 (Move head) to have value 0. | D0 : Step In. Move the disk head ahead by 1 track (the track number is incremented). It is required to check bit D1 of Port 1 (Move head) to have value 0. | . READ: . Reads the number of the sector. The value can be read only if a disk drive is selected and the disk head is positioned at the disk surface (by setting the bit D2). . D7 D6 : Unused bits; they are always 1. | D5 D4 D3 D2 D1: Number of the sector, counted from 0. | D0 : Sector True. If the value is 0, the offset in sector is 0. According to manual, the bit is set for maximum 30 microseconds. Programs could detect the bit set and quickly start writing data until the Sector true came back again. It could be made in time easily, because CPU was much faster than disk itself. plugin does not limit the period. The value is 0 practically all the time, until first byte is written. | . Port 3 (default address: 0x0A) . WRITE: . Write a byte to disk. In order to perform valid write, the Write Enable D7 bit of Port 2 must be set to 1. Before data are written to disk, it is required to check bit D0 from Port 1 (Enter new write data). . READ: . Read a byte from disk. In order to perform valid read, the Head load D2 bit of Port 2 must be set to 1. Only if bit D7 from Port 1 (New read data available) is set to 0, the read data are valid. . Program example . In this section, an example is presented showing how to read/write data from/to the floppy disk. At first, it writes one byte (letter A with ASCII value 65) to track 1, sector 18 and offset 20. Then, it reads the byte to operating memory at address 0x200. . The program uses 3 procedures (in assembler for Intel 8080) for setting the disk position (ltrack for loading the track number, lsector for loading the sector number, and loffset for loading the offset within the sector) and two more for data reading (read) and writing (write). . disk0 equ 0 ; disk number track equ 1 ; track number sector equ 18 ; sector number offset equ 20 ; offset within the sector data equ &#39;A&#39; ; data for writing dcx sp ; set stack register to 0xFFFF mvi a, disk0 ; select disk out 08h call ltrack ; set track number call we ; set &#39;write enable&#39; sequence call lsector ; set sector number call loffset ; set sector offset call write ; write data call lsector ; set sector number (for clearing the offset) call loffset ; set sector offset call read ; read data lxi h, readdata ; load address for reading the data mov m, a ; move the data there hlt ; end ltrack0: ; the procedure will set track number to 0 in 08h ; read disk status ani 1000000b ; track 0 ? rz ; yes, return mvi a, 1000b ; head unload out 09h call movetrk ; wait until the disk head can be moved mvi a, 10b ; step out, decrement track number out 08h jmp ltrack0 ltrack: ; procedure sets a track number call ltrack0 ; at first, set track number to 0 mvi b, track+1 ; b = track + 1 stepin: ; stepin: { dcr b ; b--; rz ; if (b == 0) return; call movetrk ; wait until the disk head can be moved mvi a, 1 ; step in, increment track number out 09h jmp stepin ; goto stepin; ; } movetrk: ; procedure waits until the disk head can be moved in 08h ; read disk status ani 10b ; can the disk head be moved? jnz movetrk ; nope, try again... ret ; yes, return lsector: ; procedure sets a sector number mvi a, 100b ; head load out 09h waits: in 09h ; read sector number ani 3Fh ; clear unused bits rrc cpi sector ; is the number what is requested? jnz waits ; nope, try again ret ; yes, return loffset: ; procedure sets a sector offset mvi b, offset+1 ; b = offset + 1 stepoff: ; stepoff: { dcr b ; b--; rz ; if (b == 0) return; call read ; read data; the offset is incremented jmp stepoff ; goto stepoff; ; } read: ; procedure reads data from the disk in 08h ; read disk status ani 100b ; check if the disk head is loaded on the disk surface rnz ; if not, return waitr: in 08h ; read disk status ani 10000000b ; New read data available ? jnz waitr ; nope, try again... in 0Ah ; yes, read data ret ; return we: ; procedure enables &#39;write enable&#39; sequence mvi a, 10000000b ; write enable out 09h ret write: ; procedure writes data to the disk in 08h ; read disk status ani 100b ; check if the disk head is loaded on the disk surface rnz ; if not, return waitw: in 08h ; read disk status ani 1 ; enter new write data ? jnz waitw ; nope, try again... mvi a, data ; yes, write data out 0Ah ret org 200h readdata: db 0 .",
    "url": "/documentation/user/altair8800/88-disk",
    "relUrl": "/altair8800/88-disk"
  }
  ,"3": {
    "title": "Device 88-sio",
    "content": "Serial board “88-sio” . Altair 8800 computer was equipped with serial board called 88-SIO, or 88-2 SIO. It was a device which allowed connecting other devices using RS-232 interface. From one side it was attached to CPU on at least two ports (most commonly 0x10 and 0x11). The other side was ended with one or two physical ports (allowing to connect one or two devices). Real board supported both hardware and software interrupts. . The following image shows MITS 88-SIO-2 board. . . Original manual of MITS 88-SIO serial board can be downloaded at this link. . Features . The plugin emulates only basic functionality of the board. It has the following features: . allows to connect one device only | CPU ports can be set manually | setting of transfer speed, parity, number of stop bits is not supported | GUI | . Interrupts are not supported yet. . CPU Ports settings . MITS 88-SIO board is attached to CPU using multiple ports. By default, the used CPU ports are: . Status port: 0x03, 0x10, 0x14, 0x16, 0x18 (preferred: 0x10) | Data port: 0x02, 0x11, 0x15, 0x17, 0x19 (preferred: 0x11) | . The reason why there are multiple “bindings” is that there existed various software which expected specific bindings. The presented default values are the most common ones. . These numbers can be changed in the Settings window: . . A: Attach Status SIO port to some new CPU port. The CPU port must be unique among both Status and Data ports attachments. | B: Detach Status SIO port from selected CPU port. | C: Attach Data SIO port to some new CPU port. The CPU port must be unique among both Status and Data ports attachments. | D: Detach Data SIO port from selected CPU port. | E: List of CPU ports to which the Status SIO port is attached | F: Clear the current attachements of the Status SIO port and attach it to default CPU ports | G: List of CPU ports to which the Data SIO port is attached | H: Clear the current attachements of the Data SIO port and attach it to default CPU ports | I: When selected, clicking on OK button will save the settings and will be applied at next emuStudio start. | . Connecting devices . MITS 88-SIO board as emuStudio plugin is a device which does nothing really useful. It just listens (and understands) commands coming from CPU through the I/O ports. The command is either a request for reading or request for writing to the attached device. . Theoretically any device which supports the basic I/O (reading/writing), can be attached to the board. More about plugin internals can be found in programmer’s manual of emuStudio, which is not part of the user documentation. . Usually, attached devices were: . serial terminal | line printer | paper tape reader/punch | . In current implementation of Altair 8800 emulator, the only suitable device which can be attached to the board is terminal ADM-3A from Lear Siegler, Inc and which is described in its own section. . Configuration file . The following table shows all the possible settings of MITS 88-SIO plugin: . Name Default value Valid values Description . statusPortNumberX | 0x10 | &gt; 0 and &lt; 256; X range from 0 upwards | X-th Number of Status Port | . dataPortNumberX | 0x11 | &gt; 0 and &lt; 256; X range from 0 upwards | X-th Number of Data Port | . As can be seen; the X represents a number, it’s a way how two SIO ports can be attached to multiple CPU ports. . Programming . In order to show something useful, let’s assume that a terminal LSI ADM-3A is attached to the board. Remember, the board only mediates the communication, it does not interpret any of the sent/received characters. . CPU Ports . Whole communication between the board (and attached device) and CPU is controlled by programming the two ports: Status port and Data port. The following table shows the ports and how they are used. . Port Address Input Output . 1 | 0x10 | Read board status | Not used. Originally used for enabling/disabling interrupts. | . 2 | 0x11 | Read data | Write data | . Now, detailed description of the ports follow. Bits are ordered in a byte as follows: . D7 D6 D5 D4 D3 D2 D1 D0 . where D7 is the most significant bit, and D0 the least significant bit. . Port 1 (“Control” port) . Default addresses: 0x03, 0x10, 0x14, 0x16, 0x18 (preferred is 0x10) . WRITE: . Controls input/output interrupts enable. If both interrupts are set to be enabled, it only empties transmitter buffer in the device, which was a post-step after interrupts being enabled. However, the plugin does not implement interrupts support. . D7 D6 D5 D4 D3 D2 : unused bits | D1 D0 : Used for enabling/disabling interrupts. Not used in emuStudio. | . READ: . Read status of the device. . D7 : Output device ready. Always 0 in the emulator. | D6 : Not used (always 0). | D5 : Data available (for writing to the attached device). Always 0 in the emulator, meaning that no data is pending to be written. Data are written immediately after OUT instruction. | D4 : Data overflow. Value 1 means a new word of data has been received before the previous word was inputted to the accumulator. In emuStudio, this never happens. | D3 : Framing error. Value 1 means that data bit has no valid stop bit. In emuStudio, this never happens. | D2 : Parity error. Value 1 means that received parity does not agree with selected parity. In emuStudio, this never happens. | D1 : Transmitter buffer empty. Value 1 means that the data word has been received from the attached device and it’s available for reading (from the Data port). | D0 : Input device ready. Value 1 means that the CPU can write data to the SIO (that the board is ready). Always 1 in the emulator. | . Port 2 (“Data” port) . Default addresses: 0x02, 0x11, 0x15, 0x17, 0x19 (preferred is 0x11) . WRITE: . Write data to the attached device. . READ: . Read data from the attached device. . If the attached device sends asynchronously multiple data, the emulated board stores all in a buffer (queue) with unlimited capacity, so no data should be lost and can be read anytime. . Program example . In this section it will be shown a small “How to” program terminal using 88-SIO ports. . Print a character on screen . In emuStudio, it is enough to write data to Port 2, e.g.: . mvi a, &#39;H&#39; out 11h mvi a, &#39;i&#39; out 11h . Print a string on screen . For writing strings, it is more practical to have a procedure. . lxi h, text ; load address of &#39;text&#39; label to HL call print ; print text hlt ; halt CPU text: db &#39;Hello, world!&#39;,0 ; Procedure for printing text to terminal. ; Input: pair HL must contain the address of the ASCIIZ string print: mov a, m ; load character from HL inx h ; increment HL cpi 0 ; is the character = 0? rz ; yes; quit out 11h ; otherwise; show it jmp print ; and repeat from the beginning . Reading character from keyboard . For reading a character, it is required to read the Port 1 until the character is not ready. Then we can read it from Port 2. . ; Procedure will read a single character from terminal ; Input: none ; Output: register A will contain the character. getchar: in 10h ; read Port 1 ani 1 ; is data ready ? jz getchar ; not; try again in 11h ; yes; read it (into A register) ret . Reading text from keyboard . Now follows an example, which will read a whole line of characters into memory starting at address in DE pair. The procedure will interpret some control keys, like: backspace and ENTER keys. . lxi h, text ; load address of &#39;text&#39; label to HL xchg ; DE &lt;-&gt; HL call getline ; read line from the keyboard into DE lxi h, text ; load &#39;text&#39; address again call print ; print the text on screen hlt ; halt CPU text: ds 30 ; here will be stored the read text ;Procedure for reading a text from keyboard. ;Input: DE = address, where the text should be put after reading ; C = is used internally getline: mvi c, 0 ; register C will be used as a counter of ; read characters next_char: in 10h ; read Port 1: status ani 1 ; is the char ready for reading? jz next_char ; not; try again in 11h ; yes; read it to A register ; now ENTER and Backspace will be interpreted cpi 13 ; ENTER? jz getline_ret ; yes; it means end of input cpi 8 ; Backspace ? jnz save_char ; if not; store the character ; Backspace interpretation mov a, c ; A &lt;- number of read characters cpi 0 ; are we at the beginning? jz next_char ; yes; ignore the backspace dcx d ; not; decrement DE dcr c ; decrement count of read characters mvi a,8 ; &quot;show&quot; the backspace (terminal will ; interpret this by moving the cursor ; to the left by 1 char) out 11h mvi a, 32 ; &quot;clear&quot; the current character on screen ; by a space character (ASCII code 32) out 11h mvi a,8 ; and move the cursor back again out 11h jmp next_char ; jump to next char save_char: ; stores a character into memory at DE out 11h ; show the character in A register stax d ; store it at address DE inx d ; increment DE inr c ; increment number of read characters jmp next_char ; jump to next char getline_ret: ; end of input ; ENTER will be stored as CRLF mvi a,13 ; CR (Carriage Return) stax d ; store the char inx d ; increment DE mvi a, 10 ; LF (Line Feed) stax d ; store the char inx d ; increment DE mvi a, 0 ; char 0 (End-Of-Input) stax d ; store the char ret ; return .",
    "url": "/documentation/user/altair8800/88-sio",
    "relUrl": "/altair8800/88-sio"
  }
  ,"4": {
    "title": "Abstract tape",
    "content": "Abstract tape . Abstract tapes, in general, are used in various abstract machines. Probably the best known are Turing machine, RAM machine and RASP machine. plugin of the abstract tape for emuStudio is called abstractTape-ram. . There are several properties which an abstract tape might have: . Bounded, one-side bounded or unbounded | Random access (allowing to move head in both directions) or linear access (allowing to move head only in one direction) | Specific or any cell content type (e.g. cells are integers, or strings, or can be any value?) | Read only, or read-write cells | Purpose of the tape (title) | . This plugin allows to set up such properties, but those are set up by the virtual computer which uses it, not by the user. For more information, please see the programming section. . Currently, there are just two virtual computers utilizing this plugin: . RAM machine | RASP machine | . After emuStudio is run, RAM CPU (or RASP CPU) sets up properties for all used tapes. So the tape “purpose” and behavior is set in run time. . Graphical user interface (GUI) . The graphical user interface of the abstract tape is very simple. In order to open it, select the tape in the peripheral devices list in the Emulator panel. Then, click on the “Show” button. . . The symbol, highlighted with the blue color is the current head position, in this case. In order to manipulate with particular symbols, one must select the symbol, which appears in bold, as in the following image: . . A: If the tape allows it, one can add new symbol before the selected one in the tape. In the image, the tape does not allow it. | B: The tape content area. Usually, each row consists of the symbol “index” or position within the tape, followed by the symbol itself. | C: If the tape allows it, one can add new symbol after the last one in the tape. In the image, the tape allows it. | D: Removes selected symbol from the tape. | E: Edits the tape symbol. The symbol must be selected. | F: Clears the tape content | . Settings . The tape allows to edit some settings from the graphical mode; to open the settings window click on the “Settings” button below the peripheral devices list in the Emulator panel. The window can be seen in the following image: . . A: Do not allow the tape to fall behind other window | B: Show the tape right after emuStudio start | . Configuration file . The following table shows all the possible settings of Abstract tape plugin: . Name Default value Valid values Description . showAtStartup | false | true, false | If the tape should be shown automatically after emuStudio is started | . alwaysOnTop | false | true, false | Whether the tape GUI should not allow to fall behind other windows | . Automatic emulation . Abstract tape supports automatic emulation. It means, that every change to it is being written to a file. The file name is devised from the title of the tape, by the following algorithm: . At first, all spaces in the title are replaced with underscore (_) | Then, all “unwanted” characters are also replaced with underscore | Every character is converted to lower-case | Finally, the .out extension is added at the end. | . Unwanted characters are the following: *, ., #, %, &amp;, +, !, ~, /, ?, &lt;, &gt;, ,, |, {, }, [, ], &quot;, , = . Using abstract tapes in your emulator . NOTE: This section is for developers of emulators. . The Abstract tape plugin can be used in various computers. Besides standard operations which are provided by net.emustudio.emulib.plugins.device.DeviceContext interface, it provides custom context API. . Usually, the tapes are used by CPU plugins, but it is of course possible to use it in any other plugin. You can obtain the context during the Plugin.initialize() method of the plugin root class. The context is named net.emustudio.plugins.device.abstracttape.api.AbstractTapeContext: . @PluginRoot(...) public class YourPlugin { ... public void initialize() throws PluginInitializationException { AbstractTapeContext tape = applicationApi.getContextPool().getDeviceContext(pluginID, AbstractTapeContext.class); ... } ... } . The tape context interface has the following content: . package net.emustudio.plugins.device.abstracttape.api; import net.emustudio.emulib.plugins.annotations.PluginContext; import net.emustudio.emulib.plugins.device.DeviceContext; /** * Public API of the abstract tape. */ @SuppressWarnings(&quot;unused&quot;) @PluginContext public interface AbstractTapeContext extends DeviceContext&lt;String&gt; { /** * Clear content of the tape. */ void clear(); /** * Set this tape to left-bounded or unbounded. * * @param bounded true if the tape should be left-bounded, * false if unbounded. */ void setBounded(boolean bounded); /** * Determine if the tape is left-bounded. * * @return true - left-bounded, false - unbounded. */ boolean isBounded(); /** * Move the tape one symbol to the left. * &lt;p&gt; * If the tape is left-bounded and the old position is 0, tape won&#39;t move. Otherwise the tape * will expand to the left - add new empty symbol to position 0 and shift the rest of the content to the right. * * @return true if the tape has been moved; false otherwise (if it is left-bounded and the position is 0). */ boolean moveLeft(); /** * Move tape to the right. If the tape is too short, it is expanded to the right (added new empty symbol). */ void moveRight(); /** * Allow or disallow to edit the tape. * &lt;p&gt; * If the tape is editable, the user (in GUI) can add, modify or remove symbols from the tape. * Otherwise it is driven only by the CPU. * * @param editable true if yes, false if not. */ void setEditable(boolean editable); /** * Get symbol at the specified position. * * @param pos position in the tape, starting from 0 * @return symbol at given position; if the position is out of bounds, then empty string is returned. */ String getSymbolAt(int pos); /** * Set symbol at the specified position. * &lt;p&gt; * If the position is &lt; 0, then no symbol will be set. * &lt;p&gt; * If the position is &gt; tape size, empty symbols will be added until the required tape size is ensured. * Then, the symbol is added at the specified position. * &lt;p&gt; * This method should be used only when loading some initial content to the tape. * * @param pos position in the tape, starting from 0 * @param symbol symbol value */ void setSymbolAt(int pos, String symbol); /** * Sets whether the symbol at which the head is pointing should be &quot;highlighted&quot; in GUI. * * @param visible true if yes; false otherwise. */ void setHighlightHeadPosition(boolean visible); /** * Seths whether the tape should be cleared at emulation reset. * * @param clear true if yes; false otherwise. */ void setClearAtReset(boolean clear); /** * Set title (purpose) of the tape. * * @param title title of the tape */ void setTitle(String title); /** * Determines if the symbol positions should be displayed in GUI. * * @return true if yes; false otherwise */ boolean showPositions(); /** * Set whether the symbol positions should be displayed in GUI. * * @param showPositions true if yes; false otherwise. */ void setShowPositions(boolean showPositions); /** * Get the tape head position. * * @return current position in the tape; starts from 0 */ int getHeadPosition(); /** * Get the size of the tape * * @return tape size */ int getSize(); /** * Determine if the tape is empty. * * @return true if the tape is empty; false otherwise. */ boolean isEmpty(); } .",
    "url": "/documentation/user/ram/abstract-tape",
    "relUrl": "/ram/abstract-tape"
  }
  ,"5": {
    "title": "Device adm3a-terminal",
    "content": "Terminal LSI ADM-3A . Emulation of famous terminal from Lear Siegler, Inc. - ADM-3A. It had a nick name ‘Dumb Terminal’. In the time (1974), due to its cheapness and speed capabilities required in that time, it became de facto standard in the industry. Often it was used in connection with MITS Altair 8800 computer, so the decision of which terminal to emulate was clear. . Maintenance manual can be downloaded at this link, operator’s manual here. . Display . Terminal could display 128 ASCII characters (upper-case and lower-case letters, punctuation and numbers). Original ADM-3 could display only 64 (only capital-letters and some other). For saving very expensive RAM the terminal offered size 12 rows x 80 columns, with optional extension to 24 rows x 80 columns. The size used in the emulator is hardcoded to 80 columns x 24 rows. . Besides, the emulator uses custom font colored green, with anti-aliasing support and double-buffering. . Keyboard . Terminal could generate always 128 ASCII characters (upper-case, lower-case, punctuation and numbers). Besides, it could generate special control characters which had effect on the current cursor position and were not sent to CPU. . Emulated device allows to generate almost anything what your host keyboard can give. It is only up to font which characters it can display. The font cannot display any special non-US characters used in various languages. Just classic ASCII. . Besides, the terminal can capture control codes (holding CTRL plus some key), and special control codes (ESC + &#39;=&#39; + [X] + [Y], sets new cursor position, where [X] is a key translated to X position and [Y] a key translated into Y position of a cursor). The following subsection lists all possible control and special control key combinations. . Control codes . The following table shows control codes (CTRL plus some key combinations). The table can be found in original manuals. The emulator is following it. . Code ASCII mnemonic Function in ADM-3A . CTRL+@ | NUL |   | . CTRL+A | SOH |   | . CTRL+B | STX |   | . CTRL+C | ETX |   | . CTRL+D | EOT |   | . CTRL+E | ENQ | Initiates ID message with automatic “Answer Back” option. | . CTRL+F | ACK |   | . CTRL+G | BEL | Sounds audible beep in ADM-3A (not in emulator yet :( ) | . CTRL+H | BS | Backspace | . CTRL+I | HT |   | . CTRL+J | LF | Line feed | . CTRL+K | VT | Upline | . CTRL+L | FF | Forward space | . CTRL+M | CR | Return | . CTRL+N | SO | Unlock keyboard | . CTRL+O | SI | Lock keyboard | . CTRL+P | OLE |   | . CTRL+Q | DCI |   | . CTRL+R | DC2 |   | . CTRL+S | DC3 |   | . CTRL+T | DC4 |   | . CTRL+U | NAK |   | . CTRL+V | SYN |   | . CTRL+W | ETB |   | . CTRL+X | CAN |   | . CTRL+Y | EM |   | . CTRL+Z | SUB | Clear screen | . CTRL+[ | ESC | Initiate load cursor | . CTRL+x | FS |   | . CTRL+] | GS |   | . CTRL+^ | RS | Home cursor | . Absolute cursor position from the keyboard . Terminal allows to set the absolute cursor position, when in “Cursor control Mode”. ADM-3A emulator does not have such mode, but ESC + &#39;=&#39; + [X] + [Y] combination allows to set the cursor position. By pressing ESC key, it initiates the “load cursor” operation. If the user then presses = key, the terminal expects another two keystrokes, and translates them into [X] and [Y] coordinates for the new position of the cursor. The following table shows the key-to-coordinate translation table. . Key Number . &#39; &#39; | 0 | . ! | 1 | . &quot; | 2 | . # | 3 | . $ | 4 | . % | 5 | . &amp; | 6 | . &#39; | 7 | . ( | 8 | . ) | 9 | . * | 10 | . + | 11 | . , | 12 | . - | 13 | . . | 14 | . / | 15 | . 0 | 16 | . 1 | 17 | . 2 | 18 | . 3 | 19 | . 4 | 20 | . 5 | 21 | . 6 | 22 | . 7 | 23 | . 8 | 24 | . 9 | 25 | . : | 26 | . ; | 27 | . &lt; | 28 | . = | 29 | . &gt; | 30 | . ? | 31 | . @ | 32 | . A | 33 | . B | 34 | . C | 35 | . D | 36 | . E | 37 | . F | 38 | . G | 39 | . H | 40 | . I | 41 | . J | 42 | . K | 43 | . L | 44 | . M | 45 | . N | 46 | . O | 47 | . P | 48 | . Q | 49 | . R | 50 | . S | 51 | . T | 52 | . U | 53 | . V | 54 | . W | 55 | . X | 56 | . Y | 57 | . Z | 58 | . [ | 59 | . | 60 | . ] | 61 | . ^ | 62 | . _ | 63 | . | 64 | . a | 65 | . b | 66 | . c | 67 | . d | 68 | . e | 69 | . f | 70 | . g | 71 | . h | 72 | . i | 73 | . j | 74 | . k | 75 | . l | 76 | . m | 77 | . n | 78 | . o | 79 | . ADM-3A Settings . It is possible to configure the terminal either from GUI or manually modifying configuration settings. Modification of settings requires restarting emuStudio. . The “settings” window is shown in the following image: . . A: File for reading input (when redirected) | B: File for writing output (when redirected) | C: In automatic mode, how long the terminal should wait until it reads next input character from the file (in milliseconds) | D: Whether every keystroke will also cause to display it. Programs don’t always “echo” the characters back to the screen. | E: Whether terminal GUI should be always-on-top of other windows | F: Whether the display should use anti-aliasing. | G: Clears the screen. | H: Rolls the screen down by 1 line | I: If checked, then by pressing OK the settings will be saved to the configuration file. If not, they will be not saved. In any case, the effect of the settings will be visible immediately. | . Terminal behaves differently when emuStudio is run in automatic (or “no GUI”) mode. In that moment, input is redirected to be read from a file, and also output is redirected to be written to another file. File names are configurable in the computer config file. Using redirection in GUI mode is currently not possible. . Configuration file . The following table shows all the possible settings of ADM-3A plugin: . Name Default value Valid values Description . inputFileName | adm3A-terminal.in | Path to existing file | File for reading input (when redirected) | . outputFileName | adm3A-terminal.out | Path to existing file | File for writing output (when redirected) | . inputReadDelay | 0 | &gt; 0 | How long the terminal should wait until it reads next input character from the file (in milliseconds) | . antiAliasing | false | true / false | Whether the display should use anti-aliasing. | . halfDuplex | false | true / false | Whether every keystroke will also cause to display it. | .",
    "url": "/documentation/user/altair8800/adm3a-terminal",
    "relUrl": "/altair8800/adm3a-terminal"
  }
  ,"6": {
    "title": "Assembler as-8080",
    "content": "Assembler “as-8080” . emuStudio version of assembler for Intel 8080 CPU is very similar to Intel assembler, but has some little differences. Features include: . macro support (unlimited nesting) | include files support | data definition | relative addressing using labels | literals and expressions in various radixes (bin, dec, hex, oct) | compiler output is in Intel HEX format | . The features are very similar to those in “as-z80” assembler. . Running from command line . The assembler is provided as part of emuStudio, and usually it is run from GUI. But it can be run also from the command line, as follows: . on Linux: &gt; bin/as-8080 [--output output_file.hex] [source_file.asm] . | on Windows: &gt; bin as-8080.bat [--output output_file.hex] [source_file.asm] . | . All command line options include: . Options: --output, -o file: name of the output file --version, -v : print version --help, -h : this help . Lexical symbols . The assembler does not differentiate between upper and lower case (it is case-insensitive). The token/symbol types are as follows: . Type Description . Keywords | instruction names; preprocessor directives (org, equ, set, macro, endm, include, if, endif); data definitions (db, dw, ds); CPU registers | . Identifiers | ([a-zA-Z_ ?@])[a-zA-Z_ ?@0-9]* except keywords | . Labels |   | . Constants | strings or integers | . Operators | +, -, *, /, =, mod, and, or, not, xor, shl, shr | . Comments | semi-colon (;) with text after it until the end of the line | . Constants . Numeric constants can be only integers, encoded with one of several number radixes. The possible formats are written using regexes: . binary numbers: [0-1]+[bB] | decimal numbers: [0-9]+[dD]? | octal numbers: [0-7]+[oOqQ] | hexadecimal numbers: [0-9][0-9a-fA-F]*[hH] | . Characters or strings must be enclosed in single-quotes, e,g,: MVI E, &#39;*&#39; . Identifiers . Identifiers must fit to the following regex: ([a-zA-Z_ ?@])[a-zA-Z_ ?@0-9]*. It means, that it has to start with a letter a-z (or A-Z) or the at-sign (@). Then, it can be followed by letters, at-sign, or numbers. . However, they must not equal to any keyword. . Instructions syntax . The program is basically a sequence of instructions. The instructions are separated by a new line. The instruction have optional and mandatory parts, e.g.: . LABEL: CODE OPERANDS ; COMMENT . Syntax part Required Notes . LABEL | Optional | Identifier of the memory position, followed by a colon (:). | .   | It can be used as forward or backward reference in instructions |   | .   | which expect memory address (or 16 bit number). |   | . CODE | Mandatory | Instruction name. | . OPERANDS | It depends | If applicable, a comma-separated (,) operands of the instruction. | . COMMENT | Optional | semi-colonm (;) followed by any text until the end of the line. | . Fields CODE and OPERANDS must be separated by at least one space. For example: . HERE: MVI C, 0 ; Put 0 into C register DB 3Ah ; Data constant of size 1 byte LOOP: JMP LOOP ; Infinite loop . Labels are optional. Instructions and pseudo-instructions and register names are reserved for assembler and cannot be used as labels. Also, there cannot be more definitions of the same label. . Operands must be separated with comma (,). There exist several operand types, which represent so-called “address modes”. Allowed address modes depend on the instruction. The possibilities are: . Implicit addressing: instructions do not have operands. They are implicit. | Register addressing: operands are registers. 8-bit general-purpose register names are: A, B, C, D, E, H, L. Stack pointer is defined as SP, and program status word (used by push / pop instructions) as PSW. When register pairs should be used in 16-bit instructions, the same register names are used. For example, DCX D which decrements pair DE. | Register indirect addressing: for the memory value specified by address in HL pair is used special register called M, for example: MOV A, M. | Immediate addressing: operand is the 8-bit constant. It can be also one character, enclosed in single-quotes. | Direct addressing: operand is either 8-bit or 16-bit constant, which is understood as the memory location (address). For example: SHLD 1234h. | Modified page zero: operand is 3-bit value (0-7). It represents a “index”, which is multiplied by constant 8, resulting in final memory address. Used in RST instruction. | . Immediate data or addresses can be defined in various ways: . Integer constant | Integer constant as a result of evaluation of some expression (e.g. 2 SHL 4, or 2 + 2) | Current address - denoted by special variable $. For example, instruction JMP $+6 denotes a jump by 6-bytes further from the current address. | Character constants, enclosed in single-quotes (e.g. MVI A, &#39;*&#39;) | Labels. For example: JMP THERE will jump to the label THERE. | Variables. For example: | . VALUE SET &#39;A&#39; MVI A, VALUE . Expressions . An expression is a combination of the data constants and operators. Expressions are evaluated in compile-time. Given any two expressions, they must not be defined in circular way. Expressions can be used anywhere a constant is expected. . There exist several operators, such as: . Expression Notes . + | Addition. Example: DB 2 + 2; evaluates to DB 4 | . - | Subtraction. Example: DW $ - 2; evaluates to the current compilation address minus 2. | . * | Multiply. | . / | Integer division. | . = | Comparison for equality. Returns 1 if operands equal, 0 otherwise. Example: DB 2 = 2; evaluates to DB 1. | . mod | Remainder after integer division. Example DB 4 mod 3; evaluates to DB 1. | . and | Logical and. | . or | Logical or. | . xor | Logical xor. | . not | Logical not. | . shl | Shift left by 1 bit. Example: DB 1 SHL 3; evaluates to DB 8 | . shr | Shift right by 1 bit. | . Operator priorities are as follows: . Priority Operator Type . 1 | ( ) | Unary | . 2 | *, /, mod, shl, shr | Binary | . 3 | +, - | Unary and binary | . 4 | = | Binary | . 5 | not | Unary | . 6 | and | Binary | . 7 | or, xor | Binary | . All operators work with its arguments as if they were 16-bit. Their results are always 16-bit numbers. If there is expected 8-bit number, the result is automatically “cut” using operation result AND 0FFh. This may be unwanted behavior and might lead to bugs, but it is often useful so the programmer must ensure the correctness. . Defining data . Data can be defined using special pseudo-instructions. These accept constants. Negative integers are using two’s complement. The following table describes all possible data definition pseudo-instructions: . Expression Notes . DB [expression] | Define byte. The [expression] must be of size 1 byte. Using this pseudo-instruction, a string can be defined, enclosed in single quotes. For example: DB &#39;Hello, world!&#39; is equal to DB &#39;H&#39;, DB &#39;e&#39;, etc. on separate lines. | . DW [expression] | Define word. The [expression] must be max. of size 2 bytes. Data are stored using little endian. | . DS [expression] | Define storage. The [expression] represents number of bytes which should be “reserved”. The reserved space will not be modified in memory. It is similar to “skipping” particular number of bytes. | . Examples . HERE: DB 0A3H ; A3 W0RD1: DB 5*2, 2FH-0AH ; 0A25 W0RD2: DB 5ABCH SHR 8 ; 5A STR: DB &#39;STRINGSpl&#39; ; 535452494E472031 MINUS: DB -03H ; FD ADD1: dw COMP ; 1C3B (assume COMP is 3B1CH) ADD2: dw FILL ; B43E (assume FILL is 3EB4H) ADD3: dw 3C01H, 3CAEH ; 013CAE3C . Including other source files . It is both useful and good practice to write modular programs. According to the DRY principle the repetitive parts of the program should be refactored out into functions or modules. Functionally similar groups of these functions or modules can be put into a library, reusable in other programs. . The pseudo-instruction include exists for the purpose of including already written source code into the current program. The pseudo-instruction is defined as follows: . INCLUDE &#39;[filename]&#39; . where [filename] is a relative or absolute path to the file which will be included, enclosed in single-quotes. The file can include other files, but there must not be defined circular includes (compiler will complain). . The current compilation address (denoted by $ variable) after the include will be updated about the binary size of the included file. . The namespace of the current program and the included file is shared. It means that labels or variables with the same name in the current program and the included file are prohibited. Include file “sees” everything in the current program as it was its part. . Example . Let a.asm contains: . mvi b, 80h . Let b.asm contains: . include &#39;a.asm&#39; . Then compiling b.asm will result in: . 06 80 ; mvi b, 80h . Origin address . Syntax: ORG [expression] . Sets the value to the $ variable. It means that from now on, the following instructions will be placed at the address given by the [expression]. Effectively, it is the same as using DS pseudo-instruction, but instead of defining number of skipped bytes, we define concrete memory location (address). . The following two code snippets are equal: . Address Block 1 Block 2 Opcode . 2C00 | MOV A,C | MOV A,C | 79 | . 2C01 | JMP NEXT | JMP NEXT | C3 10 2C | . 2C04 | DS 12 | ORG $+12 |   | . 2C10 | NEXT: XRA A | NEXT: XRA A | AF | . Equate . Syntax: [identifier] EQU [expression] . Define a constant. The [identifier] is a mandatory name of the constant. . [expression] is the 16-bit expression. . The pseudo-instruction will define a constant - assign a name to given expression. The name of the constant then can be used anywhere where the constant is expected and the compiler will replace it with the expression. . It is not possible to redefine a constant. . Variables . Syntax: [identifier] SET [expression] . Define or re-define a variable. The [identifier] is a mandatory name of the constant. . [expression] is the 16-bit expression. . The pseudo-instruction will define a variable - assign a name to given expression. Then, the name of the variable can be used anywhere where the constant is expected. . It is possible to redefine a variable, which effectively means to reassign new expression to the same name and forgetting the old one. The reassignment is aware of locality, i.e. before it the old value will be used, after it the new value will be used. . Conditional assembly . Syntax: . if [expression] i n s t r u c t i o n s endif . At first, the compiler evaluates the [expression]. If the result is 0, instructions between if and endif will be ignored. Otherwise they will be included in the source code. . Defining and using macros . Syntax: . [identifier] macro [operands] i n s t r u c t i o n s endm . The [identifier] is a mandatory name of the macro. . The [operands] part is a list of identifiers, separated by commas (,). Inside the macro, operands act as constants. If the macro does not use any operands, this part can be omitted. . The namespace of the operand identifiers is macro-local, ie. the operand names will not be visible outside the macro. Also, the operand names can hide variables, labels or constants defined in the outer scope. . The macros can be understood as “templates” which will be expanded in the place where they are “called”. The call syntax is as follows: . [macro name] [arguments] . where [macro name] is the macro name as defined above. Then, [arguments] are comma-separated expressions, in the order as the original operands are defined. The number of arguments must be the same as number of macro operands. . The macro can be defined anywhere in the program, even in some included file. Also, it does not matter in which place is called - above or below the macro definition. . Examples . SHV MACRO LOOP: RRC ; Right rotate with carry ANI 7FH ; Clear MSB of accumulator DCR D ; Decrement rotation counter - register D JNZ LOOP ; Jump to next rotation ENDM . The macro SHV can be used as follows: . LDA TEMP MVI D,3 ; 3 rotations SHV STA TEMP . Or another definition: . SHV MACRO AMT MVI D,AMT ; Number of rotations LOOP: RRC ANI 7FH DCR D JNZ LOOP ENDM . And usage: . LDA TEMP SHV 5 . Which has the same effect as the previous example. .",
    "url": "/documentation/user/altair8800/as-8080",
    "relUrl": "/altair8800/as-8080"
  }
  ,"7": {
    "title": "Assembler "as-ssem"",
    "content": "Assembler “as-ssem” . Assembler “as-ssem” is a simple language which compiles SSEM instructions into binary output and SSEM memory. Source code has .ssem file extension, and binary form has .bin file extension. . The instructions table follows (modified from Wikipedia): . Binary code Mnemonic Action Operation . 000 | JMP S | S(L) -&gt; CI | Jump to the instruction at the address obtained from the specified memory address S(L) (absolute unconditional jump) | . 100 | JRP / JPR / JMR S | CI + S(L) -&gt; CI | Jump to the instruction at the program counter (CI) plus the relative value obtained from the specified memory address S(L) (relative unconditional jump) | . 010 | LDN S | -S(L) -&gt; A | Take the number from the specified memory address S(L), negate it, and load it into the accumulator | . 110 | STO S | A -&gt; S(L) | Store the number in the accumulator to the specified memory address S(L) | . 001 or 101 | SUB S | A - S(L) -&gt; A | Subtract the number at the specified memory address S(L) from the value in accumulator, and store the result in the accumulator | . 011 | CMP / SKN | if A&lt;0 then CI+1-&gt;CI | Skip next instruction if the accumulator contains a negative value | . 111 | STP / HLT | Stop |   | . The instructions are stored in a memory, which had 32 cells. Each cell was 32 bits long, and each instruction fit into exactly one cell. So each instruction has 32 bits. The bit representation was reversed, so the most and the least significant bits were put on opposite sides. For example, value 3, in common personal computers represented as 011, was in SSEM represented as 110. . The instruction format is as follows: . Bit: | 00 | 01 | 02 | 03 | 04 | … | 13 | 14 | 15 | … | 31 | . Use: | L | L | L | L | L | 0 | I | I | I | 0 | 0 | . Value: | 2^0 |   |   |   |   |   |   |   |   |   | 2^31 | . where bits LLLLL denote a “line”, which is basically the memory address - index of a memory cell. It can be understood as instruction operand. Bits III specify the instruction opcode (3 bits are enough for 7 instructions). . Language syntax . New-lines . New-line character (LF, CR, or CRLF) are delimiters of instructions, and the last character of the program. Successive empty new-line characters will be ignored. . Instructions . Assembler will support all forms of instructions. All instructions must start with a line number. For example: . 01 LDN 20 . Literals / constants . Raw number constants can be defined in separate lines using special preprocessor keywords. The first one is NUM xxx, where xxx is a number in either decimal or hexadecimal form. Hexadecimal format must start with prefix 0x. For example: . 00 NUM 0x20 01 NUM 1207943145 . Another keyword is BNUM xxx, where xxx can be only a binary number. For example: . 01 BNUM 10011011111000101111110000111111 . It means that the number will be stored untouched to the memory in the format as it appears in the binary form. . There exists also a third keyword, BINS xxx, with the exact meaning as BNUM. . For all constants, the following rules hold. Only integral constants are supported, and the allowed range is from 0 - 31 (maximum is 2^5). . Comments . Only one-line comments will be supported, but of various forms. Generally, comment will be everything starting with some prefix until the end of the line. Comment prefixes are: . Double-slash (//) | Semi-colon (;) | Double-dash (--) | . Example . For example, simple 5+3 addition can be implemented as follows: . 0 LDN 7 // load negative X into the accumulator 1 SUB 8 // subtract Y from the value in the accumulator 2 STO 9 // store the sum at address 7 3 LDN 9 // A = -(-Sum) 4 STO 9 // store sum 5 HLT 7 NUM 3 // X 8 NUM 5 // Y 9 // here will be the result . The accumulator should now contain value 8, as well as memory cell at index 9. .",
    "url": "/documentation/user/ssem/as-ssem",
    "relUrl": "/ssem/as-ssem"
  }
  ,"8": {
    "title": "Assembler as-z80",
    "content": "Assembler “as-z80” . The assembler syntax is inspired by as-8080 assembler, and by instruction set described here. The assembler supports the following features: . macro support (unlimited nesting) | include other files support | conditional assembly | data definition | relative addressing using labels | literals and expressions in various radixes (bin, dec, hex, oct) | output is in Intel HEX format | . Running from command line . The assembler is provided as part of emuStudio, and usually it is run from GUI. But it can be run also from the command line, as follows: . on Linux: &gt; bin/as-z80 [--output output_file.hex] [source_file.asm] . | on Windows: &gt; bin as-z80.bat [--output output_file.hex] [source_file.asm] . | . All command line options include: . Options: --output, -o file: name of the output file --version, -v : print version --help, -h : this help . Lexical symbols . The assembler does not differentiate between upper and lower case (it is case-insensitive). The token/symbol types are as follows: . Type Description . Keywords | instruction names; preprocessor directives (org, equ, var, macro, endm, include, if, endif); data definitions (db, dw, ds); CPU registers | . Identifiers | ([a-zA-Z_ ?@])[a-zA-Z_ ?@0-9]* except keywords | . Labels |   | . Constants | strings or integers | . Operators | +, -, *, /, =, %, &amp;, |, !, ~, &lt;&lt;, &gt;&gt;, &gt;, &lt;, &gt;=, &lt;= | . Comments | semi-colon (;) with text after it until the end of the line | . Constants . Numeric constants can be only integers, encoded with one of several number radixes. The possible formats are written using regexes: . binary numbers: [0-1]+[bB] | decimal numbers: [0-9]+[dD]? | octal numbers: [0-7]+[oOqQ] | hexadecimal numbers: [0-9][0-9a-fA-F]*[hH] | . Characters or strings must be enclosed in double-quotes, e,g,: LD E, &quot;*&quot; . Identifiers . Identifiers must fit to the following regex: ([a-zA-Z_ ?@])[a-zA-Z_ ?@0-9]*. It means, that it has to start with a letter a-z (or A-Z) or the at-sign (@). Then, it can be followed by letters, at-sign, or numbers. . However, they must not equal to any keyword. . Instructions syntax . The program is basically a sequence of instructions. The instructions are separated by a new line. The instruction have optional and mandatory parts, e.g.: . LABEL: CODE OPERANDS ; COMMENT . Part Required Notes . LABEL | Optional | Identifier of the memory position, followed by a colon (:). It can be used as forward or backward reference in instructions which expect memory address (or 16 bit number). | . CODE | Mandatory | Instruction name. | . OPERANDS | It depends | If applicable, a comma-separated (,) operands of the instruction. | . COMMENT | Optional | semi-colonm (;) followed by any text until the end of the line. | . Fields CODE and OPERANDS must be separated by at least one space. For example: . HERE: LD C, 0 ; Put 0 into C register DB 3Ah ; Data constant of size 1 byte LOOP: JP LOOP ; Infinite loop . Labels are optional. Instructions and pseudo-instructions and register names are reserved for assembler and cannot be used as labels. Also, there cannot be more definitions of the same label. . Operands must be separated with comma (,). There exist several operand types, which represent so-called “address modes”. Allowed address modes depend on the instruction. The possibilities are: . Implicit addressing: instructions do not have operands. They are implicit. | Register addressing: operands are registers. 8-bit general-purpose register names are: A, B, C, D, E, H, L. Register pairs have names: BC, DE, HL. Stack pointer is defined as SP, and program status word (used by push / pop instructions) as AF. Another 16-bit registers are defined as IX, IY. | Register indirect addressing: for example, loading a memory value at address in HL pair: LD A, (HL). | Immediate addressing: operand is the 8-bit constant. It can be also one character, enclosed in double-quotes. | Direct addressing: operand is either 8-bit or 16-bit constant, which is understood as the memory location (address). For example: LD (1234h), HL. | . Immediate data or addresses can be defined in various ways: . Integer constant | Integer constant as a result of evaluation of some expression (e.g. 2 &lt;&lt; 4, or 2 + 2) | Current address - denoted by special variable $. For example, instruction JP $+6 denotes a jump by 6-bytes further from the current address. | Character constants, enclosed in double-quotes (e.g. LD A, &quot;*&quot;) | Labels. For example: JP THERE will jump to the label THERE. | Variables. For example: | . VALUE VAR &#39;A&#39; LD A, VALUE . Expressions . An expression is a combination of the data constants and operators. Expressions are evaluated in compile-time. Given any two expressions, they must not be defined in circular way. Expressions can be used anywhere a constant is expected. . There exist several operators, such as: . Expression Notes . + | Addition. Example: DB 2 + 2; evaluates to DB 4 | . - | Subtraction. Example: DW $ - 2; evaluates to the current compilation address minus 2. | . * | Multiply. | . / | Integer division. | . = | Comparison for equality. Returns 1 if operands equal, 0 otherwise. Example: DB 2 = 2; evaluates to DB 1. | . % | Remainder after integer division. Example DB 4 mod 3; evaluates to DB 1. | . &amp; | Logical and. | . | | Logical or. | . ~ | Logical xor. | . ! | Logical not. | . &lt;&lt; | Shift left by 1 bit. Example: DB 1 SHL 3; evaluates to DB 8 | . &gt;&gt; | Shift right by 1 bit. | . &gt; | Greater than. Example: DB 3 &gt; 2; evaluates to DB 1 | . &lt; | Less than. | . &gt;= | Greater or equal than. | . &lt;= | Less or equal than. | . Operator priorities are as follows: . Priority Operator Type . 1 | ( ) | Unary | . 2 | *, /, %, &lt;&lt;, &gt;&gt;, &gt;, &lt;, &gt;=, &lt;= | Binary | . 3 | +, - | Unary and binary | . 4 | = | Binary | . 5 | ! | Unary | . 6 | &amp; | Binary | . 7 | |, ~ | Binary | . All operators work with its arguments as if they were 16-bit. Their results are always 16-bit numbers. If there is expected 8-bit number, the result is automatically “cut” using operation result AND 0FFh. This may be unwanted behavior and might lead to bugs, but it is often useful so the programmer must ensure the correctness. . Defining data . Data can be defined using special pseudo-instructions. These accept constants. Negative integers are using two’s complement. . The following table describes all possible data definition pseudo-instructions: . Expression Notes . DB [expression] | Define byte. The [expression] must be of size 1 byte. Using this pseudo-instruction, a string can be defined, enclosed in single quotes. For example: DB &#39;Hello, world!&#39; is equal to DB &#39;H&#39;, DB &#39;e&#39;, etc. on separate lines. | . DW [expression] | Define word. The [expression] must be max. of size 2 bytes. Data are stored using little endian. | . DS [expression] | Define storage. The [expression] represents number of bytes which should be “reserved”. The reserved space will not be modified in memory. It is similar to “skipping” particular number of bytes. | . Examples . HERE: DB 0A3H ; A3 W0RD1: DB 5*2, 2FH-0AH ; 0A25 W0RD2: DB 5ABCH SHR 8 ; 5A STR: DB &quot;STRINGSpl&quot; ; 535452494E472031 MINUS: DB -03H ; FD ADD1: dw COMP ; 1C3B (assume COMP is 3B1CH) ADD2: dw FILL ; B43E (assume FILL is 3EB4H) ADD3: dw 3C01H, 3CAEH ; 013CAE3C . Including other source files . It is both useful and good practice to write modular programs. According to the DRY principle the repetitive parts of the program should be refactored out into functions or modules. Functionally similar groups of these functions or modules can be put into a library, reusable in other programs. . The pseudo-instruction include exists for the purpose of including already written source code into the current program. The pseudo-instruction is defined as follows: . INCLUDE &quot;[filename]&quot; . where [filename] is a relative or absolute path to the file which will be included, enclosed in double-quotes. The file can include other files, but there must not be defined circular includes (compiler will complain). . The current compilation address (denoted by $ variable) after the include will be updated about the binary size of the included file. . The namespace of the current program and the included file is shared. It means that labels or variables with the same name in the current program and the included file are prohibited. Include file “sees” everything in the current program as it was its part. . Example . Let a.asm contains: . ld b, 80h . Let b.asm contains: . include &quot;a.asm&quot; . Then compiling b.asm will result in: . 06 80 ; ld b, 80h . Origin address . Syntax: ORG [expression] . Sets the value to the $ variable. It means that from now on, the following instructions will be placed at the address given by the [expression]. Effectively, it is the same as using DS pseudo-instruction, but instead of defining number of skipped bytes, we define concrete memory location (address). . The following two code snippets are equal: . Address Block 1 Block 2 Opcode . 2C00 | LD A,C | LD A,C | 79 | . 2C01 | JP NEXT | JP NEXT | C3 10 2C | . 2C04 | DS 12 | ORG $+12 |   | . 2C10 | NEXT: XOR A | NEXT: XOR A | AF | . Equate . Syntax: [identifier] EQU [expression] . Define a constant. The [identifier] is a mandatory name of the constant. . [expression] is the 16-bit expression. . The pseudo-instruction will define a constant - assign a name to given expression. The name of the constant then can be used anywhere where the constant is expected and the compiler will replace it with the expression. . It is not possible to redefine a constant. . Variables . Syntax: [identifier] VAR [expression] . Define or re-define a variable. The [identifier] is a mandatory name of the constant. . [expression] is the 16-bit expression. . The pseudo-instruction will define a variable - assign a name to given expression. Then, the name of the variable can be used anywhere where the constant is expected. . It is possible to redefine a variable, which effectively means to reassign new expression to the same name and forgetting the old one. The reassignment is aware of locality, i.e. before it the old value will be used, after it the new value will be used. . Conditional assembly . Syntax: . if [expression] i n s t r u c t i o n s endif . At first, the compiler evaluates the [expression]. If the result is 0, instructions between if and endif will be ignored. Otherwise they will be included in the source code. . Defining and using macros . Syntax: . [identifier] macro [operands] i n s t r u c t i o n s endm . The [identifier] is a mandatory name of the macro. . The [operands] part is a list of identifiers, separated by commas (,). Inside the macro, operands act as constants. If the macro does not use any operands, this part can be omitted. . The namespace of the operand identifiers is macro-local, ie. the operand names will not be visible outside the macro. Also, the operand names can hide variables, labels or constants defined in the outer scope. . The macros can be understood as “templates” which will be expanded in the place where they are “called”. The call syntax is as follows: . [macro name] [arguments] . where [macro name] is the macro name as defined above. Then, [arguments] are comma-separated expressions, in the order as the original operands are defined. The number of arguments must be the same as number of macro operands. . The macro can be defined anywhere in the program, even in some included file. Also, it does not matter in which place is called - above or below the macro definition. . Examples . SHV MACRO LOOP: RRCA ; Right rotate with carry AND 7FH ; Clear MSB of accumulator DEC D ; Decrement rotation counter - register D JP NZ, LOOP ; Jump to next rotation ENDM . The macro SHV can be used as follows: . LD A, (TEMP) LD D,3 ; 3 rotations SHV LD (TEMP), A . Or another definition: . SHV MACRO AMT LD D,AMT ; Number of rotations LOOP: RRCA AND 7FH DEC D JP NZ, LOOP ENDM . And usage: . LD A, (TEMP) SHV 5 LD (TEMP), A . Which has the same effect as the previous example. .",
    "url": "/documentation/user/altair8800/as-z80",
    "relUrl": "/altair8800/as-z80"
  }
  ,"9": {
    "title": "Automation",
    "content": "Automation . Automation, or automatic emulation, is a feature in which user can run the emulation in a non-interactive mode, i.e. without any interruption. The emulation is being run from the command line and user just watches until it finishes. At the end, she/he collects logs and/or output files generated by plugins. Outputs then can be analyzed manually or by some custom script. . The feature has to be supported by individual plugins, so they will respect the settings from command line. Please refer to the documentation of individual plugins for these details. . Automatic emulation requires a source code to be present. The source code is called an “input”. Example of running automatic emulation is as follows: . ./emuStudio --auto --nogui --config config/MITSAltair8800.toml --input example.asm --waitmax 5000 . Command line argument --auto turns on the automatic emulation. If no other argument is provided, emuStudio will start as usual by asking to open a virtual computer. But after this step it will run the emulation with the settings as they appear in the computer configuration file (no source code compilation is performed). . The --nogui argument tells to emuStudio that we don’t want to use GUI (graphical user interface) at all. In that case, we must provide a virtual computer in the command line (using --config argument). . Argument --waitmax 5000 tells emuStudio that the emulation should not last for more than 5 seconds. If it didn’t finish up to this deadline, it is forcibly stopped and marked as failed. . Analyzing the results . An important part of the analysis of result of the automatic emulation is the log saying what happened. By default, each run of automatic emulation creates (overwrites) a log file called automation.log, located in logs/ directory. . The log file is in plaintext format and contains messages which appeared in log during the emulation. The log file format can be customized, see “Logging” chapter for more details. .",
    "url": "/documentation/user/application/automation",
    "relUrl": "/application/automation"
  }
  ,"10": {
    "title": "Automation",
    "content": "Automation . BrainDuck is one of computers which allows automatic emulation. It means that it is possible to run the emulation from command line, while all necessary input and output is redirected from/to files. If user interaction is necessary, it is possible to run an interactive automation. . Suppose the BrainDuck computer is represented by abstract schema shown in brainduck-intro document. In that case, BrainDuck terminal is the only device dealing with I/O. If the emulation was executed in automatic non-interactive mode, it will recognize it and the input/output will be redirected from/to files. . Input file is called brainduck-terminal.in and must be placed in the directory from which emuStudio was executed. If the file does not exist, emuStudio will not run. . Output file is called brainduck-terminal.out and it will be created automatically, or appended when it exists in the location from which emuStudio was executed. . NOTE: Take care about end-of-line characters. Most of brainfuck programs count with Unix-like EOLs, i.e. characters with ASCII code 10. plugin brainduck-terminal interprets ENTER key in the interactive mode as Unix-like EOL. In the non-interactive mode, EOL may be of any-like type. . Command line for starting non-interactive automatic emulation: . ./emuStudio --auto --config config/BrainDuck.toml --input examples/brainc-brainduck/mandelbrot.b . computer configuration config/BrainDuck.toml will be loaded | input file for compiler is one of the examples | (--auto) automatic emulation mode will be performed | .",
    "url": "/documentation/user/brainduck/automation",
    "relUrl": "/brainduck/automation"
  }
  ,"11": {
    "title": "Automation",
    "content": "Automation . RAM is one of computers which supports automatic emulation. In general, automatic emulation can be interactive, or not interactive. In case of the RAM emulator, only non-interactive emulation is useful. It is because during emulation it is not possible to interact (e.g. pass new input to the input tape) in any way. . Changes to any abstract tapes are written to the corresponding output file (see abstract tape documentation for more information). . Command line for starting non-interactive automatic emulation: . ./emuStudio --config config/RAM.toml --input examples/ramc-ram/factorial.ram --auto --nogui . configuration config/RAM.toml will be loaded | input file for compiler is one of the examples | (--auto) automatic emulation mode will be performed | (--nogui) non-interactive version will be set | . After the run, the following output on the stdout can be expected: . [INFO] Loading virtual computer: RAM [INFO] All plugins were loaded successfully. [INFO] Being verbose. Writing to file:registers_(storage_tape).out [INFO] Being verbose. Writing to file:input_tape.out [INFO] Being verbose. Writing to file:output_tape.out [INFO] Starting emulation automatization... [INFO] Compiler: RAM Compiler [INFO] CPU: Random Access Machine (RAM) [INFO] Memory: RAM Program Tape [INFO] Memory size: 0 [INFO] Device #00: Abstract tape [INFO] Device #01: Abstract tape [INFO] Device #02: Abstract tape [INFO] Compiling input file: examples/ramc-ram/factorial.ram [INFO] Compiler started working. [INFO] [Info (000)] RAM Compiler, version 0.39-SNAPSHOT [INFO] [Info (000)] Compile was successful. [INFO] [Info (000)] Compiled file was loaded into operating memory. [INFO] [Info (000)] Compilation was saved to the file: factorial.ro [INFO] Compiler finished successfully. [INFO] Program start address: 0000h [INFO] Resetting CPU... [INFO] Running emulation... [INFO] Normal stop [INFO] Instruction position = 0011h [INFO] Emulation completed . Then, in the current working directory, there will be created three new files: . input_tape.out | registers_(storage_tape).out | output_tape.out | . The format of the files is described in abstract tape documentation. .",
    "url": "/documentation/user/ram/automation",
    "relUrl": "/ram/automation"
  }
  ,"12": {
    "title": "Compiler "brainc-brainduck"",
    "content": "Compiler “brainc-brainduck” . BrainDuck compiler is used as a part of BrainDuck computer, which acts as a translator of brainfuck “human-readable” language into binary form, used by BrainDuck CPU. Those instructions and their binary codes have no relation with brainfuck itself, therefore the computer is not called brainfuck computer, because it is not brainfuck. But it does not mean you cannot write and run brainfuck programs in it :) . At first, each compiler, including BrainDuck compiler, provides lexical analyzer for help with tokenize of the source code, used in syntax highlighting. Secondly, the compile compiles the source code into other (usually binary) form which is then understood by CPU. . Compilation takes part by user request (clicking on ‘compile’ icon in the main window). After compilation is successful, the compiler usually loads the translated program into operating memory, and saves the translation into a file. So it is with BrainDuck compiler. Files have .hex extension (format is called Intel HEX). . Language Syntax . Language of BrainDuck compiler is almost identical with the original brainfuck. However, brainfuck interpreter is not specified well-enough, so there are open questions how to treat with some special situations, which are described below. . Generally, the language knows eight instructions. They are best described when they are compared with C language equivalent. Brainfuck uses only single data pointer called P, pointing to bounded memory. The boundary is specified in brainduck-mem plugin. . NOTE: BrainDuck architecture conforms to true von-Neumann model, instead of classic Harvard-style interpreters. It means that program memory and data memory are not separated. The data pointer is therefore not initialized to 0 as programmers might expect and potentially there can be written brainfuck programs with self-modifications. . Brainfuck instruction C language equivalent . &gt; | P++ | . &lt; | P-- | . + | ++*P | . - | --*P | . , | *P = getchar() | . . | putchar(*P); | . [ | while (*P) { | . ] | } | . The compiler is supplied with many example programs written in brainfuck. . Additional details . Specification of brainfuck language or interpreter implementation is not complete. There are left some details which might be solved differently in different implementations. In this version of BrainDuck implementation in emuStudio, the details are solved in the fixed way, as described below. . Comments . The compiler takes as a comment everything which is not the brainfuck instruction. From the first occurence of unknown character, everything to the end of the line is treated as comment. Exceptions are whitespaces, tabulators, and newlines. This practically means that it is impossible to write brainfuck program with syntax errors. . In the following example, everything starting with # is treated as comment, up to end of the line. . ++++[-] # Useless program in brainfuck. [-] clears the content of the memory cell. . Cell size . A memory cell has 8-bits (cells are bytes). . Memory size . Memory size is defined in brainduck-mem plugin. In this version of emuStudio, it is 65536 cells. . End-of-line code . EOL is defined in brainduck-terminal plugin. In the current version of emuStudio, it is a Newline character with ASCII code 10. . End-of-file behavior . EOF is defined in brainduck-cpu and brainduck-terminal plugins. In the current version of emuStudio, current cell (where P is pointing at) is changed to value 0. This is not how original brainfuck behaves, which is doing no change to the cell on EOF. .",
    "url": "/documentation/user/brainduck/compiler",
    "relUrl": "/brainduck/compiler"
  }
  ,"13": {
    "title": "CPU "brainduck-cpu"",
    "content": "CPU “brainduck-cpu” . BrainDuck CPU is used as a part of BrainDuck computer, which acts as the interpreter of BrainDuck instructions. Those instructions correspond with brainfuck language. . Program which is going to be executed is read from the operating memory, so the CPU must be connected with memory (brainduck-mem), in order to work properly. . Also, optionally (but commonly) it is should be connected with I/O device (brainduck-terminal), so input/output can be received/send from/to the device. Only one device can be used. . The CPU provides basic user interface in the form of status panel, which is visible in the emulator panel in the main window. . Breakpoints are supported, so as “jump” to specific location, which might be actually dangerous to use. . Status panel . In the following image, you can see the status panel of brainduck-cpu. . . It is split into three parts. Within ‘Internal status’ part, there is shown content of registers IP and P. Register IP does not have counterpart in brainfuck. IP stands for “instruction pointer”. The content is pointing at the next instruction being executed. Register P is commonly known from brainfuck. It is pointer to data. . There is measured execution time, which is reset when user starts the program and stopped when either the program stops or the user stops it. . Loop level shows the depth level of brainfuck loop the program is in. For example, if instruction pointer points into middle of the program [[-]], to the - instruction, loop level is 2. . Running brainfuck programs . It is very important to reset CPU after each source code compilation. The reason is that after compilation register P is not changed. It therefore might point somewhere into compiled code in the memory. If the program was executed, changes in data would corrupt the program itself. . Resetting CPU would move the P register after first occurrence of memory cell with value 0. The value 0 in BrainDuck CPU represents halt instruction, which corresponds to EOF in brainfuck. .",
    "url": "/documentation/user/brainduck/cpu",
    "relUrl": "/brainduck/cpu"
  }
  ,"14": {
    "title": "Memory "brainduck-mem"",
    "content": "Memory “brainduck-mem” . BrainDuck memory is used as a part of BrainDuck computer, which acts as the operating memory, holding both of brainfuck program and data. . BrainDuck CPU reads/writes instructions from/to the memory. Memory updates its cells and notifies debugger in emuStudio about the update. . Memory plugin contains simple graphical window, a GUI, which provides a set of the following features: . paginated view of memory cells, arranged into 16x16 table per page. | cells are displayed in hexadecimal form and can be changed directly by user. | there are hard-coded 256 pages, so the memory size is 256 * (16x16) = 64 kB | . Graphical user interface (GUI) . In the following screenshot, it is possible to see GUI of brainduck-mem. . . A: Shows actually displayed page. Can be edited manually by entering a number and pressing ENTER key | B: By double-clicking on a memory cell, the cell editor is enabled and user can overwrite the content of the cell. Supported number formats are decimal or hexadecimal. Hexadecimal number must begin with 0x prefix. | C: By clicking on button Page down, the page number is increased; button Page up decreases the page number. | .",
    "url": "/documentation/user/brainduck/mem",
    "relUrl": "/brainduck/mem"
  }
  ,"15": {
    "title": "Terminal "brainduck-terminal"",
    "content": "Terminal brainduck-terminal . BrainDuck terminal is used as a part of BrainDuck computer, which acts as an interactive console, or generally interactive input/output provider. It was written with support of GUI, but can be used also in emulation automation, in which case it loads input from the file and output to another file. . Supported features are: . monospace font, unlimited width and height, white background | blinking cursor simulation | keyboard input; binary codes can be entered with special dialog | terminal interprets some special characters like 0x8 (backspace), 0x9 (tab), 0xA (LF), and 0x10 (CR) | . Graphical User Interface (GUI) . In the following image, BrainDuck terminal window is shown: . . It’s easy and simple. BrainDuck CPU as it interprets . (dot) instructions, it sends the output to this terminal and it is displayed on screen. . Input cannot be entered anytime. In brainfuck, input is requested through , instruction. Only when CPU encounters , (comma) instruction, user is asked to enter input. This situation is marked with geen icon in the bottom-left corner: . . Next to the icon, there is a blue “ASC” button. This button can be used for entering binary values as input. Special little dialog will appear asking user to enter space-separated numbers, representing ASCII codes of the input. . NOTE: The terminal do not display characters with ASCII codes less than 32. Only some special characters are interpreted: 0x8 (backspace), 0x9 (tab), 0xA (LF), and 0x10 (CR) .",
    "url": "/documentation/user/brainduck/terminal",
    "relUrl": "/brainduck/terminal"
  }
  ,"16": {
    "title": "MITS Altair8800",
    "content": "MITS Altair8800 . Computer MITS Altair 8800 was named after a planet in one of the first episodes of Star Trek series. Having Intel 8080 CPU inside, with 256 bytes of memory, no display and keyboard is this computer, when comparing to the present era, absolutely ridiculous. His author, Ed Roberts, called the invention “personal computer”, which is now very common term. As Wikipedia states: . The Altair is widely recognized as the spark that ignited the microcomputer revolution. . Wikipedia, Altair 8800 . . Altair 8800 is one of the oldest commercially available computers overall. Ed Roberts (founder and CEO of MITS corporation) was selling these machines by classic mail directly from the factory. . Various enthusiasts understood the power of Altair and started to develop software and hardware for the computer. Those people saw a freedom in Altair - some kind of a release from batch tasks ran on mainframe systems, maintained by elite. The phenomenon of a computer which could be put on the kitchen table allowed to make enormous money by two smart university students. In 1975, Paul Allen and Bill Gates wrote a trimmed version of BASIC programming language, called Altair BASIC, which pushed them directly to foundation of Microsoft corporation. . Basic configuration of MITS Altair 8800 was: . Item Notes . Processor | Intel 8080 or 8080a | . Speed | 2 MHz | . RAM | from 256 bytes to 64 kB | . ROM | optional; usually EPROM Intel 1702 with 256 bytes (They were used for various bootloaders) | . Storage | optional; paper tapes, cassette tapes or 5.25” or 8” floppy disks (MITS 88-DISK) | . Extensions | at first 16 slots, later 18 slots | . Bus | famous S-100 | . Video | none | . I/O | optional; parallel or serial board (MITS 88-SIO) | . Original software | Altair DOS, CP/M, Altair BASIC | . Altair8800 for emuStudio . In emuStudio, there exist two variants of the computer, varying in CPU. Either Intel 8080 CPU, or Zilog Z80 CPU is used. Some behavior was inspired by simh emulator. Abstract schema for emuStudio (Intel 8080): . . Abstract schema for emuStudio (Zilog Z80): . . Each plugin is described in further sections. .",
    "url": "/documentation/user/altair8800/",
    "relUrl": "/altair8800/"
  }
  ,"17": {
    "title": "emuStudio Application",
    "content": "emuStudio Application . emuStudio is a desktop application which allows emulation of various computers. Besides emulation, it contains source code editor, which can be used to write and then compile programs then to be instantly emulated. Virtual computers, as the emulators are called, are represented by plugins of various type (compiler, memory, CPU and device), combined in a comuter configuration. The computer configuration can be opened during startup. . The application has also command-line interface, which allows executing automatic “load-compile-emulate” workflow, possibly without graphical interface. This workflow is called “automatic emulation” and has its specifics, discussed per virtual computer. . A logger is used by emuStudio which helps debugging of the application and plugins. . Installation and run . At first, please download emuStudio distribution. It is either a TAR or ZIP file in the form emuStudio-[VERSION].zip. For Linux/Mac environments, a TAR variant will be more suitable since it preserves file attributes and execution permissions. Unpack the file where you want to have emuStudio installed. . Before running, Java 11 or later must be installed. Then, emuStudio can be run by executing the following script: . On Linux / Mac &gt; ./emuStudio . | On Windows: &gt; emuStudio.bat . | . NOTE: Currently supported are Linux and Windows. Mac is NOT supported, but it might work to some extent. . Command-line interface . emuStudio accepts several command line arguments. Their description is accessible with --help argument: . $ ./emuStudio --help --auto : run the emulation automation (default: false) --config filename : load configuration with file name --help : output this message (default: true) --input filename : use the source code given by the file name --nogui : try to not show GUI in automation (default: false) --waitmax X : wait for emulation finish max X milliseconds (default: -1) . Most of these arguments are self-explanatory. Some of them have meaning only when emulation automation is turned on (--nogui, --waitmax). .",
    "url": "/documentation/user/application/",
    "relUrl": "/application/"
  }
  ,"18": {
    "title": "BrainDuck",
    "content": "BrainDuck . BrainDuck is an abstract computer for emuStudio, which mimics brainfuck programming language. Originally, brainfuck was developed by Urban Miller and it is well-known fact that the language has minimalistic compiler and it’s eight instructions don’t prevent it to be Turing complete. Also, there exist many extensions of the language and there are organized programming contests in brainfuck worldwide. But all of that can be read at Wikipedia or at other sources. . BrainDuck architecture is just a name for virtual computer in emuStudio, and consists of these plugins: . brainc-brainduck: Compiler of brainfuck language (original, without extensions) | brainduck-cpu: Brainfuck emulator acting like CPU with two registers | brainduck-mem: Virtual operating memory which holds both compiled brainfuck program and data | brainduck-terminal: Virtual terminal for displaying the output and requesting for input. | . BrainDuck is implemented as [von Neumann] computer. It means that program and data are shared in the same memory. This is not a common approach of implementing brainfuck interpreters, and it might be changed in the future. . As implementing a brainfuck interpreter, one must deal with several portability issues, which include: . Memory cell size (solved in brainduck-memory and brainduck-cpu) | Memory size (number of memory cells) (solved in brainduck-memory) | End-of-line code (solved in brainduck-terminal) | End-of-file behavior (solved in brainduck-cpu and brainduck-terminal) | . The solution is spread across the plugins, as you can see in the parentheses. Chapters devoted to plugins’ description contain specific information. . BrainDuck for emuStudio . In order to use BrainDuck, there must be drawn the abstract schema, saved in the configuration file. Abstract schemas are drawn in the schema editor in emuStudio (please see emuStudio application documentation for more details). The following image shows the schema of BrainDuck computer: . . The “-&gt;” arrows are in direction of dependency. So for example brainc-brainduck depends on brainduck-mem, because compiled programs are directly loaded into memory. . Between brainduck-cpu and brainduck-terminal exists bidirectional dependency, because input gained from terminal is passed to the CPU, and output is pushed from CPU to the terminal. . plugin brainduck-cpu also depends on brainduck-mem, because memory is a place where program and data are stored. .",
    "url": "/documentation/user/brainduck/",
    "relUrl": "/brainduck/"
  }
  ,"19": {
    "title": "RAM",
    "content": "Random Access Machine (RAM) . Random Access Machine (RAM) is an abstract machine, invented to study algorithmic complexity of programs written on register-based computers. It is equivalent to Turing machine, and has a close relationship with a so-called Harvard computer architecture, which has separated storage for program and data. The implication of this model is that it is not possible to modify instructions. . RAM machine consists of several parts: input tape (read-only), output tape (write-only), program memory, data memory or registers (read/write) and a control unit (“engine”), as can be seen in the following image: . . Input tape acts as a water-tap; the input data can be read from it, causing the input head moving to the next unread symbol. The head can never return to previously read symbol. . Output tape, on the other hand, acts as a sink. The output data can be written to it, causing the output head moving to the next “empty” symbol. The head can also never return to the previously written symbol. . Data memory - registers tape - represents the random-access memory. It consists of so-called registers, abstract cells with arbitrary size. These registers are ordered - each one has assigned the index - its position within the tape, called the address. The tape head can move arbitrarily up and down - but it has its minimum position. It is the first register, R~0~, called the accumulator. Below there are unlimited number of higher-positioned registers. . The role of accumulator is kind of special - it often acts as an implicit operand for many instructions, or implicit place for storing the result of such instructions. . Program memory is a bounded ordered sequence of registers; each of them is identified by its index within the tape, called address. Data memory is also ordered sequence of registers, but like the I/O tapes - bounded just from one side. . Since RAM machine is somewhat abstract, it frees the user from thinking about some issues, and just assumes that: . The size of the problem is always small enough to fit in the RAM memory, | Data used within the computation are always small enough to fit in one register. | . The RAM virtual machine in emuStudio consists of the following plugins: . ramc-ram: Compiler of the RAM language, very simple “assembler”-like language | ram-cpu: RAM simulator engine | ram-mem: Program memory | abstractTape-ram: Device which represents the “tape” used in RAM, other than program memory. The abstract schema must define three instances of this device, representing register, input and output tapes. | . RAM in emuStudio . In order to use RAM, there must exist the abstract schema of the “computer”, saved in the configuration file. Abstract schemas are drawn in the schema editor in emuStudio (please see emuStudio main module documentation for more details). The following image shows the schema of RAM machine simulator: . . The “-&gt;” arrows are in direction of dependency. So for example ramc-ram depends on ram-mem, because compiled programs are directly loaded into memory. . The roles of the abstract tapes are assigned by the RAM “CPU” on runtime. .",
    "url": "/documentation/user/ram/",
    "relUrl": "/ram/"
  }
  ,"20": {
    "title": "RASP",
    "content": "Random-Access Stored Program (RASP) . Random Access Stored Program machine (RASP) is an abstract von-Neumann computer. It means it does not represent a physical device, but ranther it is intended to work as a model to study von-Neumann architecture, without the need to care about specific manufacturer’s hardware details. . Firstly, it is useful to present Random Access Stored Program (RASP) machine’s architecture – it is schematically depicted in the following figure. . . As we can see, the control unit, i.e. processor, reads data from the input tape and writes results of executed operations onto the output tape. The tapes serve as a form of I/O devices. The two heads – reading (R) and writing (W), are pointers to current reading/writing position. . As already stated, RASP machine represents a von Neumann computer. This implies that the operating memory exists as a single unit in which both program and data can reside. The segment containing the program is organised in the way that two adjacent cells contain instruction/operand alternately. The memory can be read as well as written to by the control unit. . RASP for emuStudio . Each virtual computer in emuStudio is defined by so called ‘abstract schema’. It defines all the parts of its architecture (what it consists of) and inner communication (how architecture components are interconnected). Following figure presents RASP abstact schema: . ![RASP abstract schema](/documentation/user/assets/rasp/abstract_scheme.png} .",
    "url": "/documentation/user/rasp/",
    "relUrl": "/rasp/"
  }
  ,"21": {
    "title": "SSEM",
    "content": "Small Scale Experimental Machine, also known as SSEM, was the world’s very first stored-program computer, nicknamed “Baby”. It was a predecessor of Manchester Mark 1 which led to Ferranti Mark 1, the world’s first commercially available general-purpose computer. . The following image shows the SSEM CRT display: . . It it very simple computer, which can run only 7 instructions. . SSEM for emuStudio . In emuStudio, SSEM computer is composed of a compiler, memory, CRT display and CPU. Abstract schema follows: . .",
    "url": "/documentation/user/ssem/",
    "relUrl": "/ssem/"
  }
  ,"22": {
    "title": "",
    "content": "",
    "url": "/documentation/user/",
    "relUrl": "/"
  }
  ,"23": {
    "title": "Introduction",
    "content": "Introduction . emuStudio is a toy-computer emulation platform and framework, targeting mainly academic sphere. A platform, because it supports full emulation “life-cycle”. From writing and compiling programs for emulated machine, to running and debugging. A framework, because it provides API and documentation which encourages implementing your custom toy-computer, either real or abstract. . It does not aim to supersede other emulators which try to preserve history (e.g. MAME, or simh), because they do better job, have big community around them and it does not make sense to provide the same goal. Instead, emuStudio focuses on allowing programming the emulated devices - in the style of “write program - load it into computer - emulate”. . History . Project ‘emuStudio’ started in 2006 as a school project, then a master thesis, created by Peter Jakubčo. He had continued to work on it afterwards, giving it less and less spare time he has now. . Supervisor of the school project was Slavomír Šimoňák, who could be understood as the first “product owner”. On a personal note, the original author remembers the times with nostalgy. Lots of good ideas came from discussions between the supervisor and the author. . The main reason why the project started was lack of good but simple emulators which allowed ‘program-load-emulate’ workflow. Back then at Technical University of Košice (Slovakia), during first lessons in assembly language, students were at first introduced to vintage computers. They had to create simple programs for Intel 8080, but they did it by hand on a paper. emuStudio allowed to use computer, and since then it has established as basic tool, extending to multiple programming-like courses at the university. . Now, students are main contributors which extend emuStudio, but from time-to-time some unknown contributors appear as well, from various countries over the world. Original author still keeps maintaining it. .",
    "url": "/documentation/user/introduction/",
    "relUrl": "/introduction/"
  }
  ,"24": {
    "title": "Logging",
    "content": "Logging . No software is bug-free in these days, and not a person is perfect. Sometimes it might happen that emuStudio is not working as expected, either it does not start (with weird message on screen), or it fails while running. . For that purpose, everything important is being logged. If you encounter some problem and either want to fix it or report it, the logs, except steps to reproduce are the most important thing. By default, logging is written to the standard output (console). In case of a problem it is a good practice to enable file logging. . To enable file logging, open logback.xml file located in the root directory of emuStudio. Find a section named &lt;root ..&gt;, and change appender-ref from STDOUT to FILE as follows: . &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt; . The log file is named logs/emuStudio.log. Every new run of emuStudio will append log messages into that file until emuStudio is terminated. . By default, a rolling policy is enabled, which deletes logs older than 2 days and keeps the log in maximum size of 1 MB. It is of course configurable. For more information about how to configure loggers, please look at the logback site. .",
    "url": "/documentation/user/application/logging",
    "relUrl": "/application/logging"
  }
  ,"25": {
    "title": "Main window",
    "content": "Main window . Main window is the core part of emuStudio application. Users usually spends there most of the time while working with emuStudio. . The content of the window is split into two panels or tabs, placeholders for two actions users can do in emuStudio. The first tab is “Source code editor”, second is “Emulator”, used during computer emulation. . Source code editor . . In the source code editor, users can write programs for emulated computer. However, the most important tool which allows translation of the source code into binary program readable by emulated CPU is a compiler. Therefore, users must use the right compiler. . Input language of a compiler is not limited, it can be either a kind of assembler, or even C or Pascal language. It depends on the compiler implementation, there can be many. The only restriction is that compiler must have output which is compatible with CPU which is currently being emulated. This cannot be checked automatically, users must take care of this. . Source code editor supports only the basic features, such as line numbering and syntax highlighting. Also, there is possibility to search/replace text. . Compilation must be run manually. Compiler output window shows all messages which compiler produces. The content is dependant on the used compiler, but most likely it will contain compilation success or errors messages. . Compiled source code can produce output binary file (for example a HEX file), and it’s automatically loaded into the operating memory. If the emulation is running, user must stop it first manually. . If another program is loaded in memory, it is not removed before loading currently compiled program, but the memory is overwritten at only those locations relevant to the compiled program. All the other content is left unchanged. . Emulator tab . Emulator tab is shown in the following image. It is currently open with MITS Altair8800 computer with Intel 8080 CPU, and several devices: . . The tab contains three main parts. The first one is very useful - listing of operating memory, disassembled into instructions. This part is called a debugger window, or “debugger”. The other part, below the debugger window is a list of all computer devices used (“peripheral devices”). With a double-click user can open GUI window of that particular device, if it supports it. . The last part on the right displays status of the CPU used in this computer. Each CPU has its own implementation of how the status window look and what it displays. . Debugger window . Debugging is a process in which a programmer tries to analyze a program, usually with the intent to find bugs. The adverb “to debug” has a deep history. Very early computers were having of so-called vacuum tubes, which were core elements acting as electrically controlled switches. From time to time a computer stopped working, and the most usual reason was that a bug (real one) came in a vacuum tube. Maintainers of the computer had to go there and manually remove the bug. It happened that often, so that the process of removing bugs got a name - “to de-bug”.] Debugger in emuStudio contains a debugger toolbar and list of few disassembled instructions from memory. In combination with CPU status panel, it’s the most powerful tool for seeing (and checking) all internal behavior of the emulated computer. . Debugger toolbar . Debugger toolbar contains buttons (icons) for controlling the emulation and accessing memory content. Most of these buttons are self-explanatory. If you hover over those icons, a help text is displayed of how to use the icon. . . A: Reset emulation. | B: Set next instruction position to 0. CPU will perform the next instruction from there. | C: Set next instruction position to the (current - 1). This action can completely change displaying of instructions, since the new instruction position does not have to be correct in term of executing the current program. | D: Stop emulation (which is either running or paused). | E: Pause emulation (which is running). | F: Run emulation (which is paused). | G: Run emulation with timer (which is paused). Instructions are executed after elapsing specified time interval. A dialog will appear to enter the time interval. | H: Step emulation (which is paused). CPU will execute only one - the very next - instruction. | I: Jump to location. User will manually specify location (address in memory) for the next instruction to execute. | J: Set/unset breakpoint. User can set or unset a breakpoint on specific memory location. When CPU reaches the breakpoint, it will pause there, waiting for next user action. | K: Show operating memory. If the memory plugin does not have a GUI, the icon is disabled. | . List of instructions . The largest part of the debugger window a list of few disassembled instructions, so-called instructions window. Around 15 instructions are shown, but it depends on the CPU. They are arranged in a table. The first column is usually interactive, allowing user to set breakpoints. Red strip is pointing to the very next instruction being executed. . The size of disassembled memory (resulting in the number of disassembled instructions) is not configurable. Also, user cannot change instructions in this place. . Sometimes the instructions shown in the debugger do not have to be disassembled correctly. There are two reasons for that: . first, instructions can have various binary sizes (e.g. one byte, two bytes, etc.) | second, memory can contain programs on various locations, and emuStudio doesn’t know where. Well, if it’s just program compiled from the source code editor, it knows. | . The implication is that if emuStudio starts to disassemble instructions at wrong location, the instructions will be disassembled incorrectly, or they can appear as invalid. . However, emuStudio is trying hard to find the nearest program start location at which it’s safe to start disassembling. Usually it’s just few instructions back, so it is a fast process. . Controlling of displaying the instructions . It’s possible to change the current instructions view. The window can be moved in a per-page fashion. The amount of instructions displayed in the window is always preserved. With the toolbar below the list it’s possible to change “pages” of the displayed instructions. . . A: Go to the first page. The very first row corresponds to instruction position 0. | B: Go backwards. User will specify the number of pages for going back. | C: Go to the previous page. | D: Go to the page where current instruction position is. | E: Go to the next page. | F: Go forwards. User will specify the number of pages for going forward. | G: Go to the last page. It can cause incorrectly displaying of instructions. | .",
    "url": "/documentation/user/application/main-window",
    "relUrl": "/application/main-window"
  }
  ,"26": {
    "title": "Opening a computer",
    "content": "Opening a computer . The first action which emuStudio does is loading a computer to be emulated. Virtual computers are described in abstract schemas, which are stored in configuration files. . Computers can be loaded either from command line, or manually in GUI (by default). The open dialog is the first thing which appears to a user. . . Left part contains a control panel and a list of all available virtual computers. When a user clicks at a computer, it’s abstract schema is displayed on the right. Double-clicking or clicking on the Open button loads selected computer. . Managing virtual computers . . A: Adds new computer. The abstract schema editor will be opened. | B: Deletes selected computer. Be aware of what you are doing - the action cannot be undone. | C: Edits selected computer. The abstract schema editor will be opened. | D: Saves the displayed abstract schema into image file. | .",
    "url": "/documentation/user/application/opening-computer",
    "relUrl": "/application/opening-computer"
  }
  ,"27": {
    "title": "CPU "ram-cpu"",
    "content": "CPU “ram-cpu” . This plugin is the core of the emulation/simulation. Even if we’re supposed to talk about RAM simulator, because emulation is connected more with imitation of real hardware than abstract machine, there is a plugin which calls itself a RAM CPU. It is really not accurate, but CPU nowadays means something as the main or core engine of the computation which the machine does. So the name is stick rather with this convention. . The plugin strictly requires a ram-mem, and three instances of abstractTape-ram plugins, representing the tapes. After boot, the CPU assigns the specific meaning to each tape. . Status panel . In the following image, you can see the status panel of ram-cpu. . . It is split into three parts. Within ‘Internal status’ part, there is shown content of registers R0 (accumulator) and IP. Register IP is the position of the program memory head. It stands for “instruction pointer”. It is pointing at the next instruction being executed. . The input/output part shows the next unread symbol (“next input”), and the last symbol written to the output tape (“last output”). This is just for the convenience; it is possible to see the same values in particular tape devices. . The last part, “Run state”, shows in which state the whole emulation is, and it is common to all emulators in emuStudio. The state “breakpoint” means that the emulation is paused. .",
    "url": "/documentation/user/ram/ram-cpu",
    "relUrl": "/ram/ram-cpu"
  }
  ,"28": {
    "title": "Memory "ram-mem"",
    "content": "Program memory (“ram-mem”) . RAM memory is used as a part of RAM simulator, which acts as the “program memory”, holding just the program. . RAM CPU reads instructions from this memory. The instructions can be written here only by compiling the source code, or loading already compiled binary image. . The memory plugin contains simple graphical window, a GUI, which provides a set of the following features: . It computes time and space complexity of the program | It shows the memory content (the “program”) as the list of disassembled instructions | . Graphical user interface (GUI) . The memory GUI can be seen in the following picture. . . A: Opens already compiled program into memory. Previous program will be dismissed. | B: Clears memory. | C: Shows uniform time complexity for the actual program. | D: Shows uniform space complexity for the actual program. | . Uniform time complexity means maximum number of instructions based on the input N. Uniform space complexity means maximum number of used registers. .",
    "url": "/documentation/user/ram/ram-mem",
    "relUrl": "/ram/ram-mem"
  }
  ,"29": {
    "title": "Compiler "ramc-ram"",
    "content": "Compiler “ramc-ram” . RAM has a very simple assembler-like language, consisting of direct and indirect reading/writing from/to registers or input/output tape. In addition, there are three control-flow instructions. . Language syntax . The program written for this compiler consists of two sections: . INPUT section INSTRUCTIONS section . Input section . The INPUT section contains definitions the content of input tape - one or more lines in the form: . &lt;input&gt; ITEMS . where ITEMS is a space-separated list of inputs. Each input is one word - it might be any number or string. By default, every cell in the input tape is a string, and it is not interpreted as some data type. It is only in time when it is used - the instruction which works with the cell defines of which “type” it should be. . For example, input section might be: . &lt;input&gt; 1 2 3 hello world! . In this case, there are five inputs: numbers 1,2,3, then word “hello” and the last one is “world!”. . Instructions section . There exist many possible formats or variations of RAM instructions, unfortunately the syntax is not very unified. I guess the reason is that RAM is not a real machine, and for the purposes of the algorithm analysis the machine is so simple that it’s description is repeated in almost every paper where it appears. . For this reason, instructions format or the whole vocabulary might be different of what you expected or used for. We have to live with it; but the differences are really small. . Instructions should follow the Input section, but the sections can be mixed. It is just good practice to have input separated from the code. Each instruction must be on separate line, in the form: . [LABEL:] INSTRUCTION [; optional comment] . Each instruction position can be optionally labelled with some identifier (LABEL field), followed by a colon (:) character. The labels can be then referred in other instructions. . Comments begin with a semicolon (;) character and continue to the end of the line. There are no multi-line comments. . Instructions consists of the operation code and optional operand, separated with space ( ). . Operation code is expressed as an abbreviation of corresponding operation (e.g. SUB for SUBtraction). Operand can be one of three types: constant (=i), direct operand (i), where i specifies the register index on tape and indirect operand (*i), where the address of operand specified is stored in register R~i~. . The following table describes all possible instructions, usable in the RAM simulator: . Instruction Constant (=i) Direct (i) Indirect (*i) . READ |   | R~i~ &lt;- next input |   | . WRITE | output &lt;- i | output &lt;- R~i~ | output &lt;- M&lt;R~i~&gt; | . LOAD | R~0~ &lt;- i | R~0~ &lt;- R~i~ | R~0~ &lt;- M&lt;R~i~&gt; | . STORE |   | R~i~ &lt;- R~0~ | M&lt;R~i~&gt; &lt;- R~0~ | . ADD | R~0~ &lt;- R~0~ + i | R~0~ &lt;- R~0~ + R~i~ | R~0~ &lt;- R~0~ + M&lt;R~i~&gt; | . SUB | R~0~ &lt;- R~0~ - i | R~0~ &lt;- R~0~ - R~i~ | R~0~ &lt;- R~0~ - M&lt;R~i~&gt; | . MUL | R~0~ &lt;- R~0~ * i | R~0~ &lt;- R~0~ * R~i~ | R~0~ &lt;- R~0~ * M&lt;R~i~&gt; | . DIV | R~0~ &lt;- R~0~ / i | R~0~ &lt;- R~0~ / R~i~ | R~0~ &lt;- R~0~ / M&lt;R~i~&gt; | . JMP |   | IP &lt;- i |   | . JZ |   | if R~0~ == 0 then IP &lt;- i |   | . JGTZ |   | if R~0~ &gt; 0 then IP &lt;- i |   | . HALT |   | halts the simulation |   | . The table describes also the behavior of each instruction. Compiler does not care about the behavior, but about the instructions syntax, which is also incorporated in the table. . For example, this is a valid program: . ; COPY(X,Y) ; ; input: X -&gt; r1 ; Y -&gt; r2 ; ; output: X -&gt; Y ; Y -&gt; Y &lt;input&gt; 3 4 world hello &lt;input&gt; sss ; load X,Y read 1 read 2 ; load r.X, r.Y read *1 read *2 ; copy load *2 store *1 halt .",
    "url": "/documentation/user/ram/ramc-ram",
    "relUrl": "/ram/ramc-ram"
  }
  ,"30": {
    "title": "CPU "rasp-cpu"",
    "content": "CPU “rasp-cpu” . RASP CPU is the core of the RASP virtual computer. Its purpose is to execute RASP program composed of RASP instructions which is stored in the RASP memory. The CPU is therefore connected with the memory. . To run ‘interactive’ RASP programs (programs reading user input and writing something to the output), input and output tapes are needed. They are included there in default RASP configuration. . Supported instructions . RASP CPU emulator supports the following instructions: . Operation code Instruction mnemonic code Semantics . 1 | READ i | read from input tape into register Ri | . 2 | WRITE =i | write constant i onto the output tape | . 3 | WRITE i | write the content of the register Ri onto the output tape | . 4 | LOAD =i | load the accumulator (register R0) with the i constant | . 5 | LOAD i | load the accumulator (register R0) with the content of Ri register | . 6 | STORE i | store the accumulator (register R0) content into register Ri | . 7 | ADD =i | increase accumulator (register R0) value by constant i | . 8 | ADD i | increase accumulator (register R0) value by the value of register Ri | . 9 | SUB =i | decrease accumulator (register R0) value by constant i | . 10 | SUB i | decrease accumlator (register R0) by the value of register Ri | . 11 | MUL =i | multiply accumulator (register R0) by constant i | . 12 | MUL i | multiply accumulator (register R0) by the value of register Ri | . 13 | DIV =i | divide accumulator (register R0) by constant i | . 14 | DIV i | divide accumulator (register R0) by the value of register Ri | . 15 | JMP l | set instruction pointer (IP) to the address pointed to by the label l | . 16 | JZ l | set instruction pointer (IP) to the address pointed to by the label l if value of the accumulator (register R0) is zero (R0 = 0) | . 17 | JGTZ l | set instruction pointer (IP) to the address pointed to by the label l if value of the accumulator (register R0) is greater than zero (R0 &gt; 0) | . 18 | HALT | finish program execution | . CPU Status panel . There is a simple GUI window provided for the RASP CPU. It displays the two most important values: . current value of the accumulator (R0 register) | current value of the instruction pointer (IP) which points to current position within the executed program | . Also, information about the current RUNNING STATUS is displayed. . Following figure shows a screenshot: . .",
    "url": "/documentation/user/rasp/rasp-cpu",
    "relUrl": "/rasp/rasp-cpu"
  }
  ,"31": {
    "title": "Memory "rasp-mem"",
    "content": "Memory “rasp-mem” . RASP memory plug-in serves as the main store (operating memory) for the RASP virtual computer. As already mentioned in the introduction of this manual, RASP is an example of von-Neumann architecture, which implies that both program and data reside in the same memory module. . After compilation of a RASP source code file the compiled program is loaded into here. During the process of the emulation, the CPU plug-in reads instructions an their operands and writes results of the operations from/to the memory. . Graphical user interface (GUI) . During the emulation, user can view current content of the operating memory in a simple GUI window: . . It is also possible to load a compiled memory image from a file by clicking on the OPEN icon: . . After that, you can choose the binary file you want to load. . By clicking on the CLEAN icon, you can clean the entire memory content: . . The table with memory cells content is editable. By double-clicking on a row you can simply edit the value. You confirm your changes by the ENTER key. . WARNING: If you edit a cell that contains an instruction, you edit its operation code, e.g. if a cell contains the ADD = instruction (operation code 7) and you change the cell to 9, the operation code will be overwritten. As a result, the instruction changes to SUB =. It means that you cannot write number 9 as a data item here, only as an operation code. .",
    "url": "/documentation/user/rasp/rasp-mem",
    "relUrl": "/rasp/rasp-mem"
  }
  ,"32": {
    "title": "Compiler "raspc-rasp"",
    "content": "Compiler “raspc-rasp” . RASP compiler is included in the architecture of RASP virtual computer in emuStudio. Its purpose is to translate source code of a RASP program into the form executable by the RASP CPU emulator. . It includes lexical analyzer which is responsible for recognising lexical units within the source code. It also enables syntax highlighting. Then, the code goes through syntax analysis which checks for syntax errors and builds up the syntactic tree. The tree is then passed through and binary code executable by the emulator is generated. . As with the other emuStudio compilers, you start the compilation by the “Compile source” icon in the main menu. The result of the compilation is saved into a binary file with the .bin extension and also loaded into the RASP operating memory. . Language syntax . Program start definition . As RASP is a von-Neumann computer, both the program and the data reside in the same memory module. Therefore, we need to clearly specify, where the program start address is as CPU must know where to start emulation. We do so by the org directive followed by a positive ineteger. Program start definition must be the first line of the source code. Please, do not place any empty lines before it. Here, an example follows: . org 5 . WARNING: If you do not specify the program start address, or if you set it to 0 (org 0), the default pre-set value will be used, which is 20. The compiler will warn you about this, so do not worry. Setting program start to 0 is not allowed as register R0 is used as the accumulator and therefore any instruction written here would be overwritten sooner or later. . Supported instructions . All RASP emulator supported instructions together with their semantics are available in the RASP CPU documentation. There are three types of operands of those instructions: . register - e.g. READ 1 | constant - e.g. WRITE =2 - you specify that operand of an instruction should be interpreted as a constant by the = character. | label, which is operand of jump instructions (JMP, JZ, JGTZ), e.g. JMP *label* | . Line of code structure . Each RASP instruction with its operand MUST be on a separate line, otherwise the code will not compile. . A single line of code consists of instruction followed by its operand. The line can be optionally started with a label. It is possible to put the label and the instruction on two separate lines, however, please, do not place any empy lines between the label and the instruction. . Example (WRITE 2 can be on a separate line): . *labelName:* WRITE 2 . Comments . RASP compiler supports one-line comments. You start them with a semicolon (;): . ;this is a comment . You can append a comment to an existing line, e.g. . write 2 _;comment_ . or put it on a completely new line. .",
    "url": "/documentation/user/rasp/raspc-rasp",
    "relUrl": "/rasp/raspc-rasp"
  }
  ,"33": {
    "title": "Computer schema",
    "content": "Computer schema . Computer schema represents real configuration of emulated computer. They are “drawn” in a computer schema editor. Users pick plugins which appear as “boxes” or elements on the screen. Then using connection lines those elements can be connected together to express a relation (that they can “see” each other). . . Description of the control panel follows. . . A: Save the virtual computer. | B: Select a compiler. | C: Select a CPU. | D: Select a memory. | E: Select a device. | F: Use a connection line. The line is bidirectional by default. | G: Set or unset the connection line to be bidirectional. If the line is not bidirectional, the source direction is the first clicked element and the target direction is the second clicked element. | H: Remove an element from the schema. | I: This drop-down list is used for selecting specific plugin (element) in the computer schema. See icons B, C, D, and E. Those names are just file names of plugins. | J: Use / do not use a grid in the editor. Elements are “snapped” to the grid if it is used and it’s easier to draw the schema which looks good. The slider on the right then controls density of the grid. The density is saved in the configuration file of the edited computer. | . Virtual computers in emuStudio are following von-Neumann model of computers. It means that each computer must have a CPU, and memory. Optionally one or more devices, and optionally a compiler. . Connection lines . Connection line represents virtual “connection” between computer components. For the computer schema it’s not important how the connection is realized. It’s safe to say that the connection is similar as if we say that a component “sees” the other component, in the direction of the arrow: . . In the previous image, a CPU “sees” the memory, but not vice-versa. It means, CPU can read/write from/to memory, but memory is not seeing it, it can just answer to CPU requests. This connection makes sense in real-world computers. . Drawing connection lines is very easy. Connection line always connects exactly two elements in the schema. At first, user must click on already existing element in the schema. It’s just a click, not a drag. . Then a grey temporary line is being drawn having its end at the mouse position and moving with the mouse move. If the element is not really close, user can make a “path” by clicking somewhere in the schema. At those locations fixed-points are created. . When a user clicks at the second element, the temporary line disappears, and real connection line is created. . User can find the fixed-points later and move them by dragging. They can be removed by clicking at them with right button of the mouse. .",
    "url": "/documentation/user/application/computer-schema",
    "relUrl": "/application/computer-schema"
  }
  ,"34": {
    "title": "Device simhPseudo-z80",
    "content": "Virtual device “simhPseudo-z80” . Virtual device partially reimplemented from simh emulator. This device is used mainly for communication between CP/M 3 operating system for simh and emuStudio. Most of the original functionality is not implemented, but it is crucial for support of memory bank-switching. . Programming . Z80 or 8080 programs communicate with the SIMH pseudo device via port 0xfe. Programmers must apply the following principles: . For commands that do not require parameters and do not return results: . ld a,&lt;cmd&gt; out (0feh),a . Special case is the reset command which needs to be send 128 times to make sure that the internal state is properly reset. . | For commands that require parameters and do not return results: . ld a,&lt;cmd&gt; out (0feh),a ld a,&lt;p1&gt; out (0feh),a ld a,&lt;p2&gt; out (0feh),a ... . Note: The calling program must send all parameter bytes. Otherwise the pseudo device is left in an undefined state. . | For commands that do not require parameters and return results: . ld a,&lt;cmd&gt; out (0feh),a in a,(0feh) ; &lt;A&gt; contains first byte of result in a,(0feh) ; &lt;A&gt; contains second byte of result ... . Note: The calling program must request all bytes of the result. Otherwise the pseudo device is left in an undefined state. . | Commands requiring parameters and returning results do not exist currently. . |",
    "url": "/documentation/user/altair8800/simhPseudo-z80",
    "relUrl": "/altair8800/simhPseudo-z80"
  }
  ,"35": {
    "title": "Original software",
    "content": "Original software for Altair8800 . Since Altair8800 virtual computer emulates a real machine, it’s possible to use real software written for the computer. Several operating systems and programs can be run on Altair. There are many disk and memory images of those systems available online, but only some were tested and proved to work. Some of the available online sites are: . Peter Schorn | Altair clone | SIMH | DeRamp | . If you want to manipulate with disk images, please follow this link. . Most of the disk images were borrowed from great simh emulator. It’s obvious that some images were modified for simh. On the other hand, it’s not that obvious if the original images would actually work at all. . Tested and fully-functional images were: . Operating system CP/M v2.2 and 3 | Altair DOS v1.0 | BASIC programming language in various versions | . Disk / memory images for software for Altair8800 are available on many online sites, such as here or here. Some manuals can be found e.g. here. . The following subsections describe in short how to boot some of those systems, along with screen-shots how it looks. . Boot ROM . Booting operating systems on Altair requires special ROM image to be loaded in operating memory. The purpose of a boot ROM is to load specific block of data from a device and then run it as if it was code. The code block is often called ‘boot loader’. It is very small program which just loads either the whole or part of the operating system into memory and then jumps to it. . Originally, more boot ROMs existed. Different boot ROMs were used to load the code from different devices. In current implementation of emuStudio, there is only one boot ROM supported - so called ‘disk boot loader’ (or DBL), which loads operating system from MITS 88-DISK (through CPU ports). . The boot loader is already available in a file examples/altair8800/boot.bin of emuStudio installation. . Boot ROM must be loaded into memory at address 0xFF00 (hexadecimal). It is safe to jump to this address manually when operating system image file is mounted. . NOTE: All subsequent sections assume that the boot loader has been loaded in the operating memory. . CP/M 2.2 . During Altair8800 computer era, many operating systems, applications and programming languages have been developed. On of the most known operating systems is CP/M. It was written by Gary Kildall from Digital Research, Inc. At first it was mono-tasking and single-user operating system which didn’t need more than 64kB of memory. Subsequent versions added multi-user variants and they were ported to 16-bit processors. . The combination of CP/M and computers with S-100 bus (8-bit computers sharing some similarities with Altair 8800) was big “industry standard”, widely spread in 70’s up to 80’s years of twentieth century. The operating system took the burden of programming abilities from user, and this was one of the reasons why the demand for hardware and software was rapidly increased. . Tested image has name altcpm.dsk. It can be downloaded at this link. . In order to run CP/M, please follow these steps: . Mount altcpm.dsk to drive A: in MITS 88-DISK. | In emuStudio jump to location 0xFF00 | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. | Before starting emulation, show ADM-3A terminal | Run the emulation | When the steps are completed, CP/M should start (an informational message appears) and command line prompt will be displayed: . . Command dir is working, ls is better dir. More information about CP/M commands can be found at this link. . CP/M 3 . Steps for running CP/M 3 operating systems are not that different from CP/M 2. The disk image file is called cpm3.dsk and can be downloaded at this link. CP/M 3 came with two versions: banked and non-banked. The image is the banked version of CP/M. Also, simh authors provided custom BIOS and custom boot loader. . Manual of CP/M 3 can be found at this link. For more information about simh version of Altair8800 and CP/M 3, click here. . There are some requirements for the computer architecture, a bit different for CP/M 2.2. . CPU . It is recommended to use Z80 version of the computer. CPU Intel 8080 will work for the operating system itself, but most provided applications require Z80. . Operating memory . Also, the operating memory needs to be set for memory banks. The following parameters were borrowed from simh and were tested: . 8 memory banks | common address C000h | . Boot ROM . There exist specific version of boot loader (modified probably by simh authors) to load CP/M into banked memory. It is available in examples/altair8800/mboot.bin in your emuStudio installation. Before other steps, please load this image into operating memory at address 0xFF00 (hexadecimal). . Steps for booting CP/M 3 . Specific steps how to boot CP/M 3 in emuStudio follow: . Mount cpm3.dsk to drive A: in MITS 88-DISK. | In emuStudio jump to location 0xFF00 | Optionally, you can set CPU frequency to 2500 kHz, which was Zilog Z80 original frequency. | Before starting emulation, show ADM-3A terminal | Run the emulation | The following image shows the look right after the boot: . . Altair DOS v1.0 . Steps for booting Altair DOS v1.0 follow: . Mount altdos.dsk to drive A: in MITS 88-DISK. | In emuStudio jump to location 0xFF00 | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. | Before starting emulation, show ADM-3A terminal | Run the emulation | The system will start asking some questions. According to the Altair manual, answers for emuStudio are: . MEMORY SIZE? -&gt; 64 or ENTER (if memory ROM is at 0xFFFF) | INTERRUPTS -&gt; N or just ENTER | HIGHEST DISK NUMBER? -&gt; 0 (if only 1 disk is mounted) | HOW MANY DISK FILES? -&gt; 3 | HOW MANY RANDOM FILES? -&gt; 2 | . Basic commands you can use are e.g. MNT 0 - to mount the drive, and then DIR 0 to list the files. . If you want AltairDOS being able to automatically detect how much memory is installed on system, it is possible. The system does it by very nasty trick - testing if it can write to particular address (ofcourse, maximum is 16-bits - i.e. 64K of memory). If the result is the same as it was before reading, it means that it reached the “end of memory”. But when it fails to detect the ROM, it fails to determine the size, too, and the output will be INSUFFICIENT MEMORY. . The following image shows how it looks like: . . BASIC . In this section will be presented how to boot MITS BASIC version 4.1. There is possible to boot also other versions, but the principle is always the same. . As it is written in simh manual: MITS BASIC 4.1 was the commonly used software for serious users of the Altair computer. It is a powerful (but slow) BASIC with some extended commands to allow it to access and manage the disk. There was no operating system it ran under. . After boot, you must mount the disk with MOUNT 0. Then, command FILES will show all files on the disk. In order to run a file, run command RUN &quot;file&quot;. Manual can be found at this link. . It is assumed you have either examples/altair8800/boot.bin or examples/altair8800/mboot.bin mounted in the operating memory. . Steps for booting BASIC follow: . Mount mbasic.dsk to drive A: in MITS 88-DISK. | In emuStudio jump to location 0xFF00 | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. | Before starting emulation, show ADM-3A terminal | Run the emulation | The following image shows the look right after the boot: . .",
    "url": "/documentation/user/altair8800/software",
    "relUrl": "/altair8800/software"
  }
  ,"36": {
    "title": "CPU "ssem-cpu"",
    "content": "SSEM CPU emulator . SSEM is one of the first implementations of the von-Neumann design of a computer. It contained control unit, arithmetic-logic unit and I/O subsystem (CRT display). . Speed of CPU is around 700 instructions per second. . The architecture of our SSEM CPU emulator will look as follows (below is Display and Memory just to show how it is connected in overall): . . Status panel . The status panel is the interaction point between CPU and the user. With it, the user can be allowed to modify or view the internal status of the CPU emulator. This is very handy when learning or checking how it works, what the registers’ values really are (and compare them with those shown on a display), etc. The status panel shows the following: . CPU run state | Internal state: registers or possibly portion of memory | Speed | . SSEM CPU status panel looks as follows: . . Automatic emulation . The optional step is to change a behavior slightly when user runs the automatic emulation. The memory content is important enough to be put in a file in case of automatic emulation. It has just 32 rows. It can be useful to see the content of the accumulator and CI register after the emulation finishes as well. . After each emulation “stop” - no matter the reason of stopping, if before the emulation was running, a “snapshot” of the emulator state is performed - registers Acc, CI and memory content are saved to the file, called ssem.out. . The emulator automation can be run as follows: . ./emuStudio --config config/SSEMBaby.toml --nogui --auto --input examples/as-ssem/noodle-timer.ssem . the emulation will run without user interaction, and file ssem.out will be created with the following content: . ACC=0x3bfffe2 CI=0x58 L L L L L 5 6 7 8 9 0 1 2 I I I 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 00 01 * * * * * * * * * * * * * * * * * * * * * * 02 * * * * * * * * * * 03 * * * * * * * * * 04 * * * * * * * * * * 05 * * * * * * * * * * 06 * * * * * * * * * * * * * 07 * * * * * * * * * * 08 * * * * * * * 09 * * * * * * * * * * * * * * * * * * 10 * * * * * * * 11 * * * * * * * * * * * 12 * * * * * * * * * * * * * 13 * * * * * * * * * * * * * * * 14 * * * * * * * * * * 15 * * * * * * 16 * * * * * * * * * * * * * * 17 * * * * * * * * * * * * * * * * * * * * * 18 * * * * * * * * * * * * * 19 * * * * * * * 20 * * * * * * * * * * * * * 21 * * * * * * * * * * * * 22 * * * * * * * * * * * 23 * * * * * * 24 * * * * * * 25 * * * * * * * * * * * * * * * * 26 * * 27 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 28 * * * * * 29 * * * * * * * 30 * * * * * * * * * * * * * * * * * * * * * * 31 * * * * * * .",
    "url": "/documentation/user/ssem/ssem-cpu",
    "relUrl": "/ssem/ssem-cpu"
  }
  ,"37": {
    "title": "Display "ssem-display"",
    "content": "SSEM Display . SSEM computer used CRT “display”, which displayed the SSEM memory content. emuStudio plugin does not mimic the real display interface with switches and everything, but it is just a display of the memory content. Here can be seen how the original display looked like. . Graphical User Interface (GUI) . GUI of the display looks as follows: . . It doesn’t do any user interaction except displaying. .",
    "url": "/documentation/user/ssem/ssem-display",
    "relUrl": "/ssem/ssem-display"
  }
  ,"38": {
    "title": "Memory "ssem-mem"",
    "content": "Memory “ssem-mem” . SSEM used the world’s first random-access memory called Williams or Williams-Kilburn tube. Used principle was the same as in standard Cathode-Ray-Tubes (CRTs). Original EDSAC computer (which introduced the von Neumann architecture) did not have random-access memory. . SSEM memory had 32 memory cells (called words), each had size of 32 bits. The memory could contain instructions and data. So, one SSEM instruction perfectly fits in the single memory word. . SSEM had 32 so-called “lines”, which represented cells in memory. Each line, or a cell, was 4 bytes long. . Graphical user interface (GUI) . Since emuStudio is interactive application, GUIs are a natural thing. The memory GUI looks as follows: . . As you can see in the picture, a row represents single SSEM memory cell - 32 scattered bits, and the last few columns show both the number the bits represent, and a raw ASCII value of the 4-byte sequence of data. . Edits of cells is also possible, by pointing to a bit, and pressing either 1 or 0 - possibly a DELETE key, committing the change immediately. This works for the value itself, and for the data column as well. . Movement around cells is possible with arrow keys. .",
    "url": "/documentation/user/ssem/ssem-mem",
    "relUrl": "/ssem/ssem-mem"
  }
  ,"39": {
    "title": "Memory standard-mem",
    "content": "Operating memory “standard-mem” . This plugin emulates an operating memory, in a quite broad meaning. It can be used for any virtual computer which can benefit from the following basic properties: . A memory cell has size of 1 byte (8 bits) | Memory cells are linearly ordered (sequential) | Each memory cell is accessible by unique address, representing the index of the memory cell, if the memory is imagined as an array of cells | . Besides, the memory supports these additional features: . Setting up ROM (read only memory) ranges | Changing memory size; by default it is 64kB | Support of bank switching | . There are also some “interactive” features: . Manual loading/saving memory images in either binary or Intel HEX format | Ability to automatically load a memory image at startup | Intuitive control using keystrokes, and nice visual presentation of the data | . This operating memory is (for now) used only in 8-bit emulator of MITS Altair8800. However it is possible to develop an emulator which can benefit from it. . GUI overview . To open the memory GUI (graphical user interface), click at the right-most icon in the debug toolbar, on the Emulator panel. The window is shown, as in the following image: . . A: Open a memory image. Current memory content, if it does not interfere with the loaded data will be kept. | B: Dump (save) whole memory content into a file. | C: Go to address. The address can be either in decimal, hexadecimal (prefix 0x) or octal (prefix 0) format. | D: Find a sequence. A dialog shows up where user can find either a plain text or sequence of bytes in the memory. | E: Erases all memory content. | F: Shows memory settings | G: By double-clicking on the memory cell it is possible to edit it and change its value. The value format is the same as the input to “go to address” dialog (see C). | H: Page of the memory view. The whole memory cannot be shown in single window, because it can be quite large (64 kB by default), so it was divided into pages. | I: If the memory has set up «STANDARD-MEM_BANKS,memory banks», it is possible to change the view to different bank. Switching in here has no effect on the emulator and on the active bank. | J: Displays the data of the selected cell in various forms. | . Generally, it is possible to move around the cells using keystrokes (arrows). If user presses some other letter/number key, a small text field appears allowing to edit the current value. When editing is finished, user can press ENTER key to confirm it, or ESC key to discard the editing. . Memory settings . Settings window can be opened by clicking on “settings” icon in the main GUI window: . . A: Settings for memory bank-switching | B: Settings for ROM areas | C: If checked, settings for ROM areas will be saved to the configuration file | D: List of memory images which will be loaded at startup | E: The button will apply the settings | . ROM areas and memory bank-switching is explained in the following sections. . ROM areas . Some “controllers” - used as embedded devices - usually logically organize memory into areas, some of which are read only, which usually contains the firmware, and some are rewritable. Physically, these memories are wired to specific addresses, so the programmer can access them. . Standard operating memory plugin emulates this behavior. It allows to define ROM areas which represent read only memory. There can be set up multiple ROM areas, and they can overlap. Effectively it means that memory cells in ROM area cannot be changed from software running on the emulator. All writes to the memory will be ignored. . Manually, as a user it is possible to change the values, but only by loading new memory image. Editing the value will not work. . If a ROM range is defined, it is possible to remove only a part of it, effectively splitting the range and correcting their boundaries. For example, if there is defined a ROM range from 0x0A - 0x64 (see the image above), then it is possible to remove a range e.g. 0x32 - 0x46, which is the part of defined ROM area. Then, the original ROM area is split into two parts - first will be a range from 0x0A - 0x31, and the second from 0x47 - 0x64. . Memory bank-switching . This technique was invented as a workaround for a problem when the address space of a processor was smaller than memory size. In order to overcome this issue, memory was logically split into many regions of size equal to the processor address space. These regions are called “banks”. . Physically, banks could refer to the same memory, but they could be also different memories (e.g. external cartridges), and the bank-switching involved switching the active memory. . Selecting a bank from a programming perspective was usually done by writing some code to some I/O port using some I/O instruction of a CPU. But it can be implemented in various ways, e.g. some memory addresses can be used for selecting a bank. . Also, it was very common that some part of the address space still kept some common memory part which was never switched out. This part is called a “common” part. In emuStudio, common part starts with the Common address (as it can be seen in the Settings dialog image above) and ends till the rest of the CPU address space (or memory end). . To summarize, let’s consider an example. If a CPU is 8-bit, it means it has address space of size 2^8 - i.e. it can access memory from address 0 to (2^8 - 1). If the memory was larger, CPU just doesn’t allow to access higher memory cells. So memory bank-switching is coming for the rescue. If the memory has 2 MB, we require 2^log2(2MB) = 2^21 addresses. So, if we won’t have any common address space, we require ceil(21 / 8) = 3 banks: . bank 0: maps from 0 - (2^8 - 1) | bank 1: maps from 2^8 - (2^16 - 1) | bank 2: maps from 2^16 - (2^21 - 1) | . Configuration file . The following table shows all the possible settings of Standard operating memory plugin: . Name Default value Valid values Description . banksCount | 0 | &gt;= 0 | Number of memory banks | . commonBoundary | 0 | &gt;= 0 and &lt; mem size | Address from which the banks are shared | . memorySize | 65536 | &gt; 0 | Memory size in bytes | . ROMfrom(i) | N/A | &gt;= 0 and &lt; mem size | Start of the i-th ROM area | . ROMto(i) | N/A | &gt;= ROMfrom(i) and &lt; mem size | End of the i-th ROM area | . imageName(i) | N/A | file path | The i-th memory image file name. If it ends with .hex suffix, it will be loaded as Intel HEX format, otherwise as binary | . imageAddress(i) | N/A | &gt;= 0 and &lt; mem size | The i-th memory image load address | . Using memory in custom computers . This section is for developers of emulators. If you do not plan to create custom virtual computers, you can safely skip this section. In order to get started with developing plugins for emuStudio, please read tutorial “Developing emuStudio Plugins”. . As it was mentioned in the earlier sections, the Standard operating memory plugin can be used in other computers, too. Besides standard operations which are provided by net.emustudio.emulib.plugins.memory.MemoryContext interface, it provides custom context API, enabling to use more features - e.g. bank-switching. . You can obtain the context in Plugin.initialize() method. The context is named net.emustudio.plugins.memory.standard.api.StandardMemoryContext: . ... public void initialize(SettingsManager settings) { StandardMemoryContext mem = contextPoolImpl.getMemoryContext(pluginID, StandardMemoryContext.class); ... } . The memory context has the following content: . package net.emustudio.plugins.memory.standard.api; import net.emustudio.emulib.plugins.annotations.PluginContext; import net.emustudio.emulib.plugins.memory.MemoryContext; import java.util.List; /** * Extended memory context. * &lt;p&gt; * Supports bank switching, ROM ranges, and loading HEX/BIN files. */ @PluginContext(id = &quot;Standard memory&quot;) public interface StandardMemoryContext extends MemoryContext&lt;Short&gt; { /** * This interface represents a range of addresses in the memory. */ interface AddressRange { int getStartAddress(); int getStopAddress(); } /** * Determine whether specified memory position is read-only. * * @param address memory position * @return true if the memory position is read only, false otherwise */ boolean isReadOnly(int address); /** * Get list of ranges of read-only addresses. * * @return list of ROM memory addresses */ List&lt;? extends AddressRange&gt; getReadOnly(); /** * Set specified memory range as RAM (Random Access Memory). * * @param range address range */ void setReadWrite(AddressRange range); /** * Set specified memory range as ROM (Read Only Memory). * * @param range address range */ void setReadOnly(AddressRange range); /** * Get number of available memory banks. * * @return count of memory banks */ int getBanksCount(); /** * Get index of the selected memory bank. * * @return index of active (selected) memory bank */ short getSelectedBank(); /** * Select (set as active) a memory bank. * * @param bankIndex index (number) of a bank which should be selected */ void selectBank(short bankIndex); /** * Return an address in the memory which represents a boundary from which * the memory banks have the same content. Before this address all banks * can have different content. * * @return common boundary address */ int getCommonBoundary(); } .",
    "url": "/documentation/user/altair8800/standard-mem",
    "relUrl": "/altair8800/standard-mem"
  }
  ,"40": {
    "title": "CPU z80-cpu",
    "content": "Zilog Z80 CPU emulator . It was possible to upgrade your Altair 8800 computer with a “better” 8-bit processor Zilog Z80. The processor was probably the most used 8-bit processor in 80’s. It was backward compatible with 8080, and brought many enhancements. It was originally targeted for embedded systems, but very soon it become very popular and used for all kinds of computers - including desktop computers, arcade games, etc. Today the CPU is still used in some MP3 players, see e.g. S1 MP3 Player. . Main features of the emulator include: . Interpretation as emulation technique, | Correct real timing of instructions, | Ability to set clock frequency manually at run-time, | Emulation of all instructions including interrupts, | Disassembler implementation, | Ability to “dump” instruction history to console at run-time, | Support of breakpoints, | Ability of communication with up to 256 I/O devices, | Status window shows all registers, flags, and run-time frequency. | . Configuration file . The following table shows all the possible settings of Zilog Z80 CPU plugin: . Name Default value Valid values Description . printCode | false | true / false | Whether the emulator should print executed instructions, and its internal state to console (dump) | . printCodeUseCache | false | true / false | If printCode is set to true, then a cache will be used which remembers already visited blocks of code so the instruction dump will not be bloated with infinite loops | . Dumping executed instructions . The CPU offers a quite unique feature, which is the ability to dump executed instructions as a sequence to the console. When enabled, then each executed instruction - together with content of flags and registers values after the execution are printed. This feature might be extremely useful in two cases: . Reverse engineering of some unknown software | It allows to build tools for automatic checking of register values during the emulation, when performing automatic emulation. | In order to enable this feature, please see the section “Configuration file”. . For example, let’s take one of the examples which computes a reverse text: . ; Print reversed text org 1000 dec sp ; stack initialization (0FFFFh) ld hl,text1 call putstr ; print text1 ld de,input ; address for string input call getline ; read from keyboard ld bc,input ld d,0 ; chars counter char_loop: ld a, (bc) inc bc ; bc = bc+1 cp 10 ; end of input? jp z, char_end cp 13 jp z, char_end inc d ; d =d+1 jp char_loop char_end: dec bc ; bc = bc-1 dec bc call newline char2_loop: ld a, (bc) call putchar dec bc dec d jp z, char2_end jp char2_loop char2_end: halt include &quot;include getchar.inc&quot; include &quot;include getline.inc&quot; include &quot;include putstr.inc&quot; include &quot;include putchar.inc&quot; include &quot;include newline.inc&quot; text1: db &quot;Reversed text ...&quot;,10,13,&quot;Enter text: &quot;,0 text2: db 10,13,&quot;Reversed: &quot;,0 input: ds 30 . When the program is being run, and the dump instructions feature is turned on, on console you can see the following output: . 0000 | PC=03e8 | dec SP | 3B || regs=00 00 00 00 00 00 00 00 IX=0000 IY=0000 IFF=0 I=00 R=01 | flags= | SP=ffff | PC=03e9 0001 | PC=03e9 | ld HL, 485 | 21 85 04 || regs=00 00 00 00 04 85 00 00 IX=0000 IY=0000 IFF=0 I=00 R=02 | flags= | SP=ffff | PC=03ec 0002 | PC=03ec | call 46D | CD 6D 04 || regs=00 00 00 00 04 85 00 00 IX=0000 IY=0000 IFF=0 I=00 R=03 | flags= | SP=fffd | PC=046d 0002 | PC=046d | ld A, (HL) | 7E || regs=00 00 00 00 04 85 00 52 IX=0000 IY=0000 IFF=0 I=00 R=04 | flags= | SP=fffd | PC=046e 0003 | PC=046e | inc HL | 23 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=05 | flags= | SP=fffd | PC=046f 0003 | PC=046f | cp 0 | FE 00 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=06 | flags= N | SP=fffd | PC=0471 0007 | PC=0471 | ret Z | C8 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=07 | flags= N | SP=fffd | PC=0472 0008 | PC=0472 | out (11),A | D3 11 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=08 | flags= N | SP=fffd | PC=0474 0008 | PC=0474 | jp 46D | C3 6D 04 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=09 | flags= N | SP=fffd | PC=046d 0009 | PC=046d | ld A, (HL) | 7E || regs=00 00 00 00 04 86 00 65 IX=0000 IY=0000 IFF=0 I=00 R=0a | flags= N | SP=fffd | PC=046e 0025 | Block from 0474 to 03EF; count=184 0025 | PC=03ef | ld DE, 4B2 | 11 B2 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=42 | flags= Z N | SP=ffff | PC=03f2 0025 | PC=03f2 | call 428 | CD 28 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=43 | flags= Z N | SP=fffd | PC=0428 0025 | PC=0428 | ld C, 0 | 0E 00 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=44 | flags= Z N | SP=fffd | PC=042a 0026 | PC=042a | in A, 10 | DB 10 || regs=00 00 04 b2 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=45 | flags= Z N | SP=fffd | PC=042c 0026 | PC=042c | and 1 | E6 01 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=46 | flags= ZHP | SP=fffd | PC=042e 0026 | PC=042e | jp Z, 42A | CA 2A 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=47 | flags= ZHP | SP=fffd | PC=042a 0027 | PC=042a | in A, 10 | DB 10 || regs=00 00 04 b2 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=48 | flags= ZHP | SP=fffd | PC=042c 6323 | Block from 042E to 0431; count=1048716 6323 | PC=0431 | in A, 11 | DB 11 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=54 | flags= H | SP=fffd | PC=0433 6323 | PC=0433 | cp D | FE 0D || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=55 | flags= N | SP=fffd | PC=0435 6324 | PC=0435 | jp Z, 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=56 | flags= N | SP=fffd | PC=0438 6324 | PC=0438 | cp A | FE 0A || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=57 | flags= N | SP=fffd | PC=043a 6324 | PC=043a | jp Z, 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=58 | flags= N | SP=fffd | PC=043d 6324 | PC=043d | cp 8 | FE 08 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=59 | flags= N | SP=fffd | PC=043f 6324 | PC=043f | jp NZ, 459 | C2 59 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5a | flags= N | SP=fffd | PC=0459 6324 | PC=0459 | out (11),A | D3 11 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5b | flags= N | SP=fffd | PC=045b 6324 | PC=045b | ld (DE), A | 12 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5c | flags= N | SP=fffd | PC=045c 6324 | PC=045c | inc DE | 13 || regs=00 00 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5d | flags= N | SP=fffd | PC=045d 6325 | PC=045d | inc C | 0C || regs=00 01 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5e | flags= | SP=fffd | PC=045e 6325 | PC=045e | jp 42A | C3 2A 04 || regs=00 01 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5f | flags= | SP=fffd | PC=042a 6325 | PC=042a | in A, 10 | DB 10 || regs=00 01 04 b3 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=60 | flags= | SP=fffd | PC=042c 8683 | Block from 045E to 0461; count=440826 8683 | PC=0461 | ld A, A | 3E 0A || regs=00 04 04 b6 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5a | flags= ZH N | SP=fffd | PC=0463 8683 | PC=0463 | ld (DE), A | 12 || regs=00 04 04 b6 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5b | flags= ZH N | SP=fffd | PC=0464 8683 | PC=0464 | inc DE | 13 || regs=00 04 04 b7 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5c | flags= ZH N | SP=fffd | PC=0465 8683 | PC=0465 | ld A, D | 3E 0D || regs=00 04 04 b7 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5d | flags= ZH N | SP=fffd | PC=0467 8683 | PC=0467 | ld (DE), A | 12 || regs=00 04 04 b7 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5e | flags= ZH N | SP=fffd | PC=0468 8684 | PC=0468 | inc DE | 13 || regs=00 04 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5f | flags= ZH N | SP=fffd | PC=0469 8684 | PC=0469 | ld A, 0 | 3E 00 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=60 | flags= ZH N | SP=fffd | PC=046b 8684 | PC=046b | ld (DE), A | 12 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=61 | flags= ZH N | SP=fffd | PC=046c 8684 | PC=046c | ret | C9 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=62 | flags= ZH N | SP=ffff | PC=03f5 8684 | PC=03f5 | ld BC, 4B2 | 01 B2 04 || regs=04 b2 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=63 | flags= ZH N | SP=ffff | PC=03f8 8684 | PC=03f8 | ld D, 0 | 16 00 || regs=04 b2 00 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=64 | flags= ZH N | SP=ffff | PC=03fa 8684 | PC=03fa | ld A, (BC) | 0A || regs=04 b2 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=65 | flags= ZH N | SP=ffff | PC=03fb 8684 | PC=03fb | inc BC | 03 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=66 | flags= ZH N | SP=ffff | PC=03fc 8684 | PC=03fc | cp A | FE 0A || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=67 | flags= N | SP=ffff | PC=03fe 8684 | PC=03fe | jp Z, 40A | CA 0A 04 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=68 | flags= N | SP=ffff | PC=0401 8684 | PC=0401 | cp D | FE 0D || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=69 | flags= N | SP=ffff | PC=0403 8685 | PC=0403 | jp Z, 40A | CA 0A 04 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6a | flags= N | SP=ffff | PC=0406 8685 | PC=0406 | inc D | 14 || regs=04 b3 01 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6b | flags= | SP=ffff | PC=0407 8685 | PC=0407 | jp 3FA | C3 FA 03 || regs=04 b3 01 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6c | flags= | SP=ffff | PC=03fa 8685 | PC=03fa | ld A, (BC) | 0A || regs=04 b3 01 b8 04 a5 00 68 IX=0000 IY=0000 IFF=0 I=00 R=6d | flags= | SP=ffff | PC=03fb 8685 | Block from 0407 to 040A; count=28 8685 | PC=040a | dec BC | 0B || regs=04 b6 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=09 | flags= ZH N | SP=ffff | PC=040b 8685 | PC=040b | dec BC | 0B || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0a | flags= ZH N | SP=ffff | PC=040c 8685 | PC=040c | call 47A | CD 7A 04 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0b | flags= ZH N | SP=fffd | PC=047a 8685 | PC=047a | ld A, A | 3E 0A || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0c | flags= ZH N | SP=fffd | PC=047c 8686 | PC=047c | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0d | flags= ZH N | SP=fffb | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0e | flags= ZH N | SP=fffb | PC=0479 8686 | PC=0479 | ret | C9 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0f | flags= ZH N | SP=fffd | PC=047f 8686 | PC=047f | ld A, D | 3E 0D || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=10 | flags= ZH N | SP=fffd | PC=0481 8686 | PC=0481 | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=11 | flags= ZH N | SP=fffb | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=12 | flags= ZH N | SP=fffb | PC=0479 8686 | Block from 0481 to 0484; count=2 8686 | PC=0484 | ret | C9 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=14 | flags= ZH N | SP=ffff | PC=040f 8686 | PC=040f | ld A, (BC) | 0A || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=15 | flags= ZH N | SP=ffff | PC=0410 8686 | PC=0410 | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=16 | flags= ZH N | SP=fffd | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=17 | flags= ZH N | SP=fffd | PC=0479 8686 | Block from 0410 to 0413; count=2 8686 | PC=0413 | dec BC | 0B || regs=04 b4 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=19 | flags= ZH N | SP=ffff | PC=0414 8687 | PC=0414 | dec D | 15 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1a | flags= H N | SP=ffff | PC=0415 8687 | PC=0415 | jp Z, 41B | CA 1B 04 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1b | flags= H N | SP=ffff | PC=0418 8687 | PC=0418 | jp 40F | C3 0F 04 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1c | flags= H N | SP=ffff | PC=040f 8687 | PC=040f | ld A, (BC) | 0A || regs=04 b4 03 b8 04 a5 00 6f IX=0000 IY=0000 IFF=0 I=00 R=1d | flags= H N | SP=ffff | PC=0410 8687 | Block from 0418 to 041B; count=23 8687 | PC=041b | halt | 76 || regs=04 b1 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=34 | flags= ZH N | SP=ffff | PC=041c . The dump format consists of lines, each line represents one instruction execution. The line is separated by | chars, splitting it into so-called sections. Sections before the sequence || represent state before instruction execution, and sections after it represent the state after instruction execution. Particular sections are described in the following table. . Column Description . 1 | Timestamp from program start (seconds) | . 2 | Program counter before instruction execution | . 3 | Disassembled instruction | . 4 | Instruction opcodes | .   | Now follows the state after instruction execution | . 5 | Register values (B, C, D, E, H, L, reserved (always 0), A) | . 6 | Flags | . 7 | Stack pointer register (SP) | . 8 | Program counter after instruction execution | .",
    "url": "/documentation/user/altair8800/z80-cpu",
    "relUrl": "/altair8800/z80-cpu"
  }
  
}