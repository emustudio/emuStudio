<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <title>emuStudio Application - User documentation for emuStudio 0.40</title> <link rel="shortcut icon" href="/documentation/user/0.40/favicon.ico" type="image/x-icon"> <link rel="stylesheet" href="/documentation/user/0.40/assets/css/just-the-docs.css"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-3492956-5"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', "UA-3492956-5"); </script> <script type="text/javascript" src="/documentation/user/0.40/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="/documentation/user/0.40/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.6.1 --> <title>emuStudio Application | User documentation for emuStudio 0.40</title> <meta name="generator" content="Jekyll v3.8.5" /> <meta property="og:title" content="emuStudio Application" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="User documentation for emuStudio 0.40. emuStudio is universal emulation platform and framework targeting mainly academic sphere." /> <meta property="og:description" content="User documentation for emuStudio 0.40. emuStudio is universal emulation platform and framework targeting mainly academic sphere." /> <link rel="canonical" href="/documentation/user/0.40/application/" /> <meta property="og:url" content="/documentation/user/0.40/application/" /> <meta property="og:site_name" content="User documentation for emuStudio 0.40" /> <script type="application/ld+json"> {"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/documentation/user/0.40/assets/logo-1.svg"}},"description":"User documentation for emuStudio 0.40. emuStudio is universal emulation platform and framework targeting mainly academic sphere.","@type":"WebPage","url":"/documentation/user/0.40/application/","headline":"emuStudio Application","@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="link" viewBox="0 0 16 16"> <title>Link</title> <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path> </symbol> </svg> <div class="page-wrap"> <div class="side-bar"> <div class="site-header"> <a href="/documentation/user/0.40" class="site-title lh-tight"> <div class="site-logo"></div> </a> <button class="menu-button fs-3 js-main-nav-trigger" data-text-toggle="Hide" type="button">Menu</button> </div> <div class="navigation main-nav js-main-nav"> <nav role="navigation" aria-label="Main navigation"> <ul class="navigation-list"><li class="navigation-list-item active"><a href="/documentation/user/0.40/404.html" class="navigation-list-link"></a></li><li class="navigation-list-item active"><a href="/documentation/user/0.40/" class="navigation-list-link"></a></li><li class="navigation-list-item"><a href="/documentation/user/0.40/introduction/" class="navigation-list-link">Introduction</a></li><li class="navigation-list-item active"><a href="/documentation/user/0.40/application/" class="navigation-list-link active">emuStudio Application</a><ul class="navigation-list-child-list "></ul></li></ul> </nav> </div> <footer class="site-footer"> <p class="text-small text-grey-dk-000 mb-4">This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</p> </footer> </div> <div class="main-content-wrap js-main-content" tabindex="0"> <div class="main-content"> <div class="page-header js-page-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" class="js-search-input search-input" tabindex="0" placeholder="Search User documentation for emuStudio 0.40" aria-label="Search User documentation for emuStudio 0.40" autocomplete="off"> <svg width="14" height="14" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg" class="search-icon"><title>Search</title><g fill-rule="nonzero"><path d="M17.332 20.735c-5.537 0-10-4.6-10-10.247 0-5.646 4.463-10.247 10-10.247 5.536 0 10 4.601 10 10.247s-4.464 10.247-10 10.247zm0-4c3.3 0 6-2.783 6-6.247 0-3.463-2.7-6.247-6-6.247s-6 2.784-6 6.247c0 3.464 2.7 6.247 6 6.247z"/><path d="M11.672 13.791L.192 25.271 3.02 28.1 14.5 16.62z"/></g></svg> </div> <div class="js-search-results search-results-wrap"></div> </div> <ul class="list-style-none text-small aux-nav"> <li class="d-inline-block my-0"><a href="/">Back to website</a></li> </ul> </div> <div class="page"> <div id="main-content" class="page-content" role="main"> <p>[[XIB]] == Introduction</p> <p>Various computers can be emulated. Real computers are assembled using hardware components, which are in the virtual environment represented by plug-ins. All virtual computers in emuStudio can have a compiler, must have one CPU and memory. Devices are optional. The virtual computer model is very similar to von Neumann model.</p> <p>Plug-ins combinations and computer settings are written in configuration files. Each file represents one single computer. These configurations can be created manually (they’re Java properties files), but more convenient is the abstract schema editor.</p> <p>Source code editor enables users to write programs for emulated computer. Very related part is compiler, which provides lexical and syntax analysis of the source code for the syntax highlighting. Most compiler plug-ins enable direct transfer of the written code into emulated computer.</p> <p>Memory plug-ins allow modification of its content, which is immediately seen by CPU.</p> <p>There exist command line interface which allows automation of emulation. It is useful for running programs without graphical interface - some devices allow gathering input and writing output from/to files.</p> <p>Errors, and other messages are written in log file. If there is some problem, user can check the log file, or pass it to the issue for analysis by developers of emuStudio.</p> <p>[[XII]] == Installation and run</p> <p>At first, please download emuStudio distribution. It is a ZIP file in the form <code class="language-plaintext highlighter-rouge">emuStudio-[VERSION].zip</code>. Unpack the file where you want to have emuStudio installed.</p> <p>NOTE: please don’t forget to install Java Runtime Environment (JRE) of version 8 and later.</p> <p>After unzipping, go to the directory where <code class="language-plaintext highlighter-rouge">emuStudio.jar</code> is located, and run it with command from command line:</p> <p>…. java -jar emuStudio.jar ….</p> <p>[[XIID]] === Directory structure</p> <p>emuStudio has very conservative and strict directory structure, as can be seen in the following list:</p> <ul> <li><code class="language-plaintext highlighter-rouge">config/</code>: location of configuration files. Each file represents abstract schema of one virtual (emulated) computer.footnote:[The name of the file is the name of the computer, which is not very good idea.] The files are human-readable.footnote:[Format of the files is http://en.wikipedia.org/wiki/.properties[Java properties].]</li> <li><code class="language-plaintext highlighter-rouge">compilers/</code>: location of compiler plug-ins.</li> <li><code class="language-plaintext highlighter-rouge">cpu/</code>: location of CPU plug-ins.</li> <li><code class="language-plaintext highlighter-rouge">devices/</code>: location of device plug-ins.</li> <li><code class="language-plaintext highlighter-rouge">mem/</code>: location of memory plug-ins.</li> <li><code class="language-plaintext highlighter-rouge">lib/</code>: location of shared libraries.</li> </ul> <p>If you want to use a custom virtual computer in emuStudio, it’s plug-ins and shared libraries must be put into appropriate subdirectories. Then, the abstract schema editor will find new plug-ins right after fresh start of emuStudio, and they can be used immediately.</p> <p>[[XC]] == Command line arguments</p> <p>emuStudio accepts several command line arguments. Their description is accessible with <code class="language-plaintext highlighter-rouge">--help</code> argument:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ java -jar emuStudio.jar --help
emuStudio will accept the following command line parameters:

--config name : load configuration with file name
--input name  : use the source code given by the file name
--output name : output compiler messages into this file name
--auto        : run the emulation automation
--nogui       : try to not show GUI in automation
--help        : output this message
</code></pre></div></div> <p>Most of these arguments are self-explanatory. Some of them have meaning only when emulation automation is turned on (<code class="language-plaintext highlighter-rouge">--nogui</code>). For more information, please refer to section «XA».</p> <p>[[XA]] == Automatic emulation</p> <p>Automatic emulation is a feature in which user should be able to run the emulation in a non-interactive mode, i.e. without any intervention. The emulation is being run from the command line and user just watches until it finishes. At the end, he collects logs and/or output files generated by plug-ins. He can then parse them and analyze them.</p> <p>The feature has to be supported by individual plug-ins, so they will respect the settings from command line. Please refer to the plug-ins’ documentation for these details.</p> <p>Every input must be prepared before the run and passed by command line. Example of running automatic emulation is as follows:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java -jar emuStudio.jar --auto --nogui --config "MITS Altair8800" --input example.asm --output compiler.txt
</code></pre></div></div> <p>Command line argument <code class="language-plaintext highlighter-rouge">--auto</code> turns on the automatic emulation. If no other argument is provided, emuStudio will start as usual by asking to open a virtual computer. But after this step it will run the emulation with the settings as they appear in the computer configuration file (no source code compilation is performed).</p> <p>The <code class="language-plaintext highlighter-rouge">--nogui</code> parameter tells to emuStudio that we don’t want to use GUI (graphical user interface) at all. In that case, we must provide a virtual computer in the command line (using <code class="language-plaintext highlighter-rouge">--config</code> argument).</p> <p>NOTE: The plug-ins get the <code class="language-plaintext highlighter-rouge">--nogui</code> (as well as <code class="language-plaintext highlighter-rouge">--auto</code>) setting in the initialization phase, but it’s up to them if they will respect it. Whether they do or not should be in the documentation for the plug-ins you use.</p> <p>=== Analyzing the results</p> <p>An important part of the analysis of result of the automatic emulation is the log saying what happened. By default, each run of automatic emulation creates (overwrites) a log file called <code class="language-plaintext highlighter-rouge">automation.html</code>, located in the root where <code class="language-plaintext highlighter-rouge">emuStudio.jar</code> file is.</p> <p>The log file is in HTML format as you might suggest and contains common messages organized in a table. By default, each row of the table contains:</p> <ul> <li>a start datetime of the emulation,</li> <li>relative time (in milliseconds) since the emulation started,</li> <li>message level</li> <li>the message itself</li> </ul> <p>Usually, the first message is about which computer has been loaded. The second phase is compilation of the source code, if it is provided (by the <code class="language-plaintext highlighter-rouge">--input</code> argument in the command line). This should be logged, too. The next phase is the emulation itself and involves not much details in the log. Usually the most important messages are those if everything went fine, and the log file tries to keep it that simple. The final messages just say that the automatic emulation has finished and the state how it finished.</p> <p>The log file format, and columns of the table can be of course customized, see section «XLC» for more details.</p> <p>[[XO]] == Opening a computer</p> <p>The first action which emuStudio does is loading a computer to be emulated. Virtual computers are described in abstract schemas, which are stored in configuration files (see «XIID» section).</p> <p>Computers can be loaded either from «XC,command line» or manually in GUI (by default). The open dialog is the first thing which appears to a user.</p> <p>image::{imagepath}/open-dialog.png[“Open a computer” dialog]</p> <p>Left part contains a control panel and a list of all available virtual computers. When a user clicks at a computer, it’s abstract schema is displayed on the right. Double-clicking or clicking on the <code class="language-plaintext highlighter-rouge">Open</code> button loads selected computer.</p> <p>[[XOM]] === Managing virtual computers</p> <p>image::{imagepath}/open-dialog-panel.png[Managing virtual computers]</p> <ul> <li><em>A</em>: Adds new computer. The abstract schema editor will be opened.</li> <li><em>B</em>: Deletes selected computer. Be aware of what you are doing - the action cannot be undone.</li> <li><em>C</em>: Edits selected computer. The abstract schema editor will be opened.</li> <li><em>D</em>: Saves the displayed abstract schema into image file.</li> </ul> <p>[[XOA]] === Abstract schema editor</p> <p>Abstract schema editor is a graphical editor for drawing abstract schemas of virtual computers for emulation in emuStudio. Users pick plug-ins which appear as “boxes” or elements on the screen. Then using connection lines those elements can be connected together to express a relation (that they can “see” each other).</p> <p>When the abstract schema is completed, user must save it and then it will appear in the «XOM» dialog.</p> <p>image::{imagepath}/schema-editor.png[Abstract schema editor]</p> <p>Description of the control panel follows.</p> <p>image::{imagepath}/schema-editor-panel.png[Control panel in the abstract schema editor]</p> <ul> <li><em>A</em>: Save the virtual computer.</li> <li><em>B</em>: Select a compiler.</li> <li><em>C</em>: Select a CPU.</li> <li><em>D</em>: Select a memory.</li> <li><em>E</em>: Select a device.</li> <li><em>F</em>: Use a connection line. The line is bidirectional by default.</li> <li><em>G</em>: Set or unset the connection line to be bidirectional. If the line is not bidirectional, the source direction is the first clicked element and the target direction is the second clicked element.</li> <li><em>H</em>: Remove an element from the schema.</li> <li><em>I</em>: This drop-down list is used for selecting specific plug-in (element) in the abstract schema. See icons <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">C</code>, <code class="language-plaintext highlighter-rouge">D</code>, and <code class="language-plaintext highlighter-rouge">E</code>. Those names are just file names of plug-ins located in corresponding directory (see «XIID» section).</li> <li><em>J</em>: Use / do not use a grid in the editor. Elements are “snapped” to the grid if it is used and it’s easier to draw the schema which looks good. The slider on the right then controls density of the grid. The density is saved in the configuration file of the edited computer.</li> </ul> <p>NOTE: Virtual computers in emuStudio are following von-Neumann model of computers. It means that each computer must have a CPU, and memory. Optionally one or more devices, and optionally a compiler.footnote:[The compiler is not really a computer component, but since it also can be interconnected to other components, it is part of the abstract schema.]</p> <p>==== Connection lines</p> <p>Connection line represents virtual “connection” between computer components. For the abstract schema it’s not important how the connection is realized. It’s safe to say that the connection is similar as if we say that a component “sees” the other component, in the direction of the arrow:</p> <p>image::{imagepath}/connection.png[CPU “sees” operating memory, but not vice-versa]</p> <p>In the previous image, a CPU “sees” the memory, but not vice-versa. It means, CPU can read/write from/to memory, but memory is not seeing it, it can just answer to CPU requests. This connection makes sense in real-world computers.</p> <p>Drawing connection lines is very easy. Connection line always connects exactly two elements in the schema. At first, user must click on already existing element in the schema. It’s just a click, not a drag.</p> <p>Then a grey temporary line is being drawn having its end at the mouse position and moving with the mouse move. If the element is not really close, user can make a “path” by clicking somewhere in the schema. At those locations fixed-points are created.</p> <p>When a user clicks at the second element, the temporary line disappears, and real connection line is created.</p> <p>User can find the fixed-points later and move them by dragging. They can be removed by clicking at them with right button of the mouse.</p> <p>==== Accessing settings of plug-ins</p> <p>Each plug-in in the abstract schema can have its own “hidden” settings, which are used by particular plug-in. Most of these settings can be set in a “Settings” window accessible from Emulator panel -&gt; Peripheral devices window. However, plug-ins save their settings directly into the configuration file. The format of the file is http://en.wikipedia.org/wiki/.properties[Java properties file].</p> <p>Settings of particular plug-in can be accessed by clicking on the plug-in in the Abstract schema editor with the right mouse button.</p> <p>For example, the following image shows the settings of the plug-in <code class="language-plaintext highlighter-rouge">standard-mem</code>:</p> <p>image::{imagepath}/schema-editor-settings.png[“Hidden” settings of Standard operating memory plug-in]</p> <p>It is possible to Add, Remove or Save the settings. Please refer for particular plug-ins which settings they support.</p> <p>[[XM]] == Main window</p> <p>[[XMB]] === Brief description</p> <p>Main window the core part of emuStudio application. Users will spend there most of the time while working with emuStudio. It is part of the main module. Main module is a separated application developed independently from plug-ins.</p> <p>The content of the window is split into two panels or tabs, placeholders for two actions users can do in emuStudio. The first tab is «XMS,source code editor», second is «XME,emulator», used during computer emulation.</p> <p>[[XMS]] === Source code editor</p> <p>image::{imagepath}/source-code.png[Source code tab]</p> <p>In the source code editor, users can write programs for emulated computer. However, the most important tool which allows translation of the source code into binary program readable by emulated CPU is a compiler. Therefore, users must use the right compiler.</p> <p>Input language of a compiler is not limited, it can be either a kind of assembler, or even C or Pascal language. It depends on the compiler implementation, there can be many. The only restriction is that compiler must have output which is compatible with CPU which is currently being emulated. This cannot be checked automatically, users must take care of this.</p> <p>Source code editor supports only the basic features, such as line numbering and syntax highlighting. Also, there is possibility to search/replace text.</p> <p>Compilation must be run manually. Compiler output window shows all messages which compiler produces. The content is dependant on the used compiler, but most likely it will contain compilation success or errors messages.</p> <p>Compiled source code can produce output binary file (for example a HEX file), and it’s automatically loaded into the operating memory.footnote:[If the used compiler supports it]. If the emulation is running, user must stop it first manually.</p> <p>If another program is loaded in memory, it is not removed before loading currently compiled program, but the memory is overwritten at only those locations relevant to the compiled program. All the other content is left unchanged.</p> <p>[[XME]] === Emulating a computer</p> <p><em>Emulator tab</em> is shown in the following image. It is currently open with MITS Altair8800 computer with Intel 8080 CPU, and several devices:</p> <p>image::{imagepath}/emulator.png[Emulator tab]</p> <p>The tab contains three main parts. The first one is very useful - listing of operating memory, disassembled into instructions. This part is called a debugger window, or “debugger”. The other part, below the debugger window is a list of all computer devices used (“peripheral devices”).footnote:[With double-click user can open GUI window of that particular device, if it supports it.]</p> <p>The last part on the right displays status of the CPU used in this computer. Each CPU has its own implementation of how the status window look and what it displays.</p> <p>[[XMEE]] ==== Emulation lifecycle</p> <p>In real world, users control the power of computer. Computers can be turned on, or turned off if it is running, basically by pressing a button. It’s obvious that we can turn on only not running or stopped computer. The power state is a term which denotes whether the computer is turned on or off. Each of those states define possible transitions to the other power state, executed by the action - pressing a button.</p> <p>Computer behaves according to the power state in which it is. If it’s in a running state, it runs and we can see something on screen. If not, it is quiet and does nothing.</p> <p>In emuStudio, emulation of a virtual computer can be controlled very similarly. In addition to basic <em>run</em> (turn on), <em>stop</em> (turn off) actions and stopped/running states, emulation work-flow in emuStudio allows <em>reset</em> and <em>pause</em> actions (plus paused state).</p> <p>Emulation can be ready to run (the same as paused), running, or stopped. Each state has defined possible transitions to another states, by already mentioned actions. It’s possible to show those transitions in a state diagram, as in the following image:</p> <h2 id="graphvizemulation-statessvg"> <a href="#graphvizemulation-statessvg" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#link"></use></svg></a> [graphviz,emulation-states,svg] </h2> <p>digraph emulation_states { ratio = 1; node [shape = rect];</p> <p>ready [ style = filled, fillcolor=lightgrey ]; stopped [shape = doubleoctagon ];</p> <p>ready -&gt; running [ label = “run “ ]; ready -&gt; stopped [ label = “stop “ ]; ready -&gt; ready [ label = “step “, headport=w]; running -&gt; stopped [ label = “stop, error “ ]; running -&gt; ready [ label = “pause, reset “ ]; stopped -&gt; ready [ label = “reset “]; } ———————————————————————</p> <p>NOTE: This workflow applies to emulation of a whole computer. Independent emulation of devices or other computer components cannot be controlled. The emulation of a computer starts when the CPU starts interpreting and executing instructions.</p> <p>[[XMED]] ==== Debugger window</p> <p>Debugging is a process in which a programmer tries to analyze a program, usually with the intent to find bugs.footnote:[The adverb “to debug” has a deep history. Very early computers were having of so-called vacuum tubes, which were core elements acting as electrically controlled switches. From time to time a computer stopped working, and the most usual reason was that a bug (real one) came in a vacuum tube. Maintainers of the computer had to go there and manually remove the bug. It happened that often, so that the process of removing bugs got a name - “to de-bug”.] Debugger in emuStudio contains a debugger toolbar and list of few disassembled instructions from memory. In combination with CPU status panel, it’s the most powerful tool for seeing (and checking) all internal behavior of the emulated computer.</p> <p>[[XMET]] ==== Debugger toolbar</p> <p>Debugger toolbar contains buttons (icons) for controlling the emulation and accessing memory content. Most of these buttons are self-explanatory. If you hover over those icons, a help text is displayed of how to use the icon.</p> <p>image::{imagepath}/debugger-toolbar.png[Debugger toolbar]</p> <ul> <li><em>A</em>: Reset emulation.</li> <li><em>B</em>: Set next instruction position to 0. CPU will perform the next instruction from there.</li> <li><em>C</em>: Set next instruction position to the <code class="language-plaintext highlighter-rouge">(current - 1)</code>. This action can completely change displaying of instructions, since the new instruction position does not have to be correct in term of executing the current program.</li> <li><em>D</em>: Stop emulation (which is either running or paused).</li> <li><em>E</em>: Pause emulation (which is running).</li> <li><em>F</em>: Run emulation (which is paused).</li> <li><em>G</em>: Run emulation with timer (which is paused). Instructions are executed after elapsing specified time interval. A dialog will appear to enter the time interval.</li> <li><em>H</em>: Step emulation (which is paused). CPU will execute only one - the very next - instruction.</li> <li><em>I</em>: Jump to location. User will manually specify location (address in memory) for the next instruction to execute.</li> <li><em>J</em>: Set/unset breakpoint. User can set or unset a breakpoint on specific memory location. When CPU reaches the breakpoint, it will pause there, waiting for next user action.</li> <li><em>K</em>: Show operating memory. If the memory plug-in does not have a GUI, the icon is disabled.</li> </ul> <p>[[XMEL]] ==== List of instructions</p> <p>The largest part of the debugger window a list of few disassembled instructions, so-called <em>instructions window</em>.footnote:[Around 15 instructions are shown, but it depends on the CPU] They are arranged in a table. The first column is usually interactive, allowing user to set breakpoints. Red strip is pointing to the very next instruction being executed.</p> <p>NOTE: The size of disassembled memory (resulting in the number of disassembled instructions) is not configurable. Also, user cannot change instructions in this place.</p> <p>Sometimes the instructions shown in the debugger do not have to be disassembled correctly. There are two reasons for that:</p> <ul> <li>first, instructions can have various binary sizes (e.g. one byte, two bytes, etc.)</li> <li>second, memory can contain programs on various locations, and emuStudio doesn’t know where. footnote:[Well, if it’s just program compiled from the source code editor, it knows.]</li> </ul> <p>The implication is that if emuStudio starts to disassemble instructions at wrong location, the instructions will be disassembled incorrectly, or they can appear as invalid.</p> <p>However, emuStudio is trying hard to find the nearest program start location at which it’s safe to start disassembling. Usually it’s just few instructions back, so it is a fast process.</p> <p>[[XMEC]] ==== Controlling of displaying the instructions</p> <p>It’s possible to change the current instructions view. The window can be moved in a per-page fashion. The amount of instructions displayed in the window is always preserved. With the toolbar below the list it’s possible to change “pages” of the displayed instructions.</p> <p>image::{imagepath}/instructions-panel.png[Controlling instructions window]</p> <ul> <li><em>A</em>: Go to the first page. The very first row corresponds to instruction position 0.</li> <li><em>B</em>: Go backwards. User will specify the number of pages for going back.</li> <li><em>C</em>: Go to the previous page.</li> <li><em>D</em>: Go to the page where current instruction position is.</li> <li><em>E</em>: Go to the next page.</li> <li><em>F</em>: Go forwards. User will specify the number of pages for going forward.</li> <li><em>G</em>: Go to the last page. It can cause incorrectly displaying of instructions.</li> </ul> <p>[[XLC]] == Logger configuration</p> <p>This is an advanced topic, but you might need it if something goes wrong. No software is bug-free in these days, and not a person is perfect. Sometimes it might happen that emuStudio is not working as expected, either it does not start (with weird message on screen), or it fails while running.</p> <p>For that purpose, everything important is being logged (by default) in a console. If you encounter some problem and either want to fix it or report it, the logs, except steps to reproduce are the most important thing.</p> <p>By default, logging is written to the standard output. However, in case of a problem it is a good practice to enable file logging. To enable file logging, open <code class="language-plaintext highlighter-rouge">logback.xml</code> file located in the root directory of emuStudio. Find a section named <code class="language-plaintext highlighter-rouge">&lt;root ..&gt;</code>, and change <code class="language-plaintext highlighter-rouge">appender-ref</code> from <code class="language-plaintext highlighter-rouge">STDOUT</code> to <code class="language-plaintext highlighter-rouge">FILE</code> as follows:</p> <hr /> <root level="debug"> <appender-ref ref="FILE" /> </root><hr /> <p>The log file is named <code class="language-plaintext highlighter-rouge">emuStudio.log</code> and should be located in the location where <code class="language-plaintext highlighter-rouge">emuStudio.jar</code> is located. Every new run of emuStudio will append log messages into that file until emuStudio is terminated.</p> <p>NOTE: By default, a rolling policy is enabled, which deletes logs older than 2 days and keeps the log in maximum size of 1 MB. It is of course configurable.</p> <p>TIP: The log file is the best help about what went wrong for a developer which is trying to analyze or fix the problem. If you have encountered a problem with emuStudio, you should provide the log file for further analysis.</p> <p>Format, file name and content of the log file can be influenced. EmuStudio is using <code class="language-plaintext highlighter-rouge">logback</code> as the logging system. Configuration of the logging mechanism is in the file called <code class="language-plaintext highlighter-rouge">logback.xml</code>. For more information about how to configure loggers, please look at the page http://logback.qos.ch/manual/configuration.html.</p> <hr> <h2 class="text-delta">Table of contents</h2> <ul> </ul> </div> </div> </div> </div> </body> </html>
