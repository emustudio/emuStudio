{
  
  "0": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "/documentation/user/0.40/404.html",
    "relUrl": "/404.html"
  }
  ,"1": {
    "title": "CPU 8080-cpu",
    "content": "Intel 8080 CPU emulator . Altair 8800 originally came with processor Intel 8080. It is 8-bit microprocessor, from 1974. Initial clock frequency was 2 MHZ. This processor was one of the first general-purpose and widespread processors, used not only in calculators but also in first personal computers. One of the key roles why this CPU become so popular is that Gary Killdall targeted his CP/M to this CPU; and CP/M was de facto a &quot;standard&quot; in personal computers those days. . Main features of the emulator include: . Threaded-dispatch combined with interpretation as emulation technique, . | Correct real timing of instructions, . | Ability to set clock frequency manually at run-time, . | Emulation of all instructions including interrupts, . | Disassembler implementation, . | Ability to &quot;dump&quot; instruction history to console at run-time, . | Support of breakpoints, . | Ability of communication with up to 256 I/O devices, . | Status window shows all registers, flags, and run-time frequency. . | . Dumping executed instructions . The CPU offers a quite unique feature, which is the ability to dump executed instructions as a sequence to the console. When enabled, then each executed instruction - together with content of flags and registers values after the execution are printed. This feature might be extremely useful in two cases: . Reverse engineering of some unknown software . | It allows to net.emustudio.architecture.build tools for automatic checking of register values during the emulation, when performing automatic emulation. . | In order to enable this feature, please see the section Configuration file. . For example, let&#8217;s take one of the examples which computes a reverse text: . Example program for reversing text in 8080 assembly ; Print reversed text org 1000 dcx sp ; stack initialization (0FFFFh) lxi h,text1 call putstr ; print text1 lxi d,input ; address for string input call getline ; read from keyboard lxi b,input mvi d,0 ; chars counter char_loop: ldax b inx b ; bc = bc+1 cpi 10 ; end of input? jz char_end cpi 13 jz char_end inr d ; d =d+1 jmp char_loop char_end: dcx b ; bc = bc-1 dcx b call newline char2_loop: ldax b call putchar dcx b dcr d jz char2_end jmp char2_loop char2_end: hlt include &#39;include getchar.inc&#39; include &#39;include getline.inc&#39; include &#39;include putstr.inc&#39; include &#39;include putchar.inc&#39; include &#39;include newline.inc&#39; text1: db &#39;Reversed text ...&#39;,10,13,&#39;Enter text: &#39;,0 text2: db 10,13,&#39;Reversed: &#39;,0 input: ds 30 . When the program is being run, and the dump instructions feature is turned on, on console you can see the following output: . 0000 | PC=03e8 | dcx SP | 3B || regs=00 00 00 00 00 00 00 00 | flags= | SP=ffff | PC=03e9 0001 | PC=03e9 | lxi HL, 485 | 21 85 04 || regs=00 00 00 00 04 85 00 00 | flags= | SP=ffff | PC=03ec 0001 | PC=03ec | call 46D | CD 6D 04 || regs=00 00 00 00 04 85 00 00 | flags= | SP=fffd | PC=046d 0002 | PC=046d | mov A, M | 7E || regs=00 00 00 00 04 85 00 52 | flags= | SP=fffd | PC=046e 0002 | PC=046e | inx HL | 23 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=046f 0003 | PC=046f | cpi 0 | FE 00 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0471 0004 | PC=0471 | rz | C8 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0472 0005 | PC=0472 | out 11 | D3 11 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=0474 0006 | PC=0474 | jmp 46D | C3 6D 04 || regs=00 00 00 00 04 86 00 52 | flags= | SP=fffd | PC=046d 0006 | PC=046d | mov A, M | 7E || regs=00 00 00 00 04 86 00 65 | flags= | SP=fffd | PC=046e 0024 | Block from 0474 to 03EF; count=184 0024 | PC=03ef | lxi DE, 4B2 | 11 B2 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=ffff | PC=03f2 0025 | PC=03f2 | call 428 | CD 28 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=0428 0025 | PC=0428 | mvi C, 0 | 0E 00 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042a 0025 | PC=042a | in 10 | DB 10 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042c 0026 | PC=042c | ani 1 | E6 01 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042e 0026 | PC=042e | jz 42A | CA 2A 04 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042a 0027 | PC=042a | in 10 | DB 10 || regs=00 00 04 b2 04 a5 00 00 | flags= Z P | SP=fffd | PC=042c 1548 | Block from 042E to 0431; count=181125 1548 | PC=0431 | in 11 | DB 11 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0433 1548 | PC=0433 | cpi D | FE 0D || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0435 1548 | PC=0435 | jz 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=0438 1548 | PC=0438 | cpi A | FE 0A || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=043a 1549 | PC=043a | jz 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 68 | flags= | SP=fffd | PC=043d 1549 | PC=043d | cpi 8 | FE 08 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=043f 1549 | PC=043f | jnz 459 | C2 59 04 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=0459 1549 | PC=0459 | out 11 | D3 11 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=045b 1549 | PC=045b | stax DE | 12 || regs=00 00 04 b2 04 a5 00 68 | flags= AP | SP=fffd | PC=045c 1549 | PC=045c | inx DE | 13 || regs=00 00 04 b3 04 a5 00 68 | flags= AP | SP=fffd | PC=045d 1549 | PC=045d | inr C | 0C || regs=00 01 04 b3 04 a5 00 68 | flags= | SP=fffd | PC=045e 1549 | PC=045e | jmp 42A | C3 2A 04 || regs=00 01 04 b3 04 a5 00 68 | flags= | SP=fffd | PC=042a 1550 | PC=042a | in 10 | DB 10 || regs=00 01 04 b3 04 a5 00 00 | flags= | SP=fffd | PC=042c 2940 | Block from 045E to 0461; count=267777 2940 | PC=0461 | mvi A, A | 3E 0A || regs=00 05 04 b7 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0463 2940 | PC=0463 | stax DE | 12 || regs=00 05 04 b7 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0464 2940 | PC=0464 | inx DE | 13 || regs=00 05 04 b8 04 a5 00 0a | flags= ZAP | SP=fffd | PC=0465 2940 | PC=0465 | mvi A, D | 3E 0D || regs=00 05 04 b8 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0467 2940 | PC=0467 | stax DE | 12 || regs=00 05 04 b8 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0468 2940 | PC=0468 | inx DE | 13 || regs=00 05 04 b9 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0469 2940 | PC=0469 | mvi A, 0 | 3E 00 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=fffd | PC=046b 2941 | PC=046b | stax DE | 12 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=fffd | PC=046c 2941 | PC=046c | ret | C9 || regs=00 05 04 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03f5 2941 | PC=03f5 | lxi BC, 4B2 | 01 B2 04 || regs=04 b2 04 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03f8 2941 | PC=03f8 | mvi D, 0 | 16 00 || regs=04 b2 00 b9 04 a5 00 00 | flags= ZAP | SP=ffff | PC=03fa 2941 | PC=03fa | ldax BC | 0A || regs=04 b2 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=03fb 2941 | PC=03fb | inx BC | 03 || regs=04 b3 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=03fc 2941 | PC=03fc | cpi A | FE 0A || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=03fe 2941 | PC=03fe | jz 40A | CA 0A 04 || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0401 2942 | PC=0401 | cpi D | FE 0D || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0403 2942 | PC=0403 | jz 40A | CA 0A 04 || regs=04 b3 00 b9 04 a5 00 68 | flags= | SP=ffff | PC=0406 2942 | PC=0406 | inr D | 14 || regs=04 b3 01 b9 04 a5 00 68 | flags= | SP=ffff | PC=0407 2942 | PC=0407 | jmp 3FA | C3 FA 03 || regs=04 b3 01 b9 04 a5 00 68 | flags= | SP=ffff | PC=03fa 2942 | PC=03fa | ldax BC | 0A || regs=04 b3 01 b9 04 a5 00 65 | flags= | SP=ffff | PC=03fb 2942 | Block from 0407 to 040A; count=36 2942 | PC=040a | dcx BC | 0B || regs=04 b7 05 b9 04 a5 00 0a | flags= ZAP | SP=ffff | PC=040b 2943 | PC=040b | dcx BC | 0B || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=ffff | PC=040c 2943 | PC=040c | call 47A | CD 7A 04 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047a 2943 | PC=047a | mvi A, A | 3E 0A || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047c 2943 | PC=047c | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffb | PC=0477 2943 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffb | PC=0479 2943 | PC=0479 | ret | C9 || regs=04 b6 05 b9 04 a5 00 0a | flags= ZAP | SP=fffd | PC=047f 2943 | PC=047f | mvi A, D | 3E 0D || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffd | PC=0481 2943 | PC=0481 | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffb | PC=0477 2943 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=fffb | PC=0479 2943 | Block from 0481 to 0484; count=2 2943 | PC=0484 | ret | C9 || regs=04 b6 05 b9 04 a5 00 0d | flags= ZAP | SP=ffff | PC=040f 2944 | PC=040f | ldax BC | 0A || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=ffff | PC=0410 2944 | PC=0410 | call 477 | CD 77 04 || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=fffd | PC=0477 2944 | PC=0477 | out 11 | D3 11 || regs=04 b6 05 b9 04 a5 00 6f | flags= ZAP | SP=fffd | PC=0479 2944 | Block from 0410 to 0413; count=2 2944 | PC=0413 | dcx BC | 0B || regs=04 b5 05 b9 04 a5 00 6f | flags= ZAP | SP=ffff | PC=0414 2944 | PC=0414 | dcr D | 15 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=0415 2944 | PC=0415 | jz 41B | CA 1B 04 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=0418 2944 | PC=0418 | jmp 40F | C3 0F 04 || regs=04 b5 04 b9 04 a5 00 6f | flags= A | SP=ffff | PC=040f 2944 | PC=040f | ldax BC | 0A || regs=04 b5 04 b9 04 a5 00 6c | flags= A | SP=ffff | PC=0410 2945 | Block from 0418 to 041B; count=31 2945 | PC=041b | hlt | 76 || regs=04 b1 00 b9 04 a5 00 68 | flags= ZAP | SP=ffff | PC=041c . The dump format consists of lines, each line represents one instruction execution. The line is separated by | chars, splitting it into so-called sections. Sections before the sequence || represent state before instruction execution, and sections after it represent the state after instruction execution. Particular sections are described in the following table. . Column Description . 8 . | Program counter after instruction execution . | . 1 . | Timestamp from program start (seconds) . | . 2 . | Program counter before instruction execution . | . 3 . | Disassembled instruction . | . 4 . | Instruction opcodes . | . | Now follows the state after instruction execution . | . 5 . | Register values (B,C,D,E,H,L, reserved (always 0), A) . | . 6 . | Flags . | . 7 . | Stack pointer register (SP) . | . Configuration file . Configuration file of virtual computers contain also settings of all the used plug-ins, including CPUs. Please read the section &quot;Accessing settings of plug-ins&quot; in the user documentation of Main module to see how the settings can be accessed. . The following table shows all the possible settings of Intel 8080 CPU plug-in: . Table 1. Settings of Intel 8080 CPU emulator plug-in Name Default value Valid values Description . printCodeUseCache . | false . | true / false . | If printCode is set to true, then a cache will be used which remembers already visited blocks of code so the instruction dump will not be bloated with infinite loops . | . printCode . | false . | true / false . | Whether the emulator should print executed instructions, and its internal state to console (dump) . | .",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/8080-cpu.html",
    "relUrl": "/docs/mits_altair_8800/8080-cpu.html"
  }
  ,"2": {
    "title": "Device 88-disk",
    "content": "Disk controller &quot;88-disk&quot; . Altair Disk offered the advantage of fixed memory including relatively fast access to data. Data were transferred with speed 250 Kb/s (The plug-in does not emulate this). Disk was connected with disk controller (or board), and the data were transferred in serial fashion, bit after bit. . Disk controller, on the other hand communicated with CPU. It transformed these serial data into 8-bit words which were stored/read by CPU into/from operating memory. . MITS 88-DISK offered to connect up to 16 disk devices (one can be seen in the front image in the Introduction section). . | Original manual can be downloaded at this link. | . Features . The plug-in emulates basic functionality of the whole disk system for Altair 8800 computer. It is not only disk controller, but also the disk drive. . The features include: . allows to mount up to 16 disk images . | CPU ports can be set manually . | interrupts are not implemented . | images can be saved for automatic mount at startup . | GUI . | . Mounting disk images . In order to mount DISK images to the device, please go to the Settings window [1]: . A: Select drive (A - P) . | B: Choosing the image file . | C: Set sectors count and sector length for the current drive [2]. . | D: Set default values for sector count and sector length for the current drive. . | E: Mount/unmount the image file onto/from the selected drive. Mount operation: If there is any disk mounted already, the new image will be re-mounted. . | F: Check box for saving the settings into the computer configuration file. If checked, the settings will be loaded after start. . | . CPU Ports settings . MITS 88-DISK board communicates with CPU using its ports. There are three ports overall, each for different function. For more information, see section Programming. By default, the ports used by 88-DISK are: . port 1: 0x08 . | port 2: 0x09 . | port 3: 0x0A . | . These numbers can be changed in the Settings window, tab &quot;CPU Ports&quot;: . Configuration file . Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please read the section &quot;Accessing settings of plug-ins&quot; in the user documentation of Main module to see how the settings can be accessed. . The following table shows all the possible settings of MITS 88-DISK plug-in: . Table 1. Settings of MITS 88-DISK Name Default value Valid values Description . image15 . | N/A . | Path to existing file . | File name to mount on disk P (15) . | . port1CPU . | 0x08 . | &gt; 0 and &lt; 256 . | Number of Port 1 . | . port2CPU . | 0x09 . | &gt; 0 and &lt; 256 . | Number of Port 2 . | . port3CPU . | 0x0A . | &gt; 0 and &lt; 256 . | Number of Port 3 . | . sectorsPerTrack . | 32 . | &gt; 0 . | Count of sectors in a disk image . | . sectorLength . | 137 . | &gt; 0 . | Size of one sector in bytes . | . image0 . | N/A . | Path to existing file . | File name to mount on disk A (0) . | . &#8230;&#8203; . | &#8230;&#8203; . | &#8230;&#8203; . | &#8230;&#8203; . | . Programming . Data are written onto or read from disk in a serial fashion. The position in the floppy disk is uniquely set by the track number, sector number and the offset in the sector. It is rudimentary to know how many tracks are available, so as how many sectors per track and the sector size. . In Altair8800, drive Pertec FD400 used 8&quot; diskettes. Each had 77 tracks. The track had 32 sectors with 137 bytes long. The capacity was therefore 77 * 32 * 137 = 337568 B = 330 kB. Software used less capacity, because 9 bytes from each sector were used for the integrity checksum. . Setting the position . Track number and sector number can be set only incrementally, not directly. Setting the offset within the sector is more challenging. . After track and sector were set, programmer must &quot;poll&quot; the status port which tells him when the disk position is set to the beginning of the sector. Then, programmer must read data until he gets to the position where he wanted. . CPU Ports . The controller communicates with CPU using three I/O ports at addresses (by default) 0x08, 0x09 and 0x0A. The following table shows the CPU ports and how they are used. . Table 2. Summary of CPU ports usage Port Address Input Output . 3 . | 0x0A . | Read data . | Write data . | . 1 . | 0x08 . | Disk and controller status . | Select disk . | . 2 . | 0x09 . | Get number of sector . | Disk settings . | . Now, detailed description of the ports follow. Bits are ordered in a byte as follows: . D7 D6 D5 D4 D3 D2 D1 D0 . where D7 is the most significant bit, and D0 the least significant bit. . Port 1 (default address: 0x08) . WRITE: . Selects and enables one of 16 disk devices. By selecting a drive, all further operations will be performed on that drive. If the disk has not mounted any disk image, all further operations will be ignored. The previously selected device will be disabled. . D7 : if the value is 1, disable the drive. If the value is 0, select and enable the drive. . | D6 D5 D4 : unused bits . | D3 D2 D1 D0: index of the drive to be selected. From 0-15. . | . READ: . Read disk status of the selected drive. . D7 : New read data available. Indicates if there is at least 1 byte available for reading from Port 3 (value=0). It will be reset after data are read (value=1). If the value is 1, data read from Port 3 will be invalid or no new data is available. . | D6 : Track 0. Indicates if the head is positioned at track 0 (value=0). . | D5 : Interrupt Enabled. Indicates if interrupts are used (value=0). The plug-in does not support interrupts, therefore the value will be always 1. . | D4 D3 : Unused bits; they are always 0. . | D2 : Head Status. Indicates the correctness of the head setting. If the value is 0, reading sector number from Port 2 will be valid. . | D1 : Move head. Indicates if the movement of the disk head is allowed. If the value is 1, all track number changes will be ignored. . | D0 : Enter new write data. Indicates if the device is ready for writing data. If the value is 1, all written data will be ignored. . | . Initial values of the bits are: 11100111. . Port 2 (default address: 0x09) . WRITE: . Control the disk head, and other settings if a disk drive is selected. . D7 : Write Enable. Initializes write sequence (enables writing to the disk; value=1). The plug-in sets the sector number to 0 and also value 0 to bit D0 of Port 1 (Enter new write data) [3]. . | D6 : Head Current Switch. On real disks the bit should be set to 1 when a program is writting data to tracks from 43-76. The plug-in the bit is ignored. . | D5 : Interrupt Disable. Setting is ignored sicne plug-in does not support interrupts. . | D4 : Interrupt Enable. Setting is ignored sicne plug-in does not support interrupts. . | D3 : Head unload. Removes head from the disk surface. Reading sector number will now become invalid. In addition, value of bit D7 from Port 1 (New read data available) become 1 (no new data). . | D2 : Head load. Sets the disk head onto disk surface. Reading sector number now becomes valid. If additionally the bit D7 from Port 1 (New data available) is set, it is possible to read data from the disk. . | D1 : Step Out. Move the disk head back by 1 track (the track number is decremented). It is required to check bit D1 of Port 1 (Move head) to have value 0. . | D0 : Step In. Move the disk head ahead by 1 track (the track number is incremented). It is required to check bit D1 of Port 1 (Move head) to have value 0. . | . READ: . Reads the number of the sector. The value can be read only if a disk drive is selected and the disk head is positioned at the disk surface (by setting the bit D2). . D7 D6 : Unused bits; they are always 1. . | D5 D4 D3 D2 D1: Number of the sector, counted from 0. . | D0 : Sector True. If the value is 0, the offset in sector is 0 [4]. . | . Port 3 (default address: 0x0A) . WRITE: . Write a byte to disk. In order to perform valid write, the Write Enable D7 bit of Port 2 must be set to 1. Before data are written to disk, it is required to check bit D0 from Port 1 (Enter new write data). . READ: . Read a byte from disk. In order to perform valid read, the Head load D2 bit of Port 2 must be set to 1. Only if bit D7 from Port 1 (New read data available) is set to 0, the read data are valid. . Program example . In this section, an example is presented showing how to read/write data from/to the floppy disk. At first, it writes one byte (letter A with ASCII value 65) to track 1, sector 18 and offset 20. Then, it reads the byte to operating memory at address 0x200. . The program uses 3 procedures (in assembler for Intel 8080) for setting the disk position (ltrack for loading the track number, lsector for loading the sector number, and loffset for loading the offset within the sector) and two more for data reading (read) and writing (write). . Example program for writing/reading using MITS 88-DISK disk0 equ 0 ; disk number track equ 1 ; track number sector equ 18 ; sector number offset equ 20 ; offset within the sector data equ &#39;A&#39; ; data for writing dcx sp ; set stack register to 0xFFFF mvi a, disk0 ; select disk out 08h call ltrack ; set track number call we ; set &#39;write enable&#39; sequence call lsector ; set sector number call loffset ; set sector offset call write ; write data call lsector ; set sector number (for clearing the offset) call loffset ; set sector offset call read ; read data lxi h, readdata ; load address for reading the data mov m, a ; move the data there hlt ; end ltrack0: ; the procedure will set track number to 0 in 08h ; read disk status ani 1000000b ; track 0 ? rz ; yes, return mvi a, 1000b ; head unload out 09h call movetrk ; wait until the disk head can be moved mvi a, 10b ; step out, decrement track number out 08h jmp ltrack0 ltrack: ; procedure sets a track number call ltrack0 ; at first, set track number to 0 mvi b, track+1 ; b = track + 1 stepin: ; stepin: { dcr b ; b--; rz ; if (b == 0) return; call movetrk ; wait until the disk head can be moved mvi a, 1 ; step in, increment track number out 09h jmp stepin ; goto stepin; ; } movetrk: ; procedure waits until the disk head can be moved in 08h ; read disk status ani 10b ; can the disk head be moved? jnz movetrk ; nope, try again... ret ; yes, return lsector: ; procedure sets a sector number mvi a, 100b ; head load out 09h waits: in 09h ; read sector number ani 3Fh ; clear unused bits rrc cpi sector ; is the number what is requested? jnz waits ; nope, try again ret ; yes, return loffset: ; procedure sets a sector offset mvi b, offset+1 ; b = offset + 1 stepoff: ; stepoff: { dcr b ; b--; rz ; if (b == 0) return; call read ; read data; the offset is incremented jmp stepoff ; goto stepoff; ; } read: ; procedure reads data from the disk in 08h ; read disk status ani 100b ; check if the disk head is loaded on the disk surface rnz ; if not, return waitr: in 08h ; read disk status ani 10000000b ; New read data available ? jnz waitr ; nope, try again... in 0Ah ; yes, read data ret ; return we: ; procedure enables &#39;write enable&#39; sequence mvi a, 10000000b ; write enable out 09h ret write: ; procedure writes data to the disk in 08h ; read disk status ani 100b ; check if the disk head is loaded on the disk surface rnz ; if not, return waitw: in 08h ; read disk status ani 1 ; enter new write data ? jnz waitw ; nope, try again... mvi a, data ; yes, write data out 0Ah ret org 200h readdata: db 0 . . 1. &quot;peripheral devices&quot; window in the Emulator panel in emuStudio 2. Be cautious with the settings. Incorrect values can result in disk image file damage. Default values are used for classic Altair8800 image files used by simh 3. According to manual the write sequence holds only for short time, maximally until the end of sector is reached. The plug-in does not limit the sequence period, it is deactivated only when the end of the sector is reached. In addition each first byte and the last byte of a sector should have set its MSB (7th bit) to 1. It was called the &quot;sync bit&quot; for easier identification of start or end of a sector. However, the plug-in does not require it. 4. According to manual, the bit is set for maximum 30 microseconds. Programs could detect the bit set and quickly start writing data until the Sector true came back again. It could be made in time easily, because CPU was much faster than disk itself. Plug-in does not limit the period. The value is 0 practically all the time, until first byte is written.",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/88-disk.html",
    "relUrl": "/docs/mits_altair_8800/88-disk.html"
  }
  ,"3": {
    "title": "Device 88-sio",
    "content": "Serial board &quot;88-sio&quot; . Altair 8800 computer was equipped with serial board called 88-SIO, or 88-2 SIO. It was a device which allowed connecting other devices using RS-232 interface. From one side it was attached to CPU on at least two ports (most commonly 0x10 and 0x11). The other side was ended with one or two physical ports (allowing to connect one or two devices). Real board supported both hardware and software interrupts. . The following image shows MITS 88-SIO-2 board. . | Original manual of MITS 88-SIO serial board can be downloaded at this link. | . Features . The plug-in emulates only basic functionality of the board. It has the following features: . allows to connect one device only . | CPU ports can be set manually . | interrupts are not implemented . | setting of transfer speed, parity, number of stop bits is not supported . | GUI . | . CPU Ports settings . MITS 88-SIO board is attached to CPU using multiple ports. By default, the used CPU ports are: . Status port: 0x03, 0x10, 0x14, 0x16, 0x18 (preferred: 0x10) . | Data port: 0x02, 0x11, 0x15, 0x17, 0x19 (preferred: 0x11) . | . The reason why there are multiple &quot;bindings&quot; is that there existed various software which expected specific bindings. The presented default values are the most common ones. . These numbers can be changed in the Settings window: . A: Attach Status SIO port to some new CPU port. The CPU port must be unique among both Status and Data ports attachments. . | B: Detach Status SIO port from selected CPU port. . | C: Attach Data SIO port to some new CPU port. The CPU port must be unique among both Status and Data ports attachments. . | D: Detach Data SIO port from selected CPU port. . | E: List of CPU ports to which the Status SIO port is attached . | F: Clear the current attachements of the Status SIO port and attach it to default CPU ports . | G: List of CPU ports to which the Data SIO port is attached . | H: Clear the current attachements of the Data SIO port and attach it to default CPU ports . | I: When selected, clicking on OK button will save the settings and will be applied at next emuStudio start. . | . Connecting devices . MITS 88-SIO board as emuStudio plug-in is a device which does nothing really useful. It just listens (and understands) commands coming from CPU through the I/O ports. The command is either a request for reading or request for writing to the attached device. . | Theoretically any device which supports the basic I/O (reading/writing), can be attached to the board. More about plug-in internals can be found in programmer&#8217;s manual of emuStudio, which is not part of the user documentation. | . Usually, attached devices were: . serial terminal . | line printer . | paper tape reader/punch . | . In current implementation of Altair 8800 emulator, the only suitable device which can be attached to the board is terminal ADM-3A from Lear Siegler, Inc and which is described in its own section. . Configuration file . Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please read the section &quot;Accessing settings of plug-ins&quot; in the user documentation of Main module to see how the settings can be accessed. . The following table shows all the possible settings of MITS 88-SIO plug-in: . Table 1. Settings of MITS 88-SIO Name Default value Valid values Description . dataPortNumberX . | 0x11 . | &gt; 0 and &lt; 256; X range from 0 upwards . | X-th Number of Data Port . | . statusPortNumberX . | 0x10 . | &gt; 0 and &lt; 256; X range from 0 upwards . | X-th Number of Status Port . | . As can be seen; the X represents a number, it&#8217;s a way how two SIO ports can be attached to multiple CPU ports. . Programming . In order to show something useful, let&#8217;s assume that a terminal LSI ADM-3A is attached to the board. Remember, the board only mediates the communication, it does not interpret any of the sent/received characters. . CPU Ports . The whole communication between the board (and attached device) and CPU is controlled by programming the two ports: Status port and Data port. The following table shows the ports and how they are used. . Table 2. Summary of CPU ports usage Port Address Input Output . 2 . | 0x11 . | Read data . | Write data . | . 1 . | 0x10 . | Read board status . | Not used. Originally used for enabling/disabling interrupts. . | . Now, detailed description of the ports follow. Bits are ordered in a byte as follows: . D7 D6 D5 D4 D3 D2 D1 D0 . where D7 is the most significant bit, and D0 the least significant bit. . Port 1 (&quot;Control&quot; port) . Default addresses: 0x03, 0x10, 0x14, 0x16, 0x18 (preferred is 0x10) . WRITE: . Controls input/output interrupts enable. If both interrupts are set to be enabled, it only empties transmitter buffer in the device, which was a post-step after interrupts being enabled. However, the plug-in does not implement interrupts support. . D7 D6 D5 D4 D3 D2 : unused bits . | D1 D0 : Used for enabling/disabling interrupts. Not used in emuStudio. . | . READ: . Read status of the device. . D7 : Output device ready. Always 0 in the emulator. . | D6 : Not used (always 0). . | D5 : Data available (for writing to the attached device). Always 0 in the emulator, meaning that no data is pending to be written. Data are written immediately after OUT instruction. . | D4 : Data overflow. Value 1 means a new word of data has been received before the previous word was inputted to the accumulator. In emuStudio, this never happens. . | D3 : Framing error. Value 1 means that data bit has no valid stop bit. In emuStudio, this never happens. . | D2 : Parity error. Value 1 means that received parity does not agree with selected parity. In emuStudio, this never happens. . | D1 : Transmitter buffer empty. Value 1 means that the data word has been received from the attached device and it&#8217;s available for reading (from the Data port). . | D0 : Input device ready. Value 1 means that the CPU can write data to the SIO (that the board is ready). Always 1 in the emulator. . | . Port 2 (&quot;Data&quot; port) . Default addresses: 0x02, 0x11, 0x15, 0x17, 0x19 (preferred is 0x11) . WRITE: . Write data to the attached device. . READ: . Read data from the attached device. . If the attached device sends asynchronously multiple data, the emulated board stores all in a buffer (queue) with unlimited capacity, so no data should be lost and can be read anytime. . Program example . In this section it will be shown a small &quot;How to&quot; program terminal using 88-SIO ports. . Print a character on screen . In emuStudio, it is enough to write data to Port 2, e.g.: . Example program for writing character on terminal mvi a, &#39;H&#39; out 11h mvi a, &#39;i&#39; out 11h . Print a string on screen . For writing strings, it is more practical to have a procedure. . Example program for writing text on terminal lxi h, text ; load address of &#39;text&#39; label to HL call print ; print text hlt ; halt CPU text: db &#39;Hello, world!&#39;,0 ; Procedure for printing text to terminal. ; Input: pair HL must contain the address of the ASCIIZ string print: mov a, m ; load character from HL inx h ; increment HL cpi 0 ; is the character = 0? rz ; yes; quit out 11h ; otherwise; show it jmp print ; and repeat from the beginning . Reading character from keyboard . For reading a character, it is required to read the Port 1 until the character is not ready. Then we can read it from Port 2. . Example procedure for reading a character from terminal ; Procedure will read a single character from terminal ; Input: none ; Output: register A will contain the character. getchar: in 10h ; read Port 1 ani 1 ; is data ready ? jz getchar ; not; try again in 11h ; yes; read it (into A register) ret . Reading text from keyboard . Now follows an example, which will read a whole line of characters into memory starting at address in DE pair. The procedure will interpret some control keys, like: backspace and ENTER keys. . Example program for reading text from terminal lxi h, text ; load address of &#39;text&#39; label to HL xchg ; DE &lt;-&gt; HL call getline ; read line from the keyboard into DE lxi h, text ; load &#39;text&#39; address again call print ; print the text on screen hlt ; halt CPU text: ds 30 ; here will be stored the read text ;Procedure for reading a text from keyboard. ;Input: DE = address, where the text should be put after reading ; C = is used internally getline: mvi c, 0 ; register C will be used as a counter of ; read characters next_char: in 10h ; read Port 1: status ani 1 ; is the char ready for reading? jz next_char ; not; try again in 11h ; yes; read it to A register ; now ENTER and Backspace will be interpreted cpi 13 ; ENTER? jz getline_ret ; yes; it means end of input cpi 8 ; Backspace ? jnz save_char ; if not; store the character ; Backspace interpretation mov a, c ; A &lt;- number of read characters cpi 0 ; are we at the beginning? jz next_char ; yes; ignore the backspace dcx d ; not; decrement DE dcr c ; decrement count of read characters mvi a,8 ; &quot;show&quot; the backspace (terminal will ; interpret this by moving the cursor ; to the left by 1 char) out 11h mvi a, 32 ; &quot;clear&quot; the current character on screen ; by a space character (ASCII code 32) out 11h mvi a,8 ; and move the cursor back again out 11h jmp next_char ; jump to next char save_char: ; stores a character into memory at DE out 11h ; show the character in A register stax d ; store it at address DE inx d ; increment DE inr c ; increment number of read characters jmp next_char ; jump to next char getline_ret: ; end of input ; ENTER will be stored as CRLF mvi a,13 ; CR (Carriage Return) stax d ; store the char inx d ; increment DE mvi a, 10 ; LF (Line Feed) stax d ; store the char inx d ; increment DE mvi a, 0 ; char 0 (End-Of-Input) stax d ; store the char ret ; return .",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/88-sio.html",
    "relUrl": "/docs/mits_altair_8800/88-sio.html"
  }
  ,"4": {
    "title": "About emuStudio",
    "content": "What is emuStudio . emuStudio is a toy-computer emulation platform and framework, targeting mainly academic sphere. A platform, because it supports full emulation “life-cycle”. From writing and compiling programs for emulated machine, to running and debugging. A framework, because it provides API and documentation which encourages implementing your custom toy-computer, either real or abstract. . It does not aim to supersede other emulators which try to preserve history (e.g. MAME, or simh), because they do better job, have big community around them and it does not make sense to provide the same goal. Instead, emuStudio focuses on allowing programming the emulated devices - in the style of “write program - load it into computer - emulate”. . History . Project ‘emuStudio’ started in 2006 as a school project, then a master thesis, created by Peter Jakubčo. He had continued to work on it afterwards, giving it less and less spare time he has now. . Supervisor of the school project was Slavomír Šimoňák, who could be understood as the first “product owner”. On a personal note, the original author remembers the times with nostalgy. Lots of good ideas came from discussions between the supervisor and the author. . The main reason why the project started was lack of good but simple emulators which allowed ‘program-load-emulate’ workflow. Back then at Technical University of Košice (Slovakia), during first lessons in assembly language, students were at first introduced to vintage computers. They had to create simple programs for Intel 8080, but they did it by hand on a paper. emuStudio allowed to use computer, and since then it has established as basic tool, extending to multiple programming-like courses at the university. . Now, students are main contributors which extend emuStudio, but from time-to-time some unknown contributors appear as well, from various countries over the world. Original author still keeps maintaining it. .",
    "url": "/documentation/user/0.40/about/",
    "relUrl": "/about/"
  }
  ,"5": {
    "title": "",
    "content": "Abstract tapes . Abstract tapes, in general, are used in various abstract machines. Probably the best known are Turing machine, RAM machine and RASP machine. Plug-in of the abstract tape for emuStudio is called abstractTape-ram. . There are several properties which an abstract tape might have: . Bounded, one-side bounded or unbounded . | Random access (allowing to move head in both directions) or linear access (allowing to move head only in one direction) . | Specific or any cell content type (e.g. cells are integers, or strings, or can be any value?) . | Read only, or read-write cells . | Purpose of the tape (title) . | . This plug-in allows to set up such properties, but those are set up by the virtual computer which uses it, not by the user. For more information, please see the Using abstract tapes in your emulator section. . Currently, there are just two virtual computers utilizing this plug-in: . RAM machine . | RASP machine . | . After emuStudio is run, RAM CPU (or RASP CPU) sets up properties for all used tapes. So the tape &quot;purpose&quot; and behavior is set in run time. . Installation and run . The abstract tape can be run only as a part of emuStudio. It is installed in location devices/abstractTape-ram.jar. . Graphical user interface (GUI) . The graphical user interface of the abstract tape is very simple. In order to open it, select the tape in the peripheral devices list in the Emulator panel. Then, click on the &quot;Show&quot; button. . The symbol, highlighted with the blue color is the current head position, in this case. In order to manipulate with particular symbols, one must select the symbol, which appears in bold, as in the following image: . A: If the tape allows it, one can add new symbol before the selected one in the tape. In the image, the tape does not allow it. . | B: The tape content area. Usually, each row consists of the symbol &quot;index&quot; or position within the tape, followed by the symbol itself. . | C: If the tape allows it, one can add new symbol after the last one in the tape. In the image, the tape allows it. . | D: Removes selected symbol from the tape. . | E: Edits the tape symbol. The symbol must be selected. . | F: Clears the tape content . | . Settings . The tape allows to edit some settings from the graphical mode; to open the settings window click on the &quot;Settings&quot; button below the peripheral devices list in the Emulator panel. The window can be seen in the following image: . A: Do not allow the tape to fall behind other window . | B: Show the tape right after emuStudio start (see Configuration file section) . | . Configuration file . Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please read the section &quot;Accessing settings of plug-ins&quot; in the user documentation of Main module to see how the settings can be accessed. . The following table shows all the possible settings of Abstract tape plug-in: . Table 1. Settings of Abstract tape Name Default value Valid values Description . alwaysOnTop . | false . | true, false . | Whether the tape GUI should not allow to fall behind other windows . | . showAtStartup . | false . | true, false . | If the tape should be shown automatically after emuStudio is started . | . Automatic emulation . Abstract tape supports automatic emulation. It means, that every change to it is being written to a file. The file name is devised from the title of the tape, by the following algorithm: . At first, all spaces in the title are replaced with underscore (_) . | Then, all &quot;unwanted&quot; characters are also replaced with underscore . | Every character is converted to lower-case . | Finally, the .out extension is added at the end. . | . Unwanted characters are the following: *, ., #, %, &amp;, +, !, ~, /, ?, &lt;, &gt;, ,, |, {, }, [, ], &quot;, `, = . Using abstract tapes in your emulator . | This section is for developers of emulators. If you do not plan to create custom virtual computers, you can safely skip this section. In order to get started with developing plug-ins for emuStudio, please read tutorial &quot;Developing emuStudio Plugins&quot;. | . The Abstract tape plug-in can be used in various computers. Besides standard operations which are provided by emulib.plugins.device.DeviceContext interface, it provides custom context API, enabling to setting up properties described in the introduction section. . Usually, the tapes are used by CPU plug-ins, but it is ofcourse possible to use it in any other plug-in. You can obtain the context during the initialize() method of the plug-in main class. The context is named net.sf.net.emustudio.devices.abstracttape.api.AbstractTapeContext: . ... public void initialize(SettingsManager settings) { ... AbstractTapeContext tape = contextPoolImpl.getDeviceContext(pluginID, AbstractTapeContext.class); ... } . The tape context interface is as follows: . package net.sf.emustudio.devices.abstracttape.api; import emulib.annotations.ContextType; import emulib.plugins.device.DeviceContext; /** * Public API of the abstract tape. */ @ContextType public interface AbstractTapeContext extends DeviceContext&lt;String&gt; { /** * Clear content of the tape. */ void clear(); /** * Set this tape to left-bounded or unbounded. * * @param bounded true if the tape should be left-bounded, * false if unbounded. */ void setBounded(boolean bounded); /** * Determine if the tape is left-bounded. * * @return true - left-bounded, false - unbounded. */ boolean isBounded(); /** * Move the tape one symbol to the left. * * If the tape is left-bounded and the old position is 0, tape won&#39;t move. Otherwise the tape * will expand to the left - add new empty symbol to position 0 and shift the rest of the content to the right. * * @return true if the tape has been moved; false otherwise (if it is left-bounded and the position is 0). */ boolean moveLeft(); /** * Move tape to the right. If the tape is too short, it is expanded to the right (added new empty symbol). */ void moveRight(); /** * Allow or disallow to edit the tape. * * If the tape is editable, the user (in GUI) can add, modify or remove symbols from the tape. * Otherwise it is driven only by the CPU. * * @param editable true if yes, false if not. */ void setEditable(boolean editable); /** * Get symbol at the specified position. * * @param pos position in the tape, starting from 0 * @return symbol at given position; if the position is out of bounds, then empty string is returned. */ String getSymbolAt(int pos); /** * Set symbol at the specified position. * * If the position is &lt; 0, then no symbol will be set. * * If the position is &gt; tape size, empty symbols will be added until the required tape size is ensured. * Then, the symbol is added at the specified position. * * This method should be used only when loading some initial content to the tape. * * @param pos position in the tape, starting from 0 * @param symbol symbol value */ void setSymbolAt(int pos, String symbol); /** * Sets whether the symbol at which the head is pointing should be &quot;highlighted&quot; in GUI. * * @param visible true if yes; false otherwise. */ void setHighlightHeadPosition(boolean visible); /** * Seths whether the tape should be cleared at emulation reset. * * @param clear true if yes; false otherwise. */ void setClearAtReset(boolean clear); /** * Set title (purpose) of the tape. * * @param title title of the tape */ void setTitle(String title); /** * Determines if the symbol positions should be displayed in GUI. * * @return true if yes; false otherwise */ boolean showPositions(); /** * Set whether the symbol positions should be displayed in GUI. * * @param showPositions true if yes; false otherwise. */ void setShowPositions(boolean showPositions); /** * Get the tape head position. * * @return current position in the tape; starts from 0 */ int getHeadPosition(); /** * Get the size of the tape * * @return tape size */ int getSize(); /** * Determine if the tape is empty. * * @return true if the tape is empty; false otherwise. */ boolean isEmpty(); @Override default Class&lt;String&gt; getDataType() { return String.class; } } .",
    "url": "/documentation/user/0.40/docs/ram/abstractTape-ram.html",
    "relUrl": "/docs/ram/abstractTape-ram.html"
  }
  ,"6": {
    "title": "Device adm3a-terminal",
    "content": "Terminal LSI ADM-3A . Emulation of famous terminal from Lear Siegler, Inc. - ADM-3A. It had a nick name &#39;Dumb Terminal&#39;. In the time (1974), due to its cheapness and speed capabilities required in that time, it became de facto standard in the industry. Often it was used in connection with MITS Altair 8800 computer, so the decision of which terminal to emulate was clear. . | The maintenance manual can be downloaded at this link, operator&#8217;s manual here. | . Display . The terminal could display 128 ASCII characters (upper-case and lower-case letters, punctuation and numbers). The original ADM-3 could display only 64 (only capital-letters and some other). For saving very expensive RAM the terminal offered size 12 rows x 80 columns, with optional extension to 24 rows x 80 columns. The size used in the emulator is hardcoded to 80 columns x 24 rows. . Besides, the emulator uses custom font colored green, with anti-aliasing support and double-buffering. . Keyboard . The terminal could generate always 128 ASCII characters (upper-case, lower-case, punctuation and numbers). Besides, it could generate special control characters which had effect on the current cursor position and were not sent to CPU. . The emulator allows to generate almost anything what your host keyboard can give. It is only up to font which characters it can display. The font cannot display any special non-US characters used in various languages. Just classic ASCII. . Besides, the terminal can capture control codes (holding CTRL plus some key), and special control codes (ESC + &#39;=&#39; plus some key). The following subsection lists all possible control and special control key combinations. . Control codes . The following table shows control codes (CTRL plus some key combinations). The table can be found in original manuals. The emulator is following it. . Table 1. Control codes Code ASCII mnemonic Function in ADM-3A . CTRL+^ . | RS . | Home cursor . | . CTRL+@ . | NUL . | | . CTRL+A . | SOH . | | . CTRL+B . | STX . | | . CTRL+C . | ETX . | | . CTRL+D . | EOT . | | . CTRL+E . | ENQ . | Initiates ID message with automatic &quot;Answer Back&quot; option. [1] . | . CTRL+F . | ACK . | | . CTRL+G . | BEL . | Sounds audible beep in ADM-3A (not in emulator yet :( ) . | . CTRL+H . | BS . | Backspace . | . CTRL+I . | HT . | | . CTRL+J . | LF . | Line feed . | . CTRL+K . | VT . | Upline . | . CTRL+L . | FF . | Forward space . | . CTRL+M . | CR . | Return . | . CTRL+N . | SO . | Unlock keyboard [1] . | . CTRL+O . | SI . | Lock keyboard [1] . | . CTRL+P . | OLE . | | . CTRL+Q . | DCI . | | . CTRL+R . | DC2 . | | . CTRL+S . | DC3 . | | . CTRL+T . | DC4 . | | . CTRL+U . | NAK . | | . CTRL+V . | SYN . | | . CTRL+W . | ETB . | | . CTRL+X . | CAN . | | . CTRL+Y . | EM . | | . CTRL+Z . | SUB . | Clear screen . | . CTRL+[ . | ESC . | Initiate load cursor . | . CTRL+x . | FS . | | . CTRL+] . | GS . | | . Absolute cursor position from the keyboard . The terminal also allowed to set the absolute cursor position, when in &quot;Cursor control Mode&quot;. The ADM-3A emulator does not have such mode, but ESC+&#39;=&#39; X Y combinations allows to set the cursor position. As you could see in the Control codes section, pressing the ESC &quot;Initiates load cursor&quot; operation. If the user then presses = key, then the terminal takes next 2 keystrokes, and translates them into X and Y coordinates for the new position of the cursor. The following table shows the key-to-coordinate translation table. . Table 2. Translation of keystrokes to cursor coordinates Key Number . o . | 79 . | . &#39; &#39; . | 0 . | . ! . | 1 . | . &quot; . | 2 . | . # . | 3 . | . $ . | 4 . | . % . | 5 . | . &amp; . | 6 . | . &#39; . | 7 . | . ( . | 8 . | . ) . | 9 . | . * . | 10 . | . + . | 11 . | . , . | 12 . | . - . | 13 . | . . . | 14 . | . / . | 15 . | . 0 . | 16 . | . 1 . | 17 . | . 2 . | 18 . | . 3 . | 19 . | . 4 . | 20 . | . 5 . | 21 . | . 6 . | 22 . | . 7 . | 23 . | . 8 . | 24 . | . 9 . | 25 . | . : . | 26 . | . ; . | 27 . | . &lt; . | 28 . | . = . | 29 . | . &gt; . | 30 . | . ? . | 31 . | . @ . | 32 . | . A . | 33 . | . B . | 34 . | . C . | 35 . | . D . | 36 . | . E . | 37 . | . F . | 38 . | . G . | 39 . | . H . | 40 . | . I . | 41 . | . J . | 42 . | . K . | 43 . | . L . | 44 . | . M . | 45 . | . N . | 46 . | . O . | 47 . | . P . | 48 . | . Q . | 49 . | . R . | 50 . | . S . | 51 . | . T . | 52 . | . U . | 53 . | . V . | 54 . | . W . | 55 . | . X . | 56 . | . Y . | 57 . | . Z . | 58 . | . [ . | 59 . | . . | 60 . | . ] . | 61 . | . ^ . | 62 . | . _ . | 63 . | . ` . | 64 . | . a . | 65 . | . b . | 66 . | . c . | 67 . | . d . | 68 . | . e . | 69 . | . f . | 70 . | . g . | 71 . | . h . | 72 . | . i . | 73 . | . j . | 74 . | . k . | 75 . | . l . | 76 . | . m . | 77 . | . n . | 78 . | . ADM-3A Settings . It is possible to configure the terminal either from GUI or manually modifying configuration settings. In the case of manual file modification, emuStudio must be restarted (for more information, see section Configuration file). . The &quot;settings&quot; window [peripheral] is shown in the following image: . A: File for reading input (when redirected) . | B: File for writing output (when redirected) . | C: In automatic mode, how long the terminal should wait until it reads next input character from the file (in milliseconds) . | D: Whether every keystroke will also cause to display it. Programs don&#8217;t always &quot;echo&quot; the characters back to the screen. . | E: Whether terminal GUI should be always-on-top of other windows . | F: Whether the display should use anti-aliasing. . | G: Clears the screen. . | H: Rolls the screen down by 1 line . | I: If checked, then by pressing OK the settings will be saved to the configuration file. If not, they will be not saved. In any case, the effect of the settings will be visible immediately. . | . | The terminal behaves differently when emuStudio is run in automatic (no GUI) mode. In that moment, input is redirected to be read from a file, and also output is redirected to be written to another file. The file names are configurable in the computer config file. Using redirection in GUI mode is currently not possible. | . Configuration file . Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please read the section &quot;Accessing settings of plug-ins&quot; in the user documentation of Main module to see how the settings can be accessed. . The following table shows all the possible settings of ADM-3A plug-in: . Table 3. Settings of LSI ADM-3A Name Default value Valid values Description . halfDuplex . | false . | true / false . | Whether every keystroke will also cause to display it. . | . inputFileName . | adm3A-terminal.in . | Path to existing file . | File for reading input (when redirected) . | . outputFileName . | adm3A-terminal.out . | Path to existing file . | File for writing output (when redirected) . | . inputReadDelay . | 0 . | &gt; 0 . | How long the terminal should wait until it reads next input character from the file (in milliseconds) . | . alwaysOnTop . | false . | true / false . | Whether terminal GUI should be always-on-top of other windows . | . antiAliasing . | false . | true / false . | Whether the display should use anti-aliasing. . | . . 1. &quot;In the original ADM-3A device, these codes were executable only from computer.&quot;",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/adm3a-terminal.html",
    "relUrl": "/docs/mits_altair_8800/adm3a-terminal.html"
  }
  ,"7": {
    "title": "Assembler as-8080",
    "content": "Assembler &quot;as-8080&quot; . Assembler for Intel 8080 CPU in emuStudio is very similar to Intel assembler, but has some little differences. Features include: . full instructions support . | macro support (unlimited nesting) . | include other files support . | data definition . | relative addressing using labels . | literals and expressions in various radixes (bin, dec, hex, oct) . | output is in Intel HEX format . | . The features are very similar to those in as-z80 assembler. . Installation and run . The assembler is provided as part of emuStudio. It is not deployed as individual package. It can be found in compilers/ directory with name as-8080.jar. . The assembler can be run from command line, with command: . java -jar as-8080.jar [--output output_file.hex] [source_file.asm] . To query for more information, run it with command: . java -jar as-8080.jar --help . Lexical symbols . The assembler does not differentiate between upper and lower case (it is case-insensitive). The token/symbol types are as follows: . Type Description . Comments . | semi-colon (;) with text after it until the end of the line . | . Keywords . | instruction names; preprocessor directives (org, equ, set, macro, endm, include, if, endif); data definitions (db, dw, ds); CPU registers . | . Identifiers . | ([a-zA-Z_ ?@])[a-zA-Z_ ?@0-9]* except keywords . | . Labels . | | . Constants . | strings or integers . | . Operators . | +, -, *, /, =, mod, and, or, not, xor, shl, shr . | . Constants . Numeric constants can be only integers, encoded with one of several number radixes. The possible formats are written using regexes: . binary numbers: [0-1]+[bB] . | decimal numbers: [0-9]+[dD]? . | octal numbers: [0-7]+[oOqQ] . | hexadecimal numbers: [0-9][0-9a-fA-F]*[hH] . | . Characters or strings must be enclosed in single-quotes, e,g,: MVI E, &#39;*&#39; . Identifiers . Identifiers must fit to the following regex: ([a-zA-Z_ ?@])[a-zA-Z_ ?@0-9]*. It means, that it has to start with a letter a-z (or A-Z) or the at-sign (@). Then, it can be followed by letters, at-sign, or numbers. . However, they must not equal to any keyword. . Instructions syntax . The program is basically a sequence of instructions. The instructions are separated by a new line. The instruction have optional and mandatory parts, e.g.: . LABEL: CODE OPERANDS ; COMMENT . LABEL . | Optional . | Identifier of the memory position, followed by a colon (:). It can be used as forward or backward reference in instructions which expect memory address (or 16 bit number). . | . CODE . | Mandatory . | Instruction name. . | . OPERANDS . | It depends . | If applicable, a comma-separated (,) operands of the instruction. . | . COMMENT . | Optional . | semi-colonm (;) followed by any text until the end of the line. . | . Fields CODE and OPERANDS must be separated by at least one space. For example: . HERE: MVI C, 0 ; Put 0 into C register DB 3Ah ; Data constant of size 1 byte LOOP: JMP LOOP ; Infinite loop . Labels are optional. Instructions and pseudo-instructions and register names are reserved for assembler and cannot be used as labels. Also, there cannot be more definitions of the same label. . Operands must be separated with comma (,). There exist several operand types, which represent so-called &quot;address modes&quot;. Allowed address modes depend on the instruction. The possibilities are: . Implicit addressing: instructions do not have operands. They are implicit. . | Register addressing: operands are registers. 8-bit general-purpose register names are: A, B, C, D, E, H, L. Stack pointer is defined as SP, and program status word (used by push / pop instructions) as PSW. When register pairs should be used in 16-bit instructions, the same register names are used. For example, DCX D which decrements pair DE. . | Register indirect addressing: for the memory value specified by address in HL pair is used special register called M, for example: MOV A, M. . | Immediate addressing: operand is the 8-bit constant. It can be also one character, enclosed in single-quotes. . | Direct addressing: operand is either 8-bit or 16-bit constant, which is understood as the memory location (address). For example: SHLD 1234h. . | Modified page zero: operand is 3-bit value (0-7). It represents a &quot;index&quot;, which is multiplied by constant 8, resulting in final memory address. Used in RST instruction. . | . Immediate data or addresses can be defined in various ways: . Integer constant . | Integer constant as a result of evaluation of some expression (e.g. 2 SHL 4, or 2 + 2) . | Current address - denoted by special variable $. For example, instruction JMP $+6 denotes a jump by 6-bytes further from the current address. . | Character constants, enclosed in single-quotes (e.g. MVI A, &#39;*&#39;) . | Labels. For example: JMP THERE will jump to the label THERE. . | Variables. For example: . VALUE SET &#39;A&#39; MVI A, VALUE . | . Expressions . An expression is a combination of the data constants and operators. Expressions are evaluated in compile-time. Given any two expressions, they must not be defined in circular way. . Expressions can be used anywhere a constant is expected. . There exist several operators, such as: . + . | Addition. Example: DB 2 + 2; evaluates to DB 4 . | . - . | Subtraction. Example: DW $ - 2; evaluates to the current compilation address minus 2. . | . * . | Multiply. . | . / . | Integer division. . | . = . | Comparison for equality. Returns 1 if operands equal, 0 otherwise. Example: DB 2 = 2; evaluates to DB 1. . | . mod . | Remainder after integer division. Example DB 4 mod 3; evaluates to DB 1. . | . and . | Logical and. . | . or . | Logical or. . | . xor . | Logical xor. . | . not . | Logical not. . | . shl . | Shift left by 1 bit. Example: DB 1 SHL 3; evaluates to DB 8 . | . shr . | Shift right by 1 bit. . | . Operator priorities are as follows: . Priority Operator Type . 7 . | or, xor . | Binary . | . 1 . | ( ) . | Unary . | . 2 . | *, /, mod, shl, shr . | Binary . | . 3 . | +, - . | Unary and binary . | . 4 . | = . | Binary . | . 5 . | not . | Unary . | . 6 . | and . | Binary . | . All operators work with its arguments as if they were 16-bit. Their results are always 16-bit numbers. If there is expected 8-bit number, the result is automatically &quot;cut&quot; using operation result AND 0FFh. This may be unwanted behavior and might lead to bugs, but it is often useful so the programmer must ensure the correctness. . Defining data . Data can be defined using special pseudoinstructions. These accept constants. Negative integers are using two&#8217;s complement. . The following table describes all possible data definition pseudoinstructions: . DB [expression] . | Define byte. The [expression] must be of size 1 byte. Using this pseudoinstruction, a string can be defined, enclosed in single quotes. For example: DB &#39;Hello, world!&#39; is equal to DB &#39;H&#39;, DB &#39;e&#39;, etc. on separate lines. . | . DW [expression] . | Define word. The [expression] must be max. of size 2 bytes. Data are stored using little endian. . | . DS [expression] . | Define storage. The [expression] represents number of bytes which should be &quot;reserved&quot;. The reserved space will not be modified in memory. It is similar to &quot;skipping&quot; particular number of bytes. . | . Examples: . HERE: DB 0A3H ; A3 W0RD1: DB 5*2, 2FH-0AH ; 0A25 W0RD2: DB 5ABCH SHR 8 ; 5A STR: DB &#39;STRINGSpl&#39; ; 535452494E472031 MINUS: DB -03H ; FD . ADD1: dw COMP ; 1C3B (assume COMP is 3B1CH) ADD2: dw FILL ; B43E (assume FILL is 3EB4H) ADD3: dw 3C01H, 3CAEH ; 013CAE3C . Including other source files . It is both useful and good practice to write modular programs. According to the DRY principle the repetitive parts of the program should be refactored out into functions or modules. Functionally similar groups of these functions or modules can be put into a library, reusable in other programs. . The pseudoinstruction include exists for the purpose of including already written source code into the current program. The pseudoinstruction is defined as follows: . INCLUDE &#39;[filename]&#39; . where [filename] is a relative or absolute path to the file which will be included, enclosed in single-quotes. The file can include other files, but there must not be defined circular includes (compiler will complain). . The current compilation address (denoted by $ variable) after the include will be updated about the binary size of the included file. . The namespace of the current program and the included file is shared. It means that labels or variables with the same name in the current program and the included file are prohibited. Include file &quot;sees&quot; everything in the current program as it was its part. . Example: . Let a.asm contains: . mvi b, 80h . Let b.asm contains: . include &#39;a.asm&#39; . Then compiling b.asm will result in: . 06 80 ; mvi b, 80h . Origin address (ORG) . Syntax: ORG [expression] . Sets the value to the $ variable. It means that from now on, the following instructions will be placed at the address given by the [expression]. Effectively, it is the same as using DS pseudo-instruction, but instead of defining number of skipped bytes, we define concrete memory location (address). . The following two code snippets are equal: . Address Block 1 Block 2 Opcode . 2C10 . | NEXT: XRA A . | NEXT: XRA A . | AF . | . 2C00 . | MOV A,C . | MOV A,C . | 79 . | . 2C01 . | JMP NEXT . | JMP NEXT . | C3 10 2C . | . 2C04 . | DS 12 . | ORG $+12 . | | . Equate (EQU) . Syntax: [identifier] EQU [expression] . Define a constant. The [identifier] is a mandatory name of the constant. Please see the Identifiers section for more details. . [expression] is the 16-bit expression. . The pseudo-instruction will define a constant - assign a name to given expression. The name of the constant then can be used anywhere where the constant is expected and the compiler will replace it with the expression. . It is not possible to redefine a constant. . Using variables . Syntax: [identifier] SET [expression] . Define or re-define a variable. The [identifier] is a mandatory name of the constant. Please see the Identifiers section for more details. . [expression] is the 16-bit expression. . The pseudo-instruction will define a variable - assign a name to given expression. Then, the name of the variable can be used anywhere where the constant is expected. . It is possible to redefine a variable, which effectively means to reassign new expression to the same name and forgetting the old one. The reassignment is aware of locality, i.e. before it the old value will be used, after it the new value will be used. . Conditional assembly . Syntax: . if [expression] i n s t r u c t i o n s endif . At first, the compiler evaluates the [expression]. If the result is 0, instructions between if and endif will be ignored. Otherwise they will be included in the source code. . Defining and using macros . Syntax: . [identifier] macro [operands] i n s t r u c t i o n s endm . The [identifier] is a mandatory name of the macro. Please see the Identifiers section for more details. . The [operands] part is a list of identifiers, separated by commas (,). Inside the macro, operands act as constants. If the macro does not use any operands, this part can be omitted. . The namespace of the operand identifiers is macro-local, ie. the operand names will not be visible outside the macro. Also, the operand names can hide variables, labels or constants defined in the outer scope. . The macros can be understood as &quot;templates&quot; which will be expanded in the place where they are &quot;called&quot;. The call syntax is as follows: . [macro name] [arguments] . where [macro name] is the macro name as defined above. Then, [arguments] are comma-separated expressions, in the order as the original operands are defined. The number of arguments must be the same as number of macro operands. . The macro can be defined anywhere in the program, even in some included file. Also, it does not matter in which place is called - above or below the macro definition. . Examples: . SHV MACRO LOOP: RRC ; Right rotate with carry ANI 7FH ; Clear MSB of accumulator DCR D ; Decrement rotation counter - register D JNZ LOOP ; Jump to next rotation ENDM . The macro SHV can be used as follows: . LDA TEMP MVI D,3 ; 3 rotations SHV STA TEMP . Or another definition: . SHV MACRO AMT MVI D,AMT ; Number of rotations LOOP: RRC ANI 7FH DCR D JNZ LOOP ENDM . And usage: . LDA TEMP SHV 5 . Which has the same effect as the previous example. .",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/as-8080.html",
    "relUrl": "/docs/mits_altair_8800/as-8080.html"
  }
  ,"8": {
    "title": "Assembler as-z80",
    "content": "Assembler &quot;as-z80&quot; . The assembler syntax is inspired by as-8080 assembler, and by instruction set described here. The assembler supports the following features: . full instructions support . | macro support (unlimited nesting) . | include other files support . | conditional assembly . | data definition . | relative addressing using labels . | literals and expressions in various radixes (bin, dec, hex, oct) . | output is in Intel HEX format . | . Installation and run . The assembler is provided as part of emuStudio. It is not deployed as individual package. It can be found in compilers/ directory with name as-z80.jar. . The assembler can be run from command line, with command: . java -jar as-z80.jar [--output output_file.hex] [source_file.asm] . To query for more information, run it with command: . java -jar as-z80.jar --help . Lexical symbols . The assembler does not differentiate between upper and lower case (it is case-insensitive). The token/symbol types are as follows: . Type Description . Comments . | semi-colon (;) with text after it until the end of the line . | . Keywords . | instruction names; preprocessor directives (org, equ, var, macro, endm, include, if, endif); data definitions (db, dw, ds); CPU registers . | . Identifiers . | ([a-zA-Z_ ?@])[a-zA-Z_ ?@0-9]* except keywords . | . Labels . | | . Constants . | strings or integers . | . Operators . | +, -, *, /, =, %, &amp;, |, !, ~, &lt;&lt;, &gt;&gt;, &gt;, &lt;, &gt;=, &#39;&#8656;` . | . Constants . Numeric constants can be only integers, encoded with one of several number radixes. The possible formats are written using regexes: . binary numbers: [0-1]+[bB] . | decimal numbers: [0-9]+[dD]? . | octal numbers: [0-7]+[oOqQ] . | hexadecimal numbers: [0-9][0-9a-fA-F]*[hH] . | . Characters or strings must be enclosed in double-quotes, e,g,: LD E, &quot;*&quot; . Identifiers . Identifiers must fit to the following regex: ([a-zA-Z_ ?@])[a-zA-Z_ ?@0-9]*. It means, that it has to start with a letter a-z (or A-Z) or the at-sign (@). Then, it can be followed by letters, at-sign, or numbers. . However, they must not equal to any keyword. . Instructions syntax . The program is basically a sequence of instructions. The instructions are separated by a new line. The instruction have optional and mandatory parts, e.g.: . LABEL: CODE OPERANDS ; COMMENT . LABEL . | Optional . | Identifier of the memory position, followed by a colon (:). It can be used as forward or backward reference in instructions which expect memory address (or 16 bit number). . | . CODE . | Mandatory . | Instruction name. . | . OPERANDS . | It depends . | If applicable, a comma-separated (,) operands of the instruction. . | . COMMENT . | Optional . | semi-colonm (;) followed by any text until the end of the line. . | . Fields CODE and OPERANDS must be separated by at least one space. For example: . HERE: LD C, 0 ; Put 0 into C register DB 3Ah ; Data constant of size 1 byte LOOP: JP LOOP ; Infinite loop . Labels are optional. Instructions and pseudo-instructions and register names are reserved for assembler and cannot be used as labels. Also, there cannot be more definitions of the same label. . Operands must be separated with comma (,). There exist several operand types, which represent so-called &quot;address modes&quot;. Allowed address modes depend on the instruction. The possibilities are: . Implicit addressing: instructions do not have operands. They are implicit. . | Register addressing: operands are registers. 8-bit general-purpose register names are: A, B, C, D, E, H, L. Register pairs have names: BC, DE, HL. Stack pointer is defined as SP, and program status word (used by push / pop instructions) as AF. Another 16-bit registers are defined as IX, IY. . | Register indirect addressing: for example, loading a memory value at address in HL pair: LD A, (HL). . | Immediate addressing: operand is the 8-bit constant. It can be also one character, enclosed in double-quotes. . | Direct addressing: operand is either 8-bit or 16-bit constant, which is understood as the memory location (address). For example: LD (1234h), HL. . | . Immediate data or addresses can be defined in various ways: . Integer constant . | Integer constant as a result of evaluation of some expression (e.g. 2 &lt;&lt; 4, or 2 + 2) . | Current address - denoted by special variable $. For example, instruction JP $+6 denotes a jump by 6-bytes further from the current address. . | Character constants, enclosed in double-quotes (e.g. LD A, &quot;*&quot;) . | Labels. For example: JP THERE will jump to the label THERE. . | Variables. For example: . VALUE VAR &#39;A&#39; LD A, VALUE . | . Expressions . An expression is a combination of the data constants and operators. Expressions are evaluated in compile-time. Given any two expressions, they must not be defined in circular way. . Expressions can be used anywhere a constant is expected. . There exist several operators, such as: . + . | Addition. Example: DB 2 + 2; evaluates to DB 4 . | . - . | Subtraction. Example: DW $ - 2; evaluates to the current compilation address minus 2. . | . * . | Multiply. . | . / . | Integer division. . | . = . | Comparison for equality. Returns 1 if operands equal, 0 otherwise. Example: DB 2 = 2; evaluates to DB 1. . | . % . | Remainder after integer division. Example DB 4 mod 3; evaluates to DB 1. . | . &amp; . | Logical and. . | . | . | Logical or. . | . ~ . | Logical xor. . | . ! . | Logical not. . | . &lt;&lt; . | Shift left by 1 bit. Example: DB 1 SHL 3; evaluates to DB 8 . | . &gt;&gt; . | Shift right by 1 bit. . | . &gt; . | Greater than. Example: DB 3 &gt; 2; evaluates to DB 1 . | . &lt; . | Less than. . | . &gt;= . | Greater or equal than. . | . &#8656; . | Less or equal than. . | . Operator priorities are as follows: . Priority Operator Type . 7 . | |, ~ . | Binary . | . 1 . | ( ) . | Unary . | . 2 . | *, /, %, &lt;&lt;, &gt;&gt;, &gt;, &lt;, &gt;=, &#8656; . | Binary . | . 3 . | +, - . | Unary and binary . | . 4 . | = . | Binary . | . 5 . | ! . | Unary . | . 6 . | &amp; . | Binary . | . All operators work with its arguments as if they were 16-bit. Their results are always 16-bit numbers. If there is expected 8-bit number, the result is automatically &quot;cut&quot; using operation result AND 0FFh. This may be unwanted behavior and might lead to bugs, but it is often useful so the programmer must ensure the correctness. . Defining data . Data can be defined using special pseudoinstructions. These accept constants. Negative integers are using two&#8217;s complement. . The following table describes all possible data definition pseudoinstructions: . DB [expression] . | Define byte. The [expression] must be of size 1 byte. Using this pseudoinstruction, a string can be defined, enclosed in single quotes. For example: DB &#39;Hello, world!&#39; is equal to DB &#39;H&#39;, DB &#39;e&#39;, etc. on separate lines. . | . DW [expression] . | Define word. The [expression] must be max. of size 2 bytes. Data are stored using little endian. . | . DS [expression] . | Define storage. The [expression] represents number of bytes which should be &quot;reserved&quot;. The reserved space will not be modified in memory. It is similar to &quot;skipping&quot; particular number of bytes. . | . Examples: . HERE: DB 0A3H ; A3 W0RD1: DB 5*2, 2FH-0AH ; 0A25 W0RD2: DB 5ABCH SHR 8 ; 5A STR: DB &quot;STRINGSpl&quot; ; 535452494E472031 MINUS: DB -03H ; FD . ADD1: dw COMP ; 1C3B (assume COMP is 3B1CH) ADD2: dw FILL ; B43E (assume FILL is 3EB4H) ADD3: dw 3C01H, 3CAEH ; 013CAE3C . Including other source files . It is both useful and good practice to write modular programs. According to the DRY principle the repetitive parts of the program should be refactored out into functions or modules. Functionally similar groups of these functions or modules can be put into a library, reusable in other programs. . The pseudoinstruction include exists for the purpose of including already written source code into the current program. The pseudoinstruction is defined as follows: . INCLUDE &quot;[filename]&quot; . where [filename] is a relative or absolute path to the file which will be included, enclosed in double-quotes. The file can include other files, but there must not be defined circular includes (compiler will complain). . The current compilation address (denoted by $ variable) after the include will be updated about the binary size of the included file. . The namespace of the current program and the included file is shared. It means that labels or variables with the same name in the current program and the included file are prohibited. Include file &quot;sees&quot; everything in the current program as it was its part. . Example: . Let a.asm contains: . ld b, 80h . Let b.asm contains: . include &quot;a.asm&quot; . Then compiling b.asm will result in: . 06 80 ; ld b, 80h . Origin address (ORG) . Syntax: ORG [expression] . Sets the value to the $ variable. It means that from now on, the following instructions will be placed at the address given by the [expression]. Effectively, it is the same as using DS pseudo-instruction, but instead of defining number of skipped bytes, we define concrete memory location (address). . The following two code snippets are equal: . Address Block 1 Block 2 Opcode . 2C10 . | NEXT: XOR A . | NEXT: XOR A . | AF . | . 2C00 . | LD A,C . | LD A,C . | 79 . | . 2C01 . | JP NEXT . | JP NEXT . | C3 10 2C . | . 2C04 . | DS 12 . | ORG $+12 . | | . Equate (EQU) . Syntax: [identifier] EQU [expression] . Define a constant. The [identifier] is a mandatory name of the constant. Please see the [AS-8080-IDENTIFIERS] section for more details. . [expression] is the 16-bit expression. . The pseudo-instruction will define a constant - assign a name to given expression. The name of the constant then can be used anywhere where the constant is expected and the compiler will replace it with the expression. . It is not possible to redefine a constant. . Using variables . Syntax: [identifier] VAR [expression] . Define or re-define a variable. The [identifier] is a mandatory name of the constant. Please see the Identifiers section for more details. . [expression] is the 16-bit expression. . The pseudo-instruction will define a variable - assign a name to given expression. Then, the name of the variable can be used anywhere where the constant is expected. . It is possible to redefine a variable, which effectively means to reassign new expression to the same name and forgetting the old one. The reassignment is aware of locality, i.e. before it the old value will be used, after it the new value will be used. . Conditional assembly . Syntax: . if [expression] i n s t r u c t i o n s endif . At first, the compiler evaluates the [expression]. If the result is 0, instructions between if and endif will be ignored. Otherwise they will be included in the source code. . Defining and using macros . Syntax: . [identifier] macro [operands] i n s t r u c t i o n s endm . The [identifier] is a mandatory name of the macro. Please see the Identifiers section for more details. . The [operands] part is a list of identifiers, separated by commas (,). Inside the macro, operands act as constants. If the macro does not use any operands, this part can be omitted. . The namespace of the operand identifiers is macro-local, ie. the operand names will not be visible outside the macro. Also, the operand names can hide variables, labels or constants defined in the outer scope. . The macros can be understood as &quot;templates&quot; which will be expanded in the place where they are &quot;called&quot;. The call syntax is as follows: . [macro name] [arguments] . where [macro name] is the macro name as defined above. Then, [arguments] are comma-separated expressions, in the order as the original operands are defined. The number of arguments must be the same as number of macro operands. . The macro can be defined anywhere in the program, even in some included file. Also, it does not matter in which place is called - above or below the macro definition. . Examples: . SHV MACRO LOOP: RRCA ; Right rotate with carry AND 7FH ; Clear MSB of accumulator DEC D ; Decrement rotation counter - register D JP NZ, LOOP ; Jump to next rotation ENDM . The macro SHV can be used as follows: . LD A, (TEMP) LD D,3 ; 3 rotations SHV LD (TEMP), A . Or another definition: . SHV MACRO AMT LD D,AMT ; Number of rotations LOOP: RRCA AND 7FH DEC D JP NZ, LOOP ENDM . And usage: . LD A, (TEMP) SHV 5 LD (TEMP), A . Which has the same effect as the previous example. .",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/as-z80.html",
    "relUrl": "/docs/mits_altair_8800/as-z80.html"
  }
  ,"9": {
    "title": "Automation",
    "content": "Emulation automation . BrainDuck is one of computers which allows automatic emulation. It means that it is possible to run the emulation from command line, while all necessary input and output is redirected from/to files. If user interaction is necessary, it is possible to run an interactive automation. . Suppose the BrainDuck computer is represented by abstract schema shown in brainduck-intro document. In that case, BrainDuck terminal is the only device dealing with I/O. If the emulation was executed in automatic non-interactive mode, it will recognize it and the input/output will be redirected from/to files. . Input file is called brainduck-terminal.in and must be placed in the directory from which emuStudio was executed. If the file does not exist, emuStudio will not run. . Output file is called brainduck-terminal.out and it will be created automatically, or appended when it exists in the location from which emuStudio was executed. . | Take care about end-of-line characters. Most of brainfuck programs count with Unix-like EOLs, i.e. characters with ASCII code 10. Plug-in brainduck-terminal interprets ENTER key in the interactive mode as Unix-like EOL. In the non-interactive mode, EOL may be of any-like type. | . Command line for starting non-interactive automatic emulation: . java -jar emuStudio.jar --config BrainDuck --input examples/brainc-brainduck/mandelbrot.b --output compiler.out --auto --nogui . configuration config/BrainDuck.conf will be loaded . | input file for compiler is one of the examples . | compiler messages will be redirected to file compiler.out . | (--auto) automatic emulation mode will be performed . | (--nogui) non-interactive version will be set . | .",
    "url": "/documentation/user/0.40/docs/brainduck/automation.html",
    "relUrl": "/docs/brainduck/automation.html"
  }
  ,"10": {
    "title": "Compiler",
    "content": "Compiler &quot;brainc-brainduck&quot; . BrainDuck compiler is used as a part of BrainDuck computer, which acts as a translator of brainfuck &quot;human-readable&quot; language into binary form, used by BrainDuck CPU. Those instructions and their binary codes have no relation with brainfuck itself, therefore the computer is not called brainfuck computer, because it is not brainfuck. But it does not mean you cannot write and run brainfuck programs in it :) . At first, each compiler, including BrainDuck compiler, provides lexical analyzer for help with tokenize of the source code, used in syntax highlighting. Secondly, the compile compiles the source code into other (usually binary) form which is then understood by CPU. . Compilation takes part by user request (clicking on &#39;compile&#39; icon in the main window). After compilation is successful, the compiler usually loads the translated program into operating memory, and saves the translation into a file. So it is with BrainDuck compiler. Files have .hex extension.[1] . Installation and run . The compiler is provided as part of emuStudio. It is not deployed as individual package. The compiler can be found in compilers/ directory with name brainc-brainduck.jar. . The compiler can be run from command line, with command: . java -jar brainc-brainduck.jar [--output output_file.hex] [source_file.b] . To query for more information, run the compiler with command: . java -jar brainc-brainduck.jar --help . Using compiler in command line might be useful for emulation automation. . Language Syntax . The language of BrainDuck compiler is almost identical with the original brainfuck. However, brainfuck interpreter is not specified well-enough, so there are open questions how to treat with some special situations, which are described below. . Generally, the language knows eight instructions. They are best described when they are compared with C language equivalent. Brainfuck uses only single data pointer called P, pointing to bounded memory.[2] . | BrainDuck architecture conforms to true von-Neumann model, instead of classic Harvard-style interpreters. It means that program memory and data memory are not separated. The data pointer is therefore not initialized to 0 as programmers might expect and potentially there can be written brainfuck programs with self-modifications. | . Table 1. Brainfuck instructions Brainfuck instruction C language equivalent . &gt; . | P++ . | . &lt; . | P-- . | . + . | ++*P . | . - . | --*P . | . , . | *P = getchar() . | . . . | putchar(*P); . | . [ . | while (*P) { . | . ] . | } . | . The compiler is supplied with many example programms written in brainfuck. . Additional details . As was said before, specification of brainfuck language or interpreter implementation is not complete. There are left some details which might be solved differently in different implementations. In this version of BrainDuck implementation in emuStudio, the details are solved in the fixed way, as described below. . Comments . The compiler takes as a comment everything which is not the brainfuck instruction. From the first occurence of unknown character, everything to the end of the line is treated as comment. Exceptions are whitespaces, tabulators, and newlines.[3] . In the following example, everything starting with # is treated as comment, up to end of the line. . ++++[-] # Useless program in brainfuck. [-] clears the content of the memory cell. . Cell size . The memory cells are of 8-bit size (cells are bytes). . Memory size . The memory size is defined in brainduck-mem plug-in. In this version of emuStudio, it is 65536 cells. . End-of-line code . EOL is defined in brainduck-terminal plug-in. In the current version of emuStudio, it is a Newline character with ASCII code 10. . End-of-file behavior . EOF is defined in brainduck-cpu and brainduck-terminal plug-ins. In the current version of emuStudio, current cell (where P is pointing at) is changed to value 0.[4] . . 1. Intel HEX format, for more info see http://en.wikipedia.org/wiki/Intel_HEX 2. The boundary is specified in brainduck-mem plug-in 3. This practically means that it is impossible to write brainfuck program with syntax errors. 4. This is not how original brainfuck behaves, which is doing no change to the cell on EOF",
    "url": "/documentation/user/0.40/docs/brainduck/brainc-compiler.html",
    "relUrl": "/docs/brainduck/brainc-compiler.html"
  }
  ,"11": {
    "title": "CPU",
    "content": "CPU &quot;brainduck-cpu&quot; . BrainDuck CPU is used as a part of BrainDuck computer, which acts as the interpreter of BrainDuck instructions. Those instructions correspond with brainfuck language. . Program which is going to be executed is read from the operating memory, so the CPU must be connected with memory (brainduck-mem), in order to work properly. . Also, optionally (but commonly) it is should be connected with I/O device (brainduck-terminal), so input/output can be received/send from/to the device. Only one device can be used. . The CPU provides basic user interface in the form of status panel, which is visible in the emulator panel in the main window. . Breakpoints are supported, so as &quot;jump&quot; to specific location, which might be actually dangerous to use. . Installation and run . The BrainDuck CPU can be run only as a part of emuStudio. It is installed in location cpu/brainduck-cpu.jar. . Status panel . In the following image, you can see the status panel of brainduck-cpu. . It is split into three parts. Within &#39;Internal status&#39; part, there is shown content of registers IP and P. Register IP does not have counterpart in brainfuck. IP stands for &quot;instruction pointer&quot;. The content is pointing at the next instruction being executed. Register P is commonly known from brainfuck. It is pointer to data. . There is measured execution time, which is reset when user starts the program and stopped when either the program stops or the user stops it. . Loop level shows the depth level of brainfuck loop the program is in. For example, if instruction pointer points into middle of the program [[-]], to the - instruction, loop level is 2. . Running brainfuck programs . It is very important to reset CPU after each source code compilation. The reason is that after compilation register P is not changed. It therefore might point somewhere into compiled code in the memory. If the program was executed, changes in data would corrupt the program itself. . Resetting CPU would move the P register after first occurrence of memory cell with value 0. The value 0 in BrainDuck CPU represents halt instruction, which corresponds to EOF in brainfuck. .",
    "url": "/documentation/user/0.40/docs/brainduck/brainduck-cpu.html",
    "relUrl": "/docs/brainduck/brainduck-cpu.html"
  }
  ,"12": {
    "title": "Memory",
    "content": "Memory &quot;brainduck-mem&quot; . BrainDuck memory is used as a part of BrainDuck computer, which acts as the operating memory, holding both of brainfuck program and data. . BrainDuck CPU reads/writes instructions from/to the memory. Memory updates its cells and notifies debugger in emuStudio about the update. . The memory plug-in contains simple graphical window, a GUI, which provides a set of the following features: . paginated view of memory cells, arranged into 16x16 table per page. . | cells are displayed in hexadecimal form and can be changed directly by user. . | there are hard-coded 256 pages, so the memory size is 256 * (16x16) = 64 kB . | . Installation and run . The BrainDuck memory can be run only as a part of emuStudio. It is installed in location mem/brainduck-mem.jar. . Graphical user interface (GUI) . In the following screenshot, it is possible to see GUI of brainduck-mem. . A: Shows actually displayed page. Can be edited manually by entering a number and pressing ENTER key . | B: By double-clicking on a memory cell, the cell editor is enabled and user can overwrite the content of the cell. Supported number formats are decimal or hexadecimal. Hexadecimal number must begin with 0x prefix. . | C: By clicking on button Page down, the page number is increased; button Page up decreases the page number. . | .",
    "url": "/documentation/user/0.40/docs/brainduck/brainduck-mem.html",
    "relUrl": "/docs/brainduck/brainduck-mem.html"
  }
  ,"13": {
    "title": "Terminal",
    "content": "Terminal brainduck-terminal . BrainDuck terminal is used as a part of BrainDuck computer, which acts as an interactive console, or generally interactive input/output provider. It was written with support of GUI, but can be used also in emulation automation, in which case it loads input from the file and output to another file. . Supported features are: . monospace font, unlimited width and height, white background . | blinking cursor simulation . | keyboard input; binary codes can be entered with special dialog . | terminal interprets some special characters like 0x8 (backspace), 0x9 (tab), 0xA (LF), and 0x10 (CR) . | . Installation and run . The BrainDuck terminal can be run only as a part of emuStudio. It is installed in location devices/brainduck-terminal.jar. . Graphical User Interface (GUI) . In the following image, BrainDuck terminal window is shown: . It&#8217;s easy and simple. BrainDuck CPU as it interprets . (dot) instructions, it sends the output to this terminal and it is displayed on screen. . Input cannot be entered anytime. In brainfuck, input is requested through , instruction. Only when CPU encounters , (comma) instruction, user is asked to enter input. This situation is marked with geen icon in the bottom-left corner: . Next to the icon, there is a blue &quot;ASC&quot; button. This button can be used for entering binary values as input. Special little dialog will appear asking user to enter space-separated numbers, representing ASCII codes of the input. . | The terminal do not display characters with ASCII codes less than 32. Only some special characters are interpreted: 0x8 (backspace), 0x9 (tab), 0xA (LF), and 0x10 (CR) | .",
    "url": "/documentation/user/0.40/docs/brainduck/brainduck-terminal.html",
    "relUrl": "/docs/brainduck/brainduck-terminal.html"
  }
  ,"14": {
    "title": "RAM",
    "content": "Table of Contents 1. Introduction | 2. Brief description 2.1. Abstract schema | 2.2. Automatic emulation | . | 3. Compiler for RAM machine 3.1. Installation and run | 3.2. Language description | . | 4. RAM Simulator Engine 4.1. Installation and run | 4.2. Status panel | . | 5. Program Memory 5.1. Installation and run | 5.2. Graphical user interface (GUI) | . | 6. Abstract tapes 6.1. Installation and run | 6.2. Graphical user interface (GUI) | 6.3. Configuration file | 6.4. Automatic emulation | 6.5. Using abstract tapes in your emulator | . | . 1. Introduction . Random Access Machine (RAM) is an abstract machine, invented to study algorithmic complexity of programs written on register-based computers. It is equivalent to Turing machine, and has a close relationship with a so-called Harvard computer architecture, which has separated storage for program and data. The implication of this model is that it is not possible to modify instructions. . | In contrast, there exist a Random Access Stored Program machine (RASP), which is close to von-Neumann computer architecture. | . Both RAM and RASP are implemented as emulators, or maybe better - simulators in emuStudio. This documents describes the RAM simulator. . 2. Brief description . RAM machine consists of several parts: input tape (read-only), output tape (write-only), program memory, data memory or registers (read/write) and a control unit (&quot;engine&quot;), as can be seen in the following image: . Input tape acts as a water-tap; the input data can be read from it, causing the input head moving to the next unread symbol. The head can never return to previously read symbol. . Output tape, on the other hand, acts as a sink. The output data can be written to it, causing the output head moving to the next &quot;empty&quot; symbol. The head can also never return to the previously written symbol. . Data memory - registers tape - represents the random-access memory. It consists of so-called registers, abstract cells with arbitrary size. These registers are ordered - each one has assigned the index - its position within the tape, called the address. The tape head can move arbitrarily up and down - but it has its minimum position. It is the first register, R0, called the accumulator. Below there are unlimited number of higher-positioned registers. . The role of accumulator is kind of special - it often acts as an implicit operand for many instructions, or implicit place for storing the result of such instructions. . Program memory is a bounded ordered sequence of registers; each of them is identified by its index within the tape, called address. Data memory is also ordered sequence of registers, but like the I/O tapes - bounded just from one side. . Since RAM machine is somewhat abstract, it frees the user from thinking about some issues, and just assumes that: . The size of the problem is always small enough to fit in the RAM memory, . | Data used within the computation are always small enough to fit in one register. . | . The RAM virtual machine in emuStudio consists of the following plug-ins: . ramc-ram: Compiler of the RAM language, very simple &quot;assembler&quot;-like language . | ram-cpu: RAM simulator engine . | ram-mem: Program memory . | abstractTape-ram: Device which represents the &quot;tape&quot; used in RAM, other than program memory. The abstract schema must define three instances of this device, representing register, input and output tapes. . | . 2.1. Abstract schema . In order to use RAM, there must exist the abstract schema of the &quot;computer&quot;, saved in the configuration file. Abstract schemas are drawn in the schema editor in emuStudio (please see emuStudio main module documentation for more details). The following image shows the schema of RAM machine simulator: . The &quot;&#8594;&quot; arrows are in direction of dependency. So for example ramc-ram depends on ram-mem, because compiled programs are directly loaded into memory. . The roles of the abstract tapes are assigned by the RAM &quot;CPU&quot; on runtime. . 2.2. Automatic emulation . RAM is one of computers which supports automatic emulation. In general, automatic emulation can be interactive, or not interactive. In case of the RAM emulator, only non-interactive emulation is useful. It is because during emulation it is not possible to interact (e.g. pass new input to the input tape) in any way. . Changes to any abstract tapes are written to the corresponding output file. For more specific information, please see Automatic emulation section of the abstract tape chapter. . Command line for starting non-interactive automatic emulation: . java -jar emuStudio.jar --config RAM --input examples/ramc-ram/factorial.ram --auto --nogui . configuration config/RAM.conf will be loaded . | input file for compiler is one of the examples . | (--auto) automatic emulation mode will be performed . | (--nogui) non-interactive version will be set . | . After the run, the following output on the stdout can be expected: . [INFO] Loading virtual computer: RAM [INFO] All plugins were loaded successfully. [INFO] Being verbose. Writing to file:registers_(storage_tape).out [INFO] Being verbose. Writing to file:input_tape.out [INFO] Being verbose. Writing to file:output_tape.out [INFO] Starting emulation automatization... [INFO] Compiler: RAM Compiler [INFO] CPU: Random Access Machine (RAM) [INFO] Memory: RAM Program Tape [INFO] Memory size: 0 [INFO] Device #00: Abstract tape [INFO] Device #01: Abstract tape [INFO] Device #02: Abstract tape [INFO] Compiling input file: examples/ramc-ram/factorial.ram [INFO] Compiler started working. [INFO] [Info (000)] RAM Compiler, version 0.39-SNAPSHOT [INFO] [Info (000)] Compile was successful. [INFO] [Info (000)] Compiled file was loaded into operating memory. [INFO] [Info (000)] Compilation was saved to the file: /home/vbmacher/tmp/net.emustudio/examples/ramc-ram/factorial.ro [INFO] Compiler finished successfully. [INFO] Program start address: 0000h [INFO] Resetting CPU... [INFO] Running emulation... [INFO] Normal stop [INFO] Instruction position = 0011h [INFO] Emulation completed . Then, in the current working directory, there will be created three new files: . input_tape.out . | registers_(storage_tape).out . | output_tape.out . | . The format of the files is described in already mentioned Automatic emulation section of the abstract tape chapter. . 3. Compiler for RAM machine . RAM has a very simple assembler-like language, consisting of direct and indirect reading/writing from/to registers or input/output tape. In addition, there are three control-flow instructions. . 3.1. Installation and run . The compiler is provided as part of emuStudio. It is not deployed as individual package. The compiler can be found in compilers/ directory with name ramc-ram.jar. . 3.2. Language description . The program written for this compiler consists of two sections: . INPUT section INSTRUCTIONS section . 3.2.1. Input section . The INPUT section contains definitions the content of input tape - one or more lines in the form: . &lt;input&gt; ITEMS . where ITEMS is a space-separated list of inputs. Each input is one word - it might be any number or string. By default, every cell in the input tape is a string, and it is not interpreted as some data type. It is only in time when it is used - the instruction which works with the cell defines of which &quot;type&quot; it should be. . For example, input section might be: . &lt;input&gt; 1 2 3 hello world! . In this case, there are five inputs: numbers 1,2,3, then word &quot;hello&quot; and the last one is &quot;world!&quot;. . 3.2.2. Instructions section . There exist many possible formats or variations of RAM instructions, unfortunately the syntax is not very unified. I guess the reason is that RAM is not a real machine, and for the purposes of the algorithm analysis the machine is so simple that it&#8217;s description is repeated in almost every paper where it appears. . For this reason, instructions format or the whole vocabulary might be different of what you expected or used for. We have to live with it; but the differences are really small. . Instructions should follow the Input section, but the sections can be mixed. It is just good practice to have input separated from the code. Each instruction must be on separate line, in the form: . [LABEL:] INSTRUCTION [; optional comment] . Each instruction position can be optionally labelled with some identifier (LABEL field), followed by a colon (:) character. The labels can be then referred in other instructions. . Comments begin with a semicolon (;) character and continue to the end of the line. There are no multi-line comments. . Instructions consists of the operation code and optional operand, separated with space (` `). . Operation code is expressed as an abbreviation of corresponding operation (e.g. SUB for SUBtraction). Operand can be one of three types: constant (=i), direct operand (i), where i specifies the register index on tape and indirect operand (*i), where the address of operand specified is stored in register Ri. . The following table describes all possible instructions, usable in the RAM simulator: . =i i *i . HALT . | | halts the simulation . | | . READ . | | Ri &#8592; next input . | | . WRITE . | output &#8592; i . | output &#8592; Ri . | output &#8592; M&lt;Ri&gt; . | . LOAD . | R0 &#8592; i . | R0 &#8592; Ri . | R0 &#8592; M&lt;Ri&gt; . | . STORE . | | Ri &#8592; R0 . | M&lt;Ri&gt; &#8592; R0 . | . ADD . | R0 &#8592; R0 + i . | R0 &#8592; R0 + Ri . | R0 &#8592; R0 + M&lt;Ri&gt; . | . SUB . | R0 &#8592; R0 - i . | R0 &#8592; R0 - Ri . | R0 &#8592; R0 - M&lt;Ri&gt; . | . MUL . | R0 &#8592; R0 * i . | R0 &#8592; R0 * Ri . | R0 &#8592; R0 * M&lt;Ri&gt; . | . DIV . | R0 &#8592; R0 / i . | R0 &#8592; R0 / Ri . | R0 &#8592; R0 / M&lt;Ri&gt; . | . JMP . | | IP &#8592; i . | | . JZ . | | if R0 == 0 then IP &#8592; i . | | . JGTZ . | | if R0 &gt; 0 then IP &#8592; i . | | . The table describes also the behavior of each instruction. Compiler does not care about the behavior, but about the instructions syntax, which is also incorporated in the table. . For example, this is a valid program: . ; COPY(X,Y) ; ; input: X -&gt; r1 ; Y -&gt; r2 ; ; output: X -&gt; Y ; Y -&gt; Y &lt;input&gt; 3 4 world hello &lt;input&gt; sss ; load X,Y read 1 read 2 ; load r.X, r.Y read *1 read *2 ; copy load *2 store *1 halt . 4. RAM Simulator Engine . The plug-in responsible for execution of the simulation of RAM machine is called ram-cpu. Even if we&#8217;re supposed to talk about RAM simulator, because emulation is connected more with imitation of real hardware than abstract machine, there is a plugin which calls itself a RAM CPU. It is really not accurate, but CPU nowadays means something as the main or core engine of the computation which the machine does. So the name is stick rather with this convention. . The plug-in strictly requires a ram-mem, and three instances of abstractTape-ram plug-ins, representing the tapes. After boot, the CPU assigns the specific meaning to each tape. . 4.1. Installation and run . The RAM CPU can be run only as a part of emuStudio. It is installed in location cpu/ram-cpu.jar. . 4.2. Status panel . In the following image, you can see the status panel of ram-cpu. . It is split into three parts. Within &#39;Internal status&#39; part, there is shown content of registers R0 (accumulator) and IP. Register IP is the position of the program memory head. It stands for &quot;instruction pointer&quot;. It is pointing at the next instruction being executed. . The input/output part shows the next unread symbol (&quot;next input&quot;), and the last symbol written to the output tape (&quot;last output&quot;). This is just for the convenience; it is possible to see the same values in particular tape devices. . The last part, &quot;Run state&quot;, shows in which state the whole emulation is, and it is common to all emulators in emuStudio. The state &quot;breakpoint&quot; means that the emulation is paused. . 5. Program Memory . RAM memory is used as a part of RAM simulator, which acts as the &quot;program memory&quot;, holding just the program. . RAM CPU reads instructions from this memory. The instructions can be written here only by compiling the source code, or loading already compiled binary image. . The memory plug-in contains simple graphical window, a GUI, which provides a set of the following features: . It computes time and space complexity of the program . | It shows the memory content (the &quot;program&quot;) as the list of disassembled instructions . | . 5.1. Installation and run . The RAM memory can be run only as a part of emuStudio. It is installed in location mem/ram-mem.jar. . 5.2. Graphical user interface (GUI) . The memory GUI can be seen in the following picture. . A: Opens already compiled program into memory. Previous program will be dismissed. . | B: Clears memory. . | C: Shows uniform time complexity for the actual program. . | D: Shows uniform space complexity for the actual program. . | . Uniform time complexity means maximum number of instructions based on the input N. Uniform space complexity means maximum number of used registers. . 6. Abstract tapes . Abstract tapes, in general, are used in various abstract machines. Probably the best known are Turing machine, RAM machine and RASP machine. Plug-in of the abstract tape for emuStudio is called abstractTape-ram. . There are several properties which an abstract tape might have: . Bounded, one-side bounded or unbounded . | Random access (allowing to move head in both directions) or linear access (allowing to move head only in one direction) . | Specific or any cell content type (e.g. cells are integers, or strings, or can be any value?) . | Read only, or read-write cells . | Purpose of the tape (title) . | . This plug-in allows to set up such properties, but those are set up by the virtual computer which uses it, not by the user. For more information, please see the Using abstract tapes in your emulator section. . Currently, there are just two virtual computers utilizing this plug-in: . RAM machine . | RASP machine . | . After emuStudio is run, RAM CPU (or RASP CPU) sets up properties for all used tapes. So the tape &quot;purpose&quot; and behavior is set in run time. . 6.1. Installation and run . The abstract tape can be run only as a part of emuStudio. It is installed in location devices/abstractTape-ram.jar. . 6.2. Graphical user interface (GUI) . The graphical user interface of the abstract tape is very simple. In order to open it, select the tape in the peripheral devices list in the Emulator panel. Then, click on the &quot;Show&quot; button. . The symbol, highlighted with the blue color is the current head position, in this case. In order to manipulate with particular symbols, one must select the symbol, which appears in bold, as in the following image: . A: If the tape allows it, one can add new symbol before the selected one in the tape. In the image, the tape does not allow it. . | B: The tape content area. Usually, each row consists of the symbol &quot;index&quot; or position within the tape, followed by the symbol itself. . | C: If the tape allows it, one can add new symbol after the last one in the tape. In the image, the tape allows it. . | D: Removes selected symbol from the tape. . | E: Edits the tape symbol. The symbol must be selected. . | F: Clears the tape content . | . 6.2.1. Settings . The tape allows to edit some settings from the graphical mode; to open the settings window click on the &quot;Settings&quot; button below the peripheral devices list in the Emulator panel. The window can be seen in the following image: . A: Do not allow the tape to fall behind other window . | B: Show the tape right after emuStudio start (see Configuration file section) . | . 6.3. Configuration file . Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please read the section &quot;Accessing settings of plug-ins&quot; in the user documentation of Main module to see how the settings can be accessed. . The following table shows all the possible settings of Abstract tape plug-in: . Table 1. Settings of Abstract tape Name Default value Valid values Description . alwaysOnTop . | false . | true, false . | Whether the tape GUI should not allow to fall behind other windows . | . showAtStartup . | false . | true, false . | If the tape should be shown automatically after emuStudio is started . | . 6.4. Automatic emulation . Abstract tape supports automatic emulation. It means, that every change to it is being written to a file. The file name is devised from the title of the tape, by the following algorithm: . At first, all spaces in the title are replaced with underscore (_) . | Then, all &quot;unwanted&quot; characters are also replaced with underscore . | Every character is converted to lower-case . | Finally, the .out extension is added at the end. . | . Unwanted characters are the following: *, ., #, %, &amp;, +, !, ~, /, ?, &lt;, &gt;, ,, |, {, }, [, ], &quot;, `, = . 6.5. Using abstract tapes in your emulator . | This section is for developers of emulators. If you do not plan to create custom virtual computers, you can safely skip this section. In order to get started with developing plug-ins for emuStudio, please read tutorial &quot;Developing emuStudio Plugins&quot;. | . The Abstract tape plug-in can be used in various computers. Besides standard operations which are provided by emulib.plugins.device.DeviceContext interface, it provides custom context API, enabling to setting up properties described in the introduction section. . Usually, the tapes are used by CPU plug-ins, but it is ofcourse possible to use it in any other plug-in. You can obtain the context during the initialize() method of the plug-in main class. The context is named net.sf.net.emustudio.devices.abstracttape.api.AbstractTapeContext: . ... public void initialize(SettingsManager settings) { ... AbstractTapeContext tape = contextPoolImpl.getDeviceContext(pluginID, AbstractTapeContext.class); ... } . The tape context interface is as follows: . package net.sf.emustudio.devices.abstracttape.api; import emulib.annotations.ContextType; import emulib.plugins.device.DeviceContext; /** * Public API of the abstract tape. */ @ContextType public interface AbstractTapeContext extends DeviceContext&lt;String&gt; { /** * Clear content of the tape. */ void clear(); /** * Set this tape to left-bounded or unbounded. * * @param bounded true if the tape should be left-bounded, * false if unbounded. */ void setBounded(boolean bounded); /** * Determine if the tape is left-bounded. * * @return true - left-bounded, false - unbounded. */ boolean isBounded(); /** * Move the tape one symbol to the left. * * If the tape is left-bounded and the old position is 0, tape won&#39;t move. Otherwise the tape * will expand to the left - add new empty symbol to position 0 and shift the rest of the content to the right. * * @return true if the tape has been moved; false otherwise (if it is left-bounded and the position is 0). */ boolean moveLeft(); /** * Move tape to the right. If the tape is too short, it is expanded to the right (added new empty symbol). */ void moveRight(); /** * Allow or disallow to edit the tape. * * If the tape is editable, the user (in GUI) can add, modify or remove symbols from the tape. * Otherwise it is driven only by the CPU. * * @param editable true if yes, false if not. */ void setEditable(boolean editable); /** * Get symbol at the specified position. * * @param pos position in the tape, starting from 0 * @return symbol at given position; if the position is out of bounds, then empty string is returned. */ String getSymbolAt(int pos); /** * Set symbol at the specified position. * * If the position is &lt; 0, then no symbol will be set. * * If the position is &gt; tape size, empty symbols will be added until the required tape size is ensured. * Then, the symbol is added at the specified position. * * This method should be used only when loading some initial content to the tape. * * @param pos position in the tape, starting from 0 * @param symbol symbol value */ void setSymbolAt(int pos, String symbol); /** * Sets whether the symbol at which the head is pointing should be &quot;highlighted&quot; in GUI. * * @param visible true if yes; false otherwise. */ void setHighlightHeadPosition(boolean visible); /** * Seths whether the tape should be cleared at emulation reset. * * @param clear true if yes; false otherwise. */ void setClearAtReset(boolean clear); /** * Set title (purpose) of the tape. * * @param title title of the tape */ void setTitle(String title); /** * Determines if the symbol positions should be displayed in GUI. * * @return true if yes; false otherwise */ boolean showPositions(); /** * Set whether the symbol positions should be displayed in GUI. * * @param showPositions true if yes; false otherwise. */ void setShowPositions(boolean showPositions); /** * Get the tape head position. * * @return current position in the tape; starts from 0 */ int getHeadPosition(); /** * Get the size of the tape * * @return tape size */ int getSize(); /** * Determine if the tape is empty. * * @return true if the tape is empty; false otherwise. */ boolean isEmpty(); @Override default Class&lt;String&gt; getDataType() { return String.class; } } .",
    "url": "/documentation/user/0.40/docs/ram/",
    "relUrl": "/docs/ram/"
  }
  ,"15": {
    "title": "RASP",
    "content": "Table of Contents 1. Brief description | 2. Installation and run 2.1. Directory structure | 2.2. Abstract schema | . | 3. Compiler raspc-rasp 3.1. Installation and run | 3.2. Language syntax | . | 4. CPU rasp-cpu 4.1. Installation and run | 4.2. Supported instructions | 4.3. CPU Status panel | . | 5. Memory rasp-mem 5.1. Installation and run | 5.2. Graphical user interface (GUI) | . | . 1. Brief description . Random Access Stored Program machine (RASP) is an abstract von-Neumann computer. It means it does not represent a physical device, but ranther it is intended to work as a model to study von-Neumann architecture, without the need to care about specific manufacturer&#8217;s hardware details. . Firstly, it is usefull to present Random Access Stored Program (RASP) machine&#8217;s architecture&#8201;&#8212;&#8201;it is schematically depicted in the following figure. . As we can see, the control unit, i.e. processor, reads data from the input tape and writes results of executed operations onto the output tape. The tapes serve as a form of I/O devices. The two heads&#8201;&#8212;&#8201;reading &#174; and writing (W), are pointers to current reading/writing position. . As already stated, RASP machine represents a von Neumann computer. This implies that the operating memory exists as a single unit in which both program and data can reside. The segment containing the program is organised in the way that two adjacent cells contain instruction/operand alternately. The memory can be read as well as written to by the control unit. . 2. Installation and run . There is no need to download/install RASP separately as it is included in the emuStudio distribution. Here is the structure of the directories containing the files neccessary for our RASP virtual computer: . 2.1. Directory structure . config/RASP.conf: configuration file of RASP architecture. . | compilers/raspc-rasp.jar: RASP compiler plug-in. . | cpu/rasp-cpu.jar: RASP CPU emulator - CPU plug-in. . | mem/rasp-mem.jar: RASP main memory plug-in. . | . RASP virtual computer in emuStudio uses with tapes as I/O devices. For this purpose, abstractTape-ram.jar plug-in is used (&#169; P. Jakubčo). . 2.2. Abstract schema . Each virtual computer in emuStudio is defined by so called &#39;abstract schema&#39; (please see emuStudio User documentation). It defines all the parts of its architecture (what it consists of) and inner communication (how architecture components are interconnected). Following figure presents RASP abstact schema: . 3. Compiler raspc-rasp . RASP compiler is included in the architecture of RASP virtual computer in emuStudio. Its purpose is to translate source code of a RASP program into the form executable by the RASP CPU emulator. . It includes lexical analyzer which is responsibe for recognising lexical units within the source code. It also enables syntax highlighting. Then, the code goes through syntax analysis which checks for syntax errors and builds up the syntactic tree. The tree is then passed through and binary code executable by the emulator is generated. . As with the other emuStudio compilers, you start the compilation by the &quot;Compile source&quot; icon in the main menu. The result of the compilation is saved into a binary file with the .bin extension and also loaded into the RASP operating memory. . 3.1. Installation and run . RASP compiler plugin is already included in emuStudio distribution, in location compilers/raspc-rasp.jar. . 3.2. Language syntax . 3.2.1. Program start definition . As RASP is a von-Neumann computer, both the program and the data reside in the same memory module. Therefore, we need to clearly specify, where the program start address is as CPU must know where to start emulation. We do so by the org directive followed by a positive ineteger. Program start definition must be the first line of the source code. Please, do not place any empty lines before it. Here, an example follows: . org 5 . | If you do not specify the program start address, or if you set it to 0 (org 0), the default pre-set value will be used, which is 20. The compiler will warn you about this, so do not worry. Setting program start to 0 is not allowed as register R0 is used as the accumulator and therefore any instruction written here would be overwritten sooner or later. | . 3.2.2. Supported instructions . All RASP emulator supported instructions together with their semantics are available in the RASP CPU documentation. There are three types of operands of those instructions: . register - e.g. READ 1 . | constant - e.g. WRITE =2 - you specify that operand of an instruction should be interpreted as a constant by the = character. . | label, which is operand of jump instructions (JMP, JZ, JGTZ), e.g. JMP label . | . 3.2.3. Line of code structure . Each RASP instruction with its operand MUST be on a separate line, otherwise the code will not compile. . A single line of code consists of instruction followed by its operand. The line can be optionally started with a label. It is possible to put the label and the instruction on two separate lines, however, please, do not place any empy lines between the label and the instruction. . Example (WRITE 2 can be on a separate line): . labelName: WRITE 2 . 3.2.4. Comments . RASP compiler supports one-line comments. You start them with a semicolon (;): . ;this is a comment . You can append a comment to an existing line, e.g. . write 2 ;comment . or put it on a completely new line. . 4. CPU rasp-cpu . RASP CPU is the core of the RASP virtual computer. Its purpose is to execute RASP program composed of RASP instructions which is stored in the RASP memory. The CPU is therefore connected with the memory. . To run &#39;interactive&#39; RASP programs (programs reading user input and writing something to the output), input and output tapes are needed. They are included there in default RASP configuration. . 4.1. Installation and run . RASP CPU plugin is already included in emuStudio distribution, in location cpu/rasp-cpu.jar. . 4.2. Supported instructions . RASP CPU emulator supports the following instructions: . Table 1. RASP instructions Operation code Instruction mnemonic code Semantics . 18 . | HALT . | finish program execution . | . 1 . | READ i . | read from input tape into register Ri . | . 2 . | WRITE =i . | write constant i onto the output tape . | . 3 . | WRITE i . | write the content of the register Ri onto the output tape . | . 4 . | LOAD =i . | load the accumulator (register R0) with the i constant . | . 5 . | LOAD i . | load the accumulator (register R0) with the content of Ri register . | . 6 . | STORE i . | store the accumulator (register R0) content into register Ri . | . 7 . | ADD =i . | increase accumulator (register R0) value by constant i . | . 8 . | ADD i . | increase accumulator (register R0) value by the value of register Ri . | . 9 . | SUB =i . | decrease accumulator (register R0) value by constant i . | . 10 . | SUB i . | decrease accumlator (register R0) by the value of register Ri . | . 11 . | MUL =i . | multiply accumulator (register R0) by constant i . | . 12 . | MUL i . | multiply accumulator (register R0) by the value of register Ri . | . 13 . | DIV =i . | divide accumulator (register R0) by constant i . | . 14 . | DIV i . | divide accumulator (register R0) by the value of register Ri . | . 15 . | JMP l . | set instruction pointer (IP) to the address pointed to by the label l . | . 16 . | JZ l . | set instruction pointer (IP) to the address pointed to by the label l if value of the accumulator (register R0) is zero (R0 = 0) . | . 17 . | JGTZ l . | set instruction pointer (IP) to the address pointed to by the label l if value of the accumulator (register R0) is greater than zero (R0 &gt; 0) . | . 4.3. CPU Status panel . There is a simple GUI window provided for the RASP CPU. It displays the two most important values: . current value of the accumulator (R0 register) . | current value of the instruction pointer (IP) which points to current position within the executed program . | . Also, information about the current RUNNING STATUS is displayed. . Following figure shows a screenshot: . 5. Memory rasp-mem . RASP memory plug-in serves as the main store (operating memory) for the RASP virtual computer. As already mentioned in the introduction of this manual, RASP is an example of von-Neumann architecture, which implies that both program and data reside in the same memory module. . After compilation of a RASP source code file the compiled program is loaded into here. During the process of the emulation, the CPU plug-in reads instructions an their operands and writes results of the operations from/to the memory. . 5.1. Installation and run . RASP memory plugin is already included in emuStudio distribution, in location mem/rasp-mem.jar. . 5.2. Graphical user interface (GUI) . During the emulation, user can view current content of the operating memory in a simple GUI window: . It is also possible to load a compiled memory image from a file by clicking on the OPEN icon: . After that, you can choose the binary file you want to load. . By clicking on the CLEAN icon, you can clean the entire memory content: . The table with memory cells content is editable. By double-clicking on a row you can simply edit the value. You confirm your changes by the ENTER key. . | If you edit a cell that contains an instruction, you edit its operation code, e.g. if a cell contains the ADD = instruction (operation code 7) and you change the cell to 9, the operation code will be overwritten. As a result, the instruction changes to SUB =. It means that you cannot write number 9 as a data item here, only as an operation code. | .",
    "url": "/documentation/user/0.40/docs/rasp/",
    "relUrl": "/docs/rasp/"
  }
  ,"16": {
    "title": "SSEM",
    "content": "Well, there is no user documentation for the SSEM computer. This computer is provided as the result of the developer&#8217;s tutorial of how to implement a custom computer in emuStudio. . I strongly suggest to look at this nice tutorial! .",
    "url": "/documentation/user/0.40/docs/ssem/",
    "relUrl": "/docs/ssem/"
  }
  ,"17": {
    "title": "BrainDuck",
    "content": "Introduction . BrainDuck is an abstract computer for emuStudio, which mimics brainfuck programming language. Originally, brainfuck was developed by Urban Miller and it is well-known fact that the language has minimalistic compiler and it&#8217;s eight instructions don&#8217;t prevent it to be Turing complete. Also, there exist many extensions of the language and there are organized programming contests in brainfuck worldwide. But all of that can be read at Wikipedia or at other sources. . BrainDuck architecture is just a name for virtual computer in emuStudio, and consists of these plug-ins: . brainc-brainduck: Compiler of brainfuck language (original, without extensions) . | brainduck-cpu: Brainfuck emulator acting like CPU with two registers . | brainduck-mem: Virtual operating memory which holds both compiled brainfuck program and data . | brainduck-terminal: Virtual terminal for displaying the output and requesting for input. . | . All these plug-ins are free software, released under GNU GPL v2 license. The source code is freely available online. . Implementation language is Java SE 8. The implementation technology of visual components is Java Swing. All plug-ins use library emuLib version 9.0.0. . Brief description . BrainDuck is implemented as von Neumann architecture. It implies that the program and data are shared in the single memory. This is not a common approach of implementing brainfuck interpreters, and it might be changed in the future. . As implementing a brainfuck interpreter, one must deal with several portability issues, which include: . Memory cell size (solved in brainduck-memory and brainduck-cpu) . | Memory size (number of memory cells) (solved in brainduck-memory) . | End-of-line code (solved in brainduck-terminal) . | End-of-file behavior (solved in brainduck-cpu and brainduck-terminal) . | . The solution is spread across the plug-ins, as you can see in the parentheses. Chapters devoted to plug-ins&#39; description contain specific information. . Installation and run . At first, please download and install emuStudio distribution. BrainDuck is already included and ready for use. . Directory structure . For further manipulation with BrainDuck-specific files, here&#8217;s the file organization in directories: . config/BrainDuck.conf: configuration file of BrainDuck architecture. Can be edited in schema editor of emuStudio . | compilers/brainc-brainduck.jar: BrainDuck compiler plug-in. . | cpu/brainduck-cpu.jar: BrainDuck emulator (CPU plug-in). . | devices/brainduck-terminal.jar: BrainDuck terminal device. . | mem/brainduck-mem.jar: BrainDuck operating memory plug-in. . | . BrainDuck compiler (as many other compilers in emuStudio) depends on Java CUP parser runtime library, which is located at lib/java-cup-runtime-0.11a.jar. . Abstract schema . In order to use BrainDuck, there must be drawn the abstract schema, saved in the configuration file. Abstract schemas are drawn in the schema editor in emuStudio (please see emuStudio Main module documentation for more details). The following image shows the schema of BrainDuck computer: . The &quot;&#8594;&quot; arrows are in direction of dependency. So for example brainc-brainduck depends on brainduck-mem, because compiled programs are directly loaded into memory. . Between brainduck-cpu and brainduck-terminal exists bidirectional dependency, because input gained from terminal is passed to the CPU, and output is pushed from CPU to the terminal. . Plug-in brainduck-cpu also depends on brainduck-mem, because memory is a place where program and data are stored. .",
    "url": "/documentation/user/0.40/docs/brainduck/",
    "relUrl": "/docs/brainduck/"
  }
  ,"18": {
    "title": "Main module",
    "content": "Introduction . Various computers can be emulated. Real computers are assembled using hardware components, which are in the virtual environment represented by plug-ins. All virtual computers in emuStudio can have a compiler, must have one CPU and memory. Devices are optional. The virtual computer model is very similar to von Neumann model. . Plug-ins combinations and computer settings are written in configuration files. Each file represents one single computer. These configurations can be created manually (they&#8217;re Java properties files), but more convenient is the abstract schema editor. . Source code editor enables users to write programs for emulated computer. Very related part is compiler, which provides lexical and syntax analysis of the source code for the syntax highlighting. Most compiler plug-ins enable direct transfer of the written code into emulated computer. . Memory plug-ins allow modification of its content, which is immediately seen by CPU. . There exist command line interface which allows automation of emulation. It is useful for running programs without graphical interface - some devices allow gathering input and writing output from/to files. . Errors, and other messages are written in log file. If there is some problem, user can check the log file, or pass it to the issue for analysis by developers of emuStudio. . Installation and run . At first, please download emuStudio distribution. It is a ZIP file in the form emuStudio-[VERSION].zip. Unpack the file where you want to have emuStudio installed. . | please don&#8217;t forget to install Java Runtime Environment (JRE) of version 8 and later. | . After unzipping, go to the directory where emuStudio.jar is located, and run it with command from command line: . java -jar emuStudio.jar . Directory structure . emuStudio has very conservative and strict directory structure, as can be seen in the following list: . config/: location of configuration files. Each file represents abstract schema of one virtual (emulated) computer.[1] The files are human-readable.[2] . | compilers/: location of compiler plug-ins. . | cpu/: location of CPU plug-ins. . | devices/: location of device plug-ins. . | mem/: location of memory plug-ins. . | lib/: location of shared libraries. . | . If you want to use a custom virtual computer in emuStudio, it’s plug-ins and shared libraries must be put into appropriate subdirectories. Then, the abstract schema editor will find new plug-ins right after fresh start of emuStudio, and they can be used immediately. . Command line arguments . emuStudio accepts several command line arguments. Their description is accessible with --help argument: . $ java -jar emuStudio.jar --help emuStudio will accept the following command line parameters: . --config name : load configuration with file name --input name : use the source code given by the file name --output name : output compiler messages into this file name --auto : run the emulation automation --nogui : try to not show GUI in automation --help : output this message . Most of these arguments are self-explanatory. Some of them have meaning only when emulation automation is turned on (--nogui). For more information, please refer to section Automatic emulation. . Automatic emulation . Automatic emulation is a feature in which user should be able to run the emulation in a non-interactive mode, i.e. without any intervention. The emulation is being run from the command line and user just watches until it finishes. At the end, he collects logs and/or output files generated by plug-ins. He can then parse them and analyze them. . The feature has to be supported by individual plug-ins, so they will respect the settings from command line. Please refer to the plug-ins&#39; documentation for these details. . Every input must be prepared before the run and passed by command line. Example of running automatic emulation is as follows: . java -jar emuStudio.jar --auto --nogui --config &quot;MITS Altair8800&quot; --input example.asm --output compiler.txt . Command line argument --auto turns on the automatic emulation. If no other argument is provided, emuStudio will start as usual by asking to open a virtual computer. But after this step it will run the emulation with the settings as they appear in the computer configuration file (no source code compilation is performed). . The --nogui parameter tells to emuStudio that we don&#8217;t want to use GUI (graphical user interface) at all. In that case, we must provide a virtual computer in the command line (using --config argument). . | The plug-ins get the --nogui (as well as --auto) setting in the initialization phase, but it&#8217;s up to them if they will respect it. Whether they do or not should be in the documentation for the plug-ins you use. | . Analyzing the results . An important part of the analysis of result of the automatic emulation is the log saying what happened. By default, each run of automatic emulation creates (overwrites) a log file called automation.html, located in the root where emuStudio.jar file is. . The log file is in HTML format as you might suggest and contains common messages organized in a table. By default, each row of the table contains: . a start datetime of the emulation, . | relative time (in milliseconds) since the emulation started, . | message level . | the message itself . | . Usually, the first message is about which computer has been loaded. The second phase is compilation of the source code, if it is provided (by the --input argument in the command line). This should be logged, too. The next phase is the emulation itself and involves not much details in the log. Usually the most important messages are those if everything went fine, and the log file tries to keep it that simple. The final messages just say that the automatic emulation has finished and the state how it finished. . The log file format, and columns of the table can be of course customized, see section Logger configuration for more details. . Opening a computer . The first action which emuStudio does is loading a computer to be emulated. Virtual computers are described in abstract schemas, which are stored in configuration files (see Directory structure section). . Computers can be loaded either from command line or manually in GUI (by default). The open dialog is the first thing which appears to a user. . Left part contains a control panel and a list of all available virtual computers. When a user clicks at a computer, it&#8217;s abstract schema is displayed on the right. Double-clicking or clicking on the Open button loads selected computer. . Managing virtual computers . A: Adds new computer. The abstract schema editor will be opened. . | B: Deletes selected computer. Be aware of what you are doing - the action cannot be undone. . | C: Edits selected computer. The abstract schema editor will be opened. . | D: Saves the displayed abstract schema into image file. . | . Abstract schema editor . Abstract schema editor is a graphical editor for drawing abstract schemas of virtual computers for emulation in emuStudio. Users pick plug-ins which appear as &quot;boxes&quot; or elements on the screen. Then using connection lines those elements can be connected together to express a relation (that they can &quot;see&quot; each other). . When the abstract schema is completed, user must save it and then it will appear in the Managing virtual computers dialog. . Description of the control panel follows. . A: Save the virtual computer. . | B: Select a compiler. . | C: Select a CPU. . | D: Select a memory. . | E: Select a device. . | F: Use a connection line. The line is bidirectional by default. . | G: Set or unset the connection line to be bidirectional. If the line is not bidirectional, the source direction is the first clicked element and the target direction is the second clicked element. . | H: Remove an element from the schema. . | I: This drop-down list is used for selecting specific plug-in (element) in the abstract schema. See icons B, C, D, and E. Those names are just file names of plug-ins located in corresponding directory (see Directory structure section). . | J: Use / do not use a grid in the editor. Elements are &quot;snapped&quot; to the grid if it is used and it&#8217;s easier to draw the schema which looks good. The slider on the right then controls density of the grid. The density is saved in the configuration file of the edited computer. . | . | Virtual computers in emuStudio are following von-Neumann model of computers. It means that each computer must have a CPU, and memory. Optionally one or more devices, and optionally a compiler.[3] | . Connection lines . Connection line represents virtual &quot;connection&quot; between computer components. For the abstract schema it&#8217;s not important how the connection is realized. It&#8217;s safe to say that the connection is similar as if we say that a component &quot;sees&quot; the other component, in the direction of the arrow: . &lt;img src=&quot;/documentation/user/0.40/docs/main-module/images//connection.png&quot; alt=&quot;CPU &quot;sees&quot; operating memory&quot; width=&quot;but not vice-versa&quot;&gt; In the previous image, a CPU &quot;sees&quot; the memory, but not vice-versa. It means, CPU can read/write from/to memory, but memory is not seeing it, it can just answer to CPU requests. This connection makes sense in real-world computers. . Drawing connection lines is very easy. Connection line always connects exactly two elements in the schema. At first, user must click on already existing element in the schema. It&#8217;s just a click, not a drag. . Then a grey temporary line is being drawn having its end at the mouse position and moving with the mouse move. If the element is not really close, user can make a &quot;path&quot; by clicking somewhere in the schema. At those locations fixed-points are created. . When a user clicks at the second element, the temporary line disappears, and real connection line is created. . User can find the fixed-points later and move them by dragging. They can be removed by clicking at them with right button of the mouse. . Accessing settings of plug-ins . Each plug-in in the abstract schema can have its own &quot;hidden&quot; settings, which are used by particular plug-in. Most of these settings can be set in a &quot;Settings&quot; window accessible from Emulator panel &#8594; Peripheral devices window. However, plug-ins save their settings directly into the configuration file. The format of the file is Java properties file. . Settings of particular plug-in can be accessed by clicking on the plug-in in the Abstract schema editor with the right mouse button. . For example, the following image shows the settings of the plug-in standard-mem: . It is possible to Add, Remove or Save the settings. Please refer for particular plug-ins which settings they support. . Main window . Brief description . Main window the core part of emuStudio application. Users will spend there most of the time while working with emuStudio. It is part of the main module. Main module is a separated application developed independently from plug-ins. . The content of the window is split into two panels or tabs, placeholders for two actions users can do in emuStudio. The first tab is source code editor, second is emulator, used during computer emulation. . Source code editor . In the source code editor, users can write programs for emulated computer. However, the most important tool which allows translation of the source code into binary program readable by emulated CPU is a compiler. Therefore, users must use the right compiler. . Input language of a compiler is not limited, it can be either a kind of assembler, or even C or Pascal language. It depends on the compiler implementation, there can be many. The only restriction is that compiler must have output which is compatible with CPU which is currently being emulated. This cannot be checked automatically, users must take care of this. . Source code editor supports only the basic features, such as line numbering and syntax highlighting. Also, there is possibility to search/replace text. . Compilation must be run manually. Compiler output window shows all messages which compiler produces. The content is dependant on the used compiler, but most likely it will contain compilation success or errors messages. . Compiled source code can produce output binary file (for example a HEX file), and it&#8217;s automatically loaded into the operating memory.[4]. If the emulation is running, user must stop it first manually. . If another program is loaded in memory, it is not removed before loading currently compiled program, but the memory is overwritten at only those locations relevant to the compiled program. All the other content is left unchanged. . Emulating a computer . Emulator tab is shown in the following image. It is currently open with MITS Altair8800 computer with Intel 8080 CPU, and several devices: . The tab contains three main parts. The first one is very useful - listing of operating memory, disassembled into instructions. This part is called a debugger window, or &quot;debugger&quot;. The other part, below the debugger window is a list of all computer devices used (&quot;peripheral devices&quot;).[5] . The last part on the right displays status of the CPU used in this computer. Each CPU has its own implementation of how the status window look and what it displays. . Emulation lifecycle . In real world, users control the power of computer. Computers can be turned on, or turned off if it is running, basically by pressing a button. It&#8217;s obvious that we can turn on only not running or stopped computer. The power state is a term which denotes whether the computer is turned on or off. Each of those states define possible transitions to the other power state, executed by the action - pressing a button. . Computer behaves according to the power state in which it is. If it&#8217;s in a running state, it runs and we can see something on screen. If not, it is quiet and does nothing. . In emuStudio, emulation of a virtual computer can be controlled very similarly. In addition to basic run (turn on), stop (turn off) actions and stopped/running states, emulation work-flow in emuStudio allows reset and pause actions (plus paused state). . Emulation can be ready to run (the same as paused), running, or stopped. Each state has defined possible transitions to another states, by already mentioned actions. It&#8217;s possible to show those transitions in a state diagram, as in the following image: . | This workflow applies to emulation of a whole computer. Independent emulation of devices or other computer components cannot be controlled. The emulation of a computer starts when the CPU starts interpreting and executing instructions. | . Debugger window . Debugging is a process in which a programmer tries to analyze a program, usually with the intent to find bugs.[6] Debugger in emuStudio contains a debugger toolbar and list of few disassembled instructions from memory. In combination with CPU status panel, it&#8217;s the most powerful tool for seeing (and checking) all internal behavior of the emulated computer. . Debugger toolbar . Debugger toolbar contains buttons (icons) for controlling the emulation and accessing memory content. Most of these buttons are self-explanatory. If you hover over those icons, a help text is displayed of how to use the icon. . A: Reset emulation. . | B: Set next instruction position to 0. CPU will perform the next instruction from there. . | C: Set next instruction position to the (current - 1). This action can completely change displaying of instructions, since the new instruction position does not have to be correct in term of executing the current program. . | D: Stop emulation (which is either running or paused). . | E: Pause emulation (which is running). . | F: Run emulation (which is paused). . | G: Run emulation with timer (which is paused). Instructions are executed after elapsing specified time interval. A dialog will appear to enter the time interval. . | H: Step emulation (which is paused). CPU will execute only one - the very next - instruction. . | I: Jump to location. User will manually specify location (address in memory) for the next instruction to execute. . | J: Set/unset breakpoint. User can set or unset a breakpoint on specific memory location. When CPU reaches the breakpoint, it will pause there, waiting for next user action. . | K: Show operating memory. If the memory plug-in does not have a GUI, the icon is disabled. . | . List of instructions . The largest part of the debugger window a list of few disassembled instructions, so-called instructions window.[7] They are arranged in a table. The first column is usually interactive, allowing user to set breakpoints. Red strip is pointing to the very next instruction being executed. . | The size of disassembled memory (resulting in the number of disassembled instructions) is not configurable. Also, user cannot change instructions in this place. | . Sometimes the instructions shown in the debugger do not have to be disassembled correctly. There are two reasons for that: . first, instructions can have various binary sizes (e.g. one byte, two bytes, etc.) . | second, memory can contain programs on various locations, and emuStudio doesn&#8217;t know where. [8] . | . The implication is that if emuStudio starts to disassemble instructions at wrong location, the instructions will be disassembled incorrectly, or they can appear as invalid. . However, emuStudio is trying hard to find the nearest program start location at which it&#8217;s safe to start disassembling. Usually it&#8217;s just few instructions back, so it is a fast process. . Controlling of displaying the instructions . It&#8217;s possible to change the current instructions view. The window can be moved in a per-page fashion. The amount of instructions displayed in the window is always preserved. With the toolbar below the list it&#8217;s possible to change &quot;pages&quot; of the displayed instructions. . A: Go to the first page. The very first row corresponds to instruction position 0. . | B: Go backwards. User will specify the number of pages for going back. . | C: Go to the previous page. . | D: Go to the page where current instruction position is. . | E: Go to the next page. . | F: Go forwards. User will specify the number of pages for going forward. . | G: Go to the last page. It can cause incorrectly displaying of instructions. . | . Logger configuration . This is an advanced topic, but you might need it if something goes wrong. No software is bug-free in these days, and not a person is perfect. Sometimes it might happen that emuStudio is not working as expected, either it does not start (with weird message on screen), or it fails while running. . For that purpose, everything important is being logged (by default) in a console. If you encounter some problem and either want to fix it or report it, the logs, except steps to reproduce are the most important thing. . By default, logging is written to the standard output. However, in case of a problem it is a good practice to enable file logging. To enable file logging, open logback.xml file located in the root directory of emuStudio. Find a section named &lt;root ..&gt;, and change appender-ref from STDOUT to FILE as follows: . &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt; . The log file is named emuStudio.log and should be located in the location where emuStudio.jar is located. Every new run of emuStudio will append log messages into that file until emuStudio is terminated. . | By default, a rolling policy is enabled, which deletes logs older than 2 days and keeps the log in maximum size of 1 MB. It is of course configurable. | . | The log file is the best help about what went wrong for a developer which is trying to analyze or fix the problem. If you have encountered a problem with emuStudio, you should provide the log file for further analysis. | . Format, file name and content of the log file can be influenced. EmuStudio is using logback as the logging system. Configuration of the logging mechanism is in the file called logback.xml. For more information about how to configure loggers, please look at the page http://logback.qos.ch/manual/configuration.html. . . 1. The name of the file is the name of the computer, which is not very good idea. 2. Format of the files is Java properties. 3. The compiler is not really a computer component, but since it also can be interconnected to other components, it is part of the abstract schema. 4. If the used compiler supports it 5. With double-click user can open GUI window of that particular device, if it supports it. 6. The adverb &quot;to debug&quot; has a deep history. Very early computers were having of so-called vacuum tubes, which were core elements acting as electrically controlled switches. From time to time a computer stopped working, and the most usual reason was that a bug (real one) came in a vacuum tube. Maintainers of the computer had to go there and manually remove the bug. It happened that often, so that the process of removing bugs got a name - &quot;to de-bug&quot;. 7. Around 15 instructions are shown, but it depends on the CPU 8. Well, if it&#8217;s just program compiled from the source code editor, it knows.",
    "url": "/documentation/user/0.40/docs/main-module/",
    "relUrl": "/docs/main-module/"
  }
  ,"19": {
    "title": "MITS Altair8800",
    "content": "Introduction . Computer MITS Altair 8800 was named after a planet in one of the first episodes of Star Trek series. Having Intel 8080 CPU inside, with 256 bytes of memory, no display and keyboard is this computer, when comparing to the present era, absolutely ridiculous. His author, Ed Roberts, called the invention &quot;personal computer&quot;, which is now very common term. As Wikipedia states: . The Altair is widely recognized as the spark that ignited the microcomputer revolution. &#8212; Wikipedia Altair 8800 Altair 8800 is one of the oldest commercially available computers overall. Ed Roberts (founder and CEO of MITS corporation) was selling these machines by mail directly from the factory. . Various enthusiasts understood the power of Altair and started to develop software and hardware for the computer. Those people saw a freedom in Altair - some kind of a release from batch tasks ran on mainframe systems, maintained by elite. The phenomenon of a computer which could be put on the kitchen table allowed to make enormous money by two smart university students. In 1975, Paul Allen and Bill Gates wrote a trimmed version of BASIC programming language, called Altair BASIC, which pushed them directly to foundation of Microsoft corporation. . Basic configuration of MITS Altair 8800 was: . Processor . | Intel 8080 or 8080a . | . Speed . | 2 MHz . | . RAM . | from 256 bytes to 64 kB . | . ROM . | optional; usually EPROM Intel 1702 with 256 bytes. [1] . | . Storage . | optional; paper tapes, cassette tapes or 5.25&quot; or 8&quot; floppy disks (MITS 88-DISK) . | . Extensions . | at first 16 slots, later 18 slots . | . Bus . | famous S-100 . | . Video . | none . | . I/O . | optional; parallel or serial board (MITS 88-SIO) . | . Original software . | Altair DOS, CP/M, Altair BASIC . | . Altair8800 for emuStudio . In emuStudio, there exist two variants of the computer. These variants varies only with the used CPU. There is available either Intel 8080 emulator, or Zilog Z80 emulator. Lots of behavior and some devices was inspired by simh emulator. . Abstract schema for emuStudio (Intel 8080): . Abstract schema for emuStudio (Zilog Z80): . The following plug-ins are used in the schemas. Each plug-in is described in further sections. . Compiler . | as-8080 . | . Compiler . | as-z80 . | . Operating memory (RAM) . | standard-mem . | . CPU . | 8080-cpu . | . Another CPU . | z80-cpu . | . Device . | 88-sio . | . Device . | 88-disk . | . Device . | simhPseudo-z80 . | . Device . | adm3A-terminal . | . . 1. They were used for various bootloaders",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/",
    "relUrl": "/docs/mits_altair_8800/"
  }
  ,"20": {
    "title": "",
    "content": "",
    "url": "/documentation/user/0.40/",
    "relUrl": "/"
  }
  ,"21": {
    "title": "",
    "content": "RAM Simulator Engine . The plug-in responsible for execution of the simulation of RAM machine is called ram-cpu. Even if we&#8217;re supposed to talk about RAM simulator, because emulation is connected more with imitation of real hardware than abstract machine, there is a plugin which calls itself a RAM CPU. It is really not accurate, but CPU nowadays means something as the main or core engine of the computation which the machine does. So the name is stick rather with this convention. . The plug-in strictly requires a ram-mem, and three instances of abstractTape-ram plug-ins, representing the tapes. After boot, the CPU assigns the specific meaning to each tape. . Installation and run . The RAM CPU can be run only as a part of emuStudio. It is installed in location cpu/ram-cpu.jar. . Status panel . In the following image, you can see the status panel of ram-cpu. . It is split into three parts. Within &#39;Internal status&#39; part, there is shown content of registers R0 (accumulator) and IP. Register IP is the position of the program memory head. It stands for &quot;instruction pointer&quot;. It is pointing at the next instruction being executed. . The input/output part shows the next unread symbol (&quot;next input&quot;), and the last symbol written to the output tape (&quot;last output&quot;). This is just for the convenience; it is possible to see the same values in particular tape devices. . The last part, &quot;Run state&quot;, shows in which state the whole emulation is, and it is common to all emulators in emuStudio. The state &quot;breakpoint&quot; means that the emulation is paused. .",
    "url": "/documentation/user/0.40/docs/ram/ram-cpu.html",
    "relUrl": "/docs/ram/ram-cpu.html"
  }
  ,"22": {
    "title": "",
    "content": "Introduction . Random Access Machine (RAM) is an abstract machine, invented to study algorithmic complexity of programs written on register-based computers. It is equivalent to Turing machine, and has a close relationship with a so-called Harvard computer architecture, which has separated storage for program and data. The implication of this model is that it is not possible to modify instructions. . | In contrast, there exist a Random Access Stored Program machine (RASP), which is close to von-Neumann computer architecture. | . Both RAM and RASP are implemented as emulators, or maybe better - simulators in emuStudio. This documents describes the RAM simulator. . Brief description . RAM machine consists of several parts: input tape (read-only), output tape (write-only), program memory, data memory or registers (read/write) and a control unit (&quot;engine&quot;), as can be seen in the following image: . Input tape acts as a water-tap; the input data can be read from it, causing the input head moving to the next unread symbol. The head can never return to previously read symbol. . Output tape, on the other hand, acts as a sink. The output data can be written to it, causing the output head moving to the next &quot;empty&quot; symbol. The head can also never return to the previously written symbol. . Data memory - registers tape - represents the random-access memory. It consists of so-called registers, abstract cells with arbitrary size. These registers are ordered - each one has assigned the index - its position within the tape, called the address. The tape head can move arbitrarily up and down - but it has its minimum position. It is the first register, R0, called the accumulator. Below there are unlimited number of higher-positioned registers. . The role of accumulator is kind of special - it often acts as an implicit operand for many instructions, or implicit place for storing the result of such instructions. . Program memory is a bounded ordered sequence of registers; each of them is identified by its index within the tape, called address. Data memory is also ordered sequence of registers, but like the I/O tapes - bounded just from one side. . Since RAM machine is somewhat abstract, it frees the user from thinking about some issues, and just assumes that: . The size of the problem is always small enough to fit in the RAM memory, . | Data used within the computation are always small enough to fit in one register. . | . The RAM virtual machine in emuStudio consists of the following plug-ins: . ramc-ram: Compiler of the RAM language, very simple &quot;assembler&quot;-like language . | ram-cpu: RAM simulator engine . | ram-mem: Program memory . | abstractTape-ram: Device which represents the &quot;tape&quot; used in RAM, other than program memory. The abstract schema must define three instances of this device, representing register, input and output tapes. . | . Abstract schema . In order to use RAM, there must exist the abstract schema of the &quot;computer&quot;, saved in the configuration file. Abstract schemas are drawn in the schema editor in emuStudio (please see emuStudio main module documentation for more details). The following image shows the schema of RAM machine simulator: . The &quot;&#8594;&quot; arrows are in direction of dependency. So for example ramc-ram depends on ram-mem, because compiled programs are directly loaded into memory. . The roles of the abstract tapes are assigned by the RAM &quot;CPU&quot; on runtime. . Automatic emulation . RAM is one of computers which supports automatic emulation. In general, automatic emulation can be interactive, or not interactive. In case of the RAM emulator, only non-interactive emulation is useful. It is because during emulation it is not possible to interact (e.g. pass new input to the input tape) in any way. . Changes to any abstract tapes are written to the corresponding output file. For more specific information, please see [ABSTRACT_TAPE_AUTOMATIC_EMULATION] section of the abstract tape chapter. . Command line for starting non-interactive automatic emulation: . java -jar emuStudio.jar --config RAM --input examples/ramc-ram/factorial.ram --auto --nogui . configuration config/RAM.conf will be loaded . | input file for compiler is one of the examples . | (--auto) automatic emulation mode will be performed . | (--nogui) non-interactive version will be set . | . After the run, the following output on the stdout can be expected: . [INFO] Loading virtual computer: RAM [INFO] All plugins were loaded successfully. [INFO] Being verbose. Writing to file:registers_(storage_tape).out [INFO] Being verbose. Writing to file:input_tape.out [INFO] Being verbose. Writing to file:output_tape.out [INFO] Starting emulation automatization... [INFO] Compiler: RAM Compiler [INFO] CPU: Random Access Machine (RAM) [INFO] Memory: RAM Program Tape [INFO] Memory size: 0 [INFO] Device #00: Abstract tape [INFO] Device #01: Abstract tape [INFO] Device #02: Abstract tape [INFO] Compiling input file: examples/ramc-ram/factorial.ram [INFO] Compiler started working. [INFO] [Info (000)] RAM Compiler, version 0.39-SNAPSHOT [INFO] [Info (000)] Compile was successful. [INFO] [Info (000)] Compiled file was loaded into operating memory. [INFO] [Info (000)] Compilation was saved to the file: /home/vbmacher/tmp/net.emustudio/examples/ramc-ram/factorial.ro [INFO] Compiler finished successfully. [INFO] Program start address: 0000h [INFO] Resetting CPU... [INFO] Running emulation... [INFO] Normal stop [INFO] Instruction position = 0011h [INFO] Emulation completed . Then, in the current working directory, there will be created three new files: . input_tape.out . | registers_(storage_tape).out . | output_tape.out . | . The format of the files is described in already mentioned [ABSTRACT_TAPE_AUTOMATIC_EMULATION] section of the abstract tape chapter. .",
    "url": "/documentation/user/0.40/docs/ram/ram-intro.html",
    "relUrl": "/docs/ram/ram-intro.html"
  }
  ,"23": {
    "title": "",
    "content": "Program Memory . RAM memory is used as a part of RAM simulator, which acts as the &quot;program memory&quot;, holding just the program. . RAM CPU reads instructions from this memory. The instructions can be written here only by compiling the source code, or loading already compiled binary image. . The memory plug-in contains simple graphical window, a GUI, which provides a set of the following features: . It computes time and space complexity of the program . | It shows the memory content (the &quot;program&quot;) as the list of disassembled instructions . | . Installation and run . The RAM memory can be run only as a part of emuStudio. It is installed in location mem/ram-mem.jar. . Graphical user interface (GUI) . The memory GUI can be seen in the following picture. . A: Opens already compiled program into memory. Previous program will be dismissed. . | B: Clears memory. . | C: Shows uniform time complexity for the actual program. . | D: Shows uniform space complexity for the actual program. . | . Uniform time complexity means maximum number of instructions based on the input N. Uniform space complexity means maximum number of used registers. .",
    "url": "/documentation/user/0.40/docs/ram/ram-mem.html",
    "relUrl": "/docs/ram/ram-mem.html"
  }
  ,"24": {
    "title": "",
    "content": "Compiler for RAM machine . RAM has a very simple assembler-like language, consisting of direct and indirect reading/writing from/to registers or input/output tape. In addition, there are three control-flow instructions. . Installation and run . The compiler is provided as part of emuStudio. It is not deployed as individual package. The compiler can be found in compilers/ directory with name ramc-ram.jar. . Language description . The program written for this compiler consists of two sections: . INPUT section INSTRUCTIONS section . Input section . The INPUT section contains definitions the content of input tape - one or more lines in the form: . &lt;input&gt; ITEMS . where ITEMS is a space-separated list of inputs. Each input is one word - it might be any number or string. By default, every cell in the input tape is a string, and it is not interpreted as some data type. It is only in time when it is used - the instruction which works with the cell defines of which &quot;type&quot; it should be. . For example, input section might be: . &lt;input&gt; 1 2 3 hello world! . In this case, there are five inputs: numbers 1,2,3, then word &quot;hello&quot; and the last one is &quot;world!&quot;. . Instructions section . There exist many possible formats or variations of RAM instructions, unfortunately the syntax is not very unified. I guess the reason is that RAM is not a real machine, and for the purposes of the algorithm analysis the machine is so simple that it&#8217;s description is repeated in almost every paper where it appears. . For this reason, instructions format or the whole vocabulary might be different of what you expected or used for. We have to live with it; but the differences are really small. . Instructions should follow the Input section, but the sections can be mixed. It is just good practice to have input separated from the code. Each instruction must be on separate line, in the form: . [LABEL:] INSTRUCTION [; optional comment] . Each instruction position can be optionally labelled with some identifier (LABEL field), followed by a colon (:) character. The labels can be then referred in other instructions. . Comments begin with a semicolon (;) character and continue to the end of the line. There are no multi-line comments. . Instructions consists of the operation code and optional operand, separated with space (` `). . Operation code is expressed as an abbreviation of corresponding operation (e.g. SUB for SUBtraction). Operand can be one of three types: constant (=i), direct operand (i), where i specifies the register index on tape and indirect operand (*i), where the address of operand specified is stored in register Ri. . The following table describes all possible instructions, usable in the RAM simulator: . =i i *i . HALT . | | halts the simulation . | | . READ . | | Ri &#8592; next input . | | . WRITE . | output &#8592; i . | output &#8592; Ri . | output &#8592; M&lt;Ri&gt; . | . LOAD . | R0 &#8592; i . | R0 &#8592; Ri . | R0 &#8592; M&lt;Ri&gt; . | . STORE . | | Ri &#8592; R0 . | M&lt;Ri&gt; &#8592; R0 . | . ADD . | R0 &#8592; R0 + i . | R0 &#8592; R0 + Ri . | R0 &#8592; R0 + M&lt;Ri&gt; . | . SUB . | R0 &#8592; R0 - i . | R0 &#8592; R0 - Ri . | R0 &#8592; R0 - M&lt;Ri&gt; . | . MUL . | R0 &#8592; R0 * i . | R0 &#8592; R0 * Ri . | R0 &#8592; R0 * M&lt;Ri&gt; . | . DIV . | R0 &#8592; R0 / i . | R0 &#8592; R0 / Ri . | R0 &#8592; R0 / M&lt;Ri&gt; . | . JMP . | | IP &#8592; i . | | . JZ . | | if R0 == 0 then IP &#8592; i . | | . JGTZ . | | if R0 &gt; 0 then IP &#8592; i . | | . The table describes also the behavior of each instruction. Compiler does not care about the behavior, but about the instructions syntax, which is also incorporated in the table. . For example, this is a valid program: . ; COPY(X,Y) ; ; input: X -&gt; r1 ; Y -&gt; r2 ; ; output: X -&gt; Y ; Y -&gt; Y &lt;input&gt; 3 4 world hello &lt;input&gt; sss ; load X,Y read 1 read 2 ; load r.X, r.Y read *1 read *2 ; copy load *2 store *1 halt .",
    "url": "/documentation/user/0.40/docs/ram/ramc-ram.html",
    "relUrl": "/docs/ram/ramc-ram.html"
  }
  ,"25": {
    "title": "",
    "content": "CPU rasp-cpu . RASP CPU is the core of the RASP virtual computer. Its purpose is to execute RASP program composed of RASP instructions which is stored in the RASP memory. The CPU is therefore connected with the memory. . To run &#39;interactive&#39; RASP programs (programs reading user input and writing something to the output), input and output tapes are needed. They are included there in default RASP configuration. . Installation and run . RASP CPU plugin is already included in emuStudio distribution, in location cpu/rasp-cpu.jar. . Supported instructions . RASP CPU emulator supports the following instructions: . Table 1. RASP instructions Operation code Instruction mnemonic code Semantics . 18 . | HALT . | finish program execution . | . 1 . | READ i . | read from input tape into register Ri . | . 2 . | WRITE =i . | write constant i onto the output tape . | . 3 . | WRITE i . | write the content of the register Ri onto the output tape . | . 4 . | LOAD =i . | load the accumulator (register R0) with the i constant . | . 5 . | LOAD i . | load the accumulator (register R0) with the content of Ri register . | . 6 . | STORE i . | store the accumulator (register R0) content into register Ri . | . 7 . | ADD =i . | increase accumulator (register R0) value by constant i . | . 8 . | ADD i . | increase accumulator (register R0) value by the value of register Ri . | . 9 . | SUB =i . | decrease accumulator (register R0) value by constant i . | . 10 . | SUB i . | decrease accumlator (register R0) by the value of register Ri . | . 11 . | MUL =i . | multiply accumulator (register R0) by constant i . | . 12 . | MUL i . | multiply accumulator (register R0) by the value of register Ri . | . 13 . | DIV =i . | divide accumulator (register R0) by constant i . | . 14 . | DIV i . | divide accumulator (register R0) by the value of register Ri . | . 15 . | JMP l . | set instruction pointer (IP) to the address pointed to by the label l . | . 16 . | JZ l . | set instruction pointer (IP) to the address pointed to by the label l if value of the accumulator (register R0) is zero (R0 = 0) . | . 17 . | JGTZ l . | set instruction pointer (IP) to the address pointed to by the label l if value of the accumulator (register R0) is greater than zero (R0 &gt; 0) . | . CPU Status panel . There is a simple GUI window provided for the RASP CPU. It displays the two most important values: . current value of the accumulator (R0 register) . | current value of the instruction pointer (IP) which points to current position within the executed program . | . Also, information about the current RUNNING STATUS is displayed. . Following figure shows a screenshot: .",
    "url": "/documentation/user/0.40/docs/rasp/rasp-cpu.html",
    "relUrl": "/docs/rasp/rasp-cpu.html"
  }
  ,"26": {
    "title": "",
    "content": "Brief description . Random Access Stored Program machine (RASP) is an abstract von-Neumann computer. It means it does not represent a physical device, but ranther it is intended to work as a model to study von-Neumann architecture, without the need to care about specific manufacturer&#8217;s hardware details. . Firstly, it is usefull to present Random Access Stored Program (RASP) machine&#8217;s architecture&#8201;&#8212;&#8201;it is schematically depicted in the following figure. . As we can see, the control unit, i.e. processor, reads data from the input tape and writes results of executed operations onto the output tape. The tapes serve as a form of I/O devices. The two heads&#8201;&#8212;&#8201;reading &#174; and writing (W), are pointers to current reading/writing position. . As already stated, RASP machine represents a von Neumann computer. This implies that the operating memory exists as a single unit in which both program and data can reside. The segment containing the program is organised in the way that two adjacent cells contain instruction/operand alternately. The memory can be read as well as written to by the control unit. . Installation and run . There is no need to download/install RASP separately as it is included in the emuStudio distribution. Here is the structure of the directories containing the files neccessary for our RASP virtual computer: . Directory structure . config/RASP.conf: configuration file of RASP architecture. . | compilers/raspc-rasp.jar: RASP compiler plug-in. . | cpu/rasp-cpu.jar: RASP CPU emulator - CPU plug-in. . | mem/rasp-mem.jar: RASP main memory plug-in. . | . RASP virtual computer in emuStudio uses with tapes as I/O devices. For this purpose, abstractTape-ram.jar plug-in is used (&#169; P. Jakubčo). . Abstract schema . Each virtual computer in emuStudio is defined by so called &#39;abstract schema&#39; (please see emuStudio User documentation). It defines all the parts of its architecture (what it consists of) and inner communication (how architecture components are interconnected). Following figure presents RASP abstact schema: .",
    "url": "/documentation/user/0.40/docs/rasp/rasp-intro.html",
    "relUrl": "/docs/rasp/rasp-intro.html"
  }
  ,"27": {
    "title": "",
    "content": "Memory rasp-mem . RASP memory plug-in serves as the main store (operating memory) for the RASP virtual computer. As already mentioned in the introduction of this manual, RASP is an example of von-Neumann architecture, which implies that both program and data reside in the same memory module. . After compilation of a RASP source code file the compiled program is loaded into here. During the process of the emulation, the CPU plug-in reads instructions an their operands and writes results of the operations from/to the memory. . Installation and run . RASP memory plugin is already included in emuStudio distribution, in location mem/rasp-mem.jar. . Graphical user interface (GUI) . During the emulation, user can view current content of the operating memory in a simple GUI window: . It is also possible to load a compiled memory image from a file by clicking on the OPEN icon: . After that, you can choose the binary file you want to load. . By clicking on the CLEAN icon, you can clean the entire memory content: . The table with memory cells content is editable. By double-clicking on a row you can simply edit the value. You confirm your changes by the ENTER key. . | If you edit a cell that contains an instruction, you edit its operation code, e.g. if a cell contains the ADD = instruction (operation code 7) and you change the cell to 9, the operation code will be overwritten. As a result, the instruction changes to SUB =. It means that you cannot write number 9 as a data item here, only as an operation code. | .",
    "url": "/documentation/user/0.40/docs/rasp/rasp-mem.html",
    "relUrl": "/docs/rasp/rasp-mem.html"
  }
  ,"28": {
    "title": "",
    "content": "Compiler raspc-rasp . RASP compiler is included in the architecture of RASP virtual computer in emuStudio. Its purpose is to translate source code of a RASP program into the form executable by the RASP CPU emulator. . It includes lexical analyzer which is responsibe for recognising lexical units within the source code. It also enables syntax highlighting. Then, the code goes through syntax analysis which checks for syntax errors and builds up the syntactic tree. The tree is then passed through and binary code executable by the emulator is generated. . As with the other emuStudio compilers, you start the compilation by the &quot;Compile source&quot; icon in the main menu. The result of the compilation is saved into a binary file with the .bin extension and also loaded into the RASP operating memory. . Installation and run . RASP compiler plugin is already included in emuStudio distribution, in location compilers/raspc-rasp.jar. . Language syntax . Program start definition . As RASP is a von-Neumann computer, both the program and the data reside in the same memory module. Therefore, we need to clearly specify, where the program start address is as CPU must know where to start emulation. We do so by the org directive followed by a positive ineteger. Program start definition must be the first line of the source code. Please, do not place any empty lines before it. Here, an example follows: . org 5 . | If you do not specify the program start address, or if you set it to 0 (org 0), the default pre-set value will be used, which is 20. The compiler will warn you about this, so do not worry. Setting program start to 0 is not allowed as register R0 is used as the accumulator and therefore any instruction written here would be overwritten sooner or later. | . Supported instructions . All RASP emulator supported instructions together with their semantics are available in the RASP CPU documentation. There are three types of operands of those instructions: . register - e.g. READ 1 . | constant - e.g. WRITE =2 - you specify that operand of an instruction should be interpreted as a constant by the = character. . | label, which is operand of jump instructions (JMP, JZ, JGTZ), e.g. JMP label . | . Line of code structure . Each RASP instruction with its operand MUST be on a separate line, otherwise the code will not compile. . A single line of code consists of instruction followed by its operand. The line can be optionally started with a label. It is possible to put the label and the instruction on two separate lines, however, please, do not place any empy lines between the label and the instruction. . Example (WRITE 2 can be on a separate line): . labelName: WRITE 2 . Comments . RASP compiler supports one-line comments. You start them with a semicolon (;): . ;this is a comment . You can append a comment to an existing line, e.g. . write 2 ;comment . or put it on a completely new line. .",
    "url": "/documentation/user/0.40/docs/rasp/raspc-rasp.html",
    "relUrl": "/docs/rasp/raspc-rasp.html"
  }
  ,"29": {
    "title": "Device simhPseudo-z80",
    "content": "Virtual device &quot;simhPseudo-z80&quot; . Virtual device partially reimplemented from simh emulator. This device is used mainly for communication between CP/M 3 operating system for simh and emuStudio. Most of the original functionality is not implemented, but it is crucial for support of memory bank-switching. . Programming . Z80 or 8080 programs communicate with the SIMH pseudo device via port 0xfe. Programmers must apply the following principles: . For commands that do not require parameters and do not return results: . ld a,&lt;cmd&gt; out (0feh),a . Special case is the reset command which needs to be send 128 times to make sure that the internal state is properly reset. . | For commands that require parameters and do not return results: . ld a,&lt;cmd&gt; out (0feh),a ld a,&lt;p1&gt; out (0feh),a ld a,&lt;p2&gt; out (0feh),a ... . Note: The calling program must send all parameter bytes. Otherwise the pseudo device is left in an undefined state. . | For commands that do not require parameters and return results: . ld a,&lt;cmd&gt; out (0feh),a in a,(0feh) ; &lt;A&gt; contains first byte of result in a,(0feh) ; &lt;A&gt; contains second byte of result ... . Note: The calling program must request all bytes of the result. Otherwise the pseudo device is left in an undefined state. . | Commands requiring parameters and returning results do not exist currently. . |",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/simhPseudo-z80.html",
    "relUrl": "/docs/mits_altair_8800/simhPseudo-z80.html"
  }
  ,"30": {
    "title": "Original software",
    "content": "Original software for Altair8800 . Since Altair8800 virtual computer emulates a real machine, it&#8217;s possible to use real software written for the computer. As was mentioned in [ALTAIR_FOR_EMUSTUDIO] section, several operating systems and programs can be run on Altair. There are many disk and memory images of those systems available online, but only some were tested and proved to work. Some of the available online sites are: . Peter Schorn . | Altair clone . | SIMH . | . In order to net.emustudio.architecture.build custom disk images, please follow this link: . http://www.autometer.de/unix4fun/z80pack/ . | . Most of the disk images were borrowed from great simh emulator. It&#8217;s obvious that some images were modified for simh. On the other hand, it&#8217;s not that obvious if the original images would actually work at all. . Tested and fully-functional images were: . Operating system CP/M v2.2 and 3 . | Altair DOS v1.0 . | BASIC programming language in various versions . | . Disk / memory images for software for Altair8800 are available on many online sites, such as: . http://schorn.ch/altair.html . | http://www.classiccmp.org/cpmarchives/cpm/mirrors/www.schorn.ch/cpm/intro.php . | . Some manuals can be found at e.g. http://altairclone.com/altair_manuals.htm. . The following subsections describe in short how to boot some of those systems, along with screen-shots how it looks. . Boot ROM . Booting operating systems on Altair requires special ROM image to be loaded in operating memory [1]. . Originally, more boot ROMs existed. Different boot ROMs were used to load the code from different devices. In current implementation of emuStudio, there is only one boot ROM supported - so called &#39;disk boot loader&#39; (or DBL), which loads operating system from MITS 88-DISK (through CPU ports). . The boot loader is already available in a file boot.bin. You can find it at the download page. . The boot ROM must be loaded into memory at address 0xFF00 (hexadecimal). It is safe to jump to this address manually when operating system image file is mounted. . | All subsequent sections assume that the boot loader has been loaded in the operating memory. | . CP/M 2.2 . During Altair8800 computer era, many operating systems, applications and programming languages have been developed. On of the most known operating systems is CP/M. It was written by Gary Kildall from Digital Research, Inc. At first it was mono-tasking and single-user operating system which didn&#8217;t need more than 64kB of memory. Subsequent versions added multi-user variants and they were ported to 16-bit processors. . The combination of CP/M and computers with S-100 bus [2] was big &quot;industry standard&quot;, widely spread in 70&#8217;s up to 80&#8217;s years of twentieth century. The operating system took the burden of programming abilities from user, and this was one of the reasons why the demand for hardware and software was rapidly increased. . Tested image has name altcpm.dsk. It can be downloaded at this link. . In order to run CP/M, please follow these steps: . [DISK-88_MOUNTING_IMAGES] altcpm.dsk to drive A: in MITS 88-DISK. . | In emuStudio jump to location 0xFF00 [3] . | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. . | Before starting emulation, show ADM-3A terminal [peripheral] . | Run the emulation [3] . | After these steps were completed, CP/M should start (an informational message appears) and command line prompt will be displayed: . | Command dir is working, ls is better dir. More information about CP/M commands can be found at this link. | . CP/M 3 . Steps for running CP/M 3 operating systems are not that different from CP/M 2. The disk image file is called cpm3.dsk and can be downloaded at this link. CP/M 3 came with two versions: banked and non-banked. The image is the banked version of CP/M. Also, simh authors provided custom BIOS and custom boot loader. . | Manual of CP/M 3 can be found at this link. For more information about simh Altair8800 and CP/M 3, click here. | . There are some requirements for the computer architecture, a bit different for CP/M 2.2. . CPU . It is recommended to use Z80 version of the computer as was presented in the section [ALTAIR_FOR_EMUSTUDIO]. CPU Intel 8080 will work for the operating system itself, but most provided applications require Z80. . Operating memory . Also, the operating memory needs to be set for memory banks [4]. The following parameters were borrowed from simh and were tested: . 8 memory banks . | common address C000h . | . Boot ROM . There exist specific version of boot loader (modified probably by simh authors) to load CP/M into banked memory. It has name mboot.bin and you can find it at the download page. Before other steps, please load this image into operating memory at address 0xFF00 (hexadecimal). . Steps for booting CP/M 3 . Specific steps how to boot CP/M 3 in emuStudio follow: . [DISK-88_MOUNTING_IMAGES] cpm3.dsk to drive A: in MITS 88-DISK. . | In emuStudio jump to location 0xFF00 [3] . | Optionally, you can set CPU frequency to 2500 kHz, which was Zilog Z80 original frequency. . | Before starting emulation, show ADM-3A terminal [peripheral] . | Run the emulation [3] . | The following image shows the look right after the boot: . Altair DOS v1.0 . Steps for booting Altair DOS v1.0 follow: . [DISK-88_MOUNTING_IMAGES] altdos.dsk to drive A: in MITS 88-DISK. . | In emuStudio jump to location 0xFF00 [3] . | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. . | Before starting emulation, show ADM-3A terminal [peripheral] . | Run the emulation [3] . | The system will start asking some questions. According to the manual, the answers for emuStudio are: . MEMORY SIZE? &#8594; 64 or ENTER (if memory ROM is at 0xFFFF) . | INTERRUPTS &#8594; N or just ENTER . | HIGHEST DISK NUMBER? &#8594; 0 (if only 1 disk is mounted) . | HOW MANY DISK FILES? &#8594; 3 . | HOW MANY RANDOM FILES? &#8594; 2 . | . The basic commands you can use are e.g. MNT 0 - to mount the drive, and then DIR 0 to list the files. . If you want AltairDOS being able to automatically detect how much memory is installed on system, it is possible. The system does it by very nasty trick - testing if it can write to particular address (ofcourse, maximum is 16-bits - i.e. 64K of memory). If the result is the same as it was before reading, it means that it reached the &quot;end of memory&quot;. But when it fails to detect the ROM, it fails to determine the size, too, and the output will be INSUFFICIENT MEMORY. . The following image shows how it looks like: . BASIC . In this section will be presented how to boot MITS BASIC version 4.1. There is possible to boot also other versions, but the principle is always the same. . As it is written in simh manual: MITS BASIC 4.1 was the commonly used software for serious users of the Altair computer. It is a powerful (but slow) BASIC with some extended commands to allow it to access and manage the disk. There was no operating system it ran under. . | After boot, you must mount the disk with MOUNT 0. Then, command FILES will show all files on the disk. In order to run a file, run command RUN &quot;file&quot;. Manual can be found at this link. | . It is assumed you have either boot.bin or mboot.bin mounted in the operating memory (see Boot ROM for more details). . Steps for booting BASIC follow: . [DISK-88_MOUNTING_IMAGES] mbasic.dsk to drive A: in MITS 88-DISK. . | In emuStudio jump to location 0xFF00 [3] . | Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency. . | Before starting emulation, show ADM-3A terminal [peripheral] . | Run the emulation [3] . | The following image shows the look right after the boot: . . 1. The purpose of a boot ROM is to load specific block of data from a device and then run it as if it was code. The code block is often called &#39;boot loader&#39;. It is very small program which just loads either the whole or part of the operating system into memory and then jumps to it. 2. 8-bit computers sharing some similarities with Altair 8800 3. See &quot;Debugger toolbar&quot; in the user documentation of Main module 4. Please see section Bank switching",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/software.html",
    "relUrl": "/docs/mits_altair_8800/software.html"
  }
  ,"31": {
    "title": "Memory standard-mem",
    "content": "Operating memory &quot;standard-mem&quot; . This plug-in emulates an operating memory, in a quite broad meaning. It can be used for any virtual computer which can benefit from the following basic properties: . A memory cell has size of 1 byte (8 bits) . | Memory cells are linearly ordered (sequential) . | Each memory cell is accessible by unique address, representing the index of the memory cell, if the memory is imagined as an array of cells . | . Besides, the memory supports these additional features: . Setting up ROM (read only memory) ranges . | Changing memory size; by default it is 64kB . | Support of bank switching . | . There are also some &quot;interactive&quot; features: . Manual loading/saving memory images in either binary or Intel HEX format . | Ability to automatically load a memory image at startup . | Intuitive control using keystrokes, and nice visual presentation of the data . | . This operating memory is (for now) used only in 8-bit emulator of MITS Altair8800. However it is possible to develop an emulator which can benefit from it. . GUI overview . To open the memory GUI (graphical user interface), click at the right-most icon in the debug toolbar, on the Emulator panel. The window is shown, as in the following image: . A: Open a memory image. Current memory content, if it does not interfere with the loaded data will be kept. . | B: Dump (save) whole memory content into a file. . | C: Go to address. The address can be either in decimal, hexadecimal (prefix 0x) or octal (prefix 0) format. . | D: Find a sequence. A dialog shows up where user can find either a plain text or sequence of bytes in the memory. . | E: Erases all memory content. . | F: Shows memory settings . | G: By double-clicking on the memory cell it is possible to edit it and change its value. The value format is the same as the input to &quot;go to address&quot; dialog (see C). . | H: Page of the memory view. The whole memory cannot be shown in single window, because it can be quite large (64 kB by default), so it was divided into pages. . | I: If the memory has set up memory banks, it is possible to change the view to different bank. Switching in here has no effect on the emulator and on the active bank. . | J: Displays the data of the selected cell in various forms. . | . Generally, it is possible to move around the cells using keystrokes (arrows). If user presses some other letter/number key, a small text field appears allowing to edit the current value. When editing is finished, user can press ENTER key to confirm it, or ESC key to discard the editing. . Memory settings . Settings window can be opened by clicking on &quot;settings&quot; icon in the main GUI window: . A: Settings for memory bank-switching . | B: Settings for ROM areas . | C: If checked, settings for ROM areas will be saved to the configuration file . | D: List of memory images which will be loaded at startup . | E: The button will apply the settings . | . ROM areas and memory bank-switching is explained in the following sections. . ROM areas . Some &quot;controllers&quot; - used as embedded devices - usually logically organize memory into areas, some of which are read only, which usually contains the firmware, and some are rewritable. Physically, these memories are wired to specific addresses, so the programmer can access them. . Standard operating memory plug-in emulates this behavior. It allows to define ROM areas which represent read only memory. There can be set up multiple ROM areas, and they can overlap. Effectively it means that memory cells in ROM area cannot be changed from software running on the emulator. All writes to the memory will be ignored. . Manually, as a user it is possible to change the values, but only by loading new memory image. Editing the value will not work. . If a ROM range is defined, it is possible to remove only a part of it, effectively splitting the range and correcting their boundaries. For example, if there is defined a ROM range from 0x0A - 0x64 (see the image above), then it is possible to remove a range e.g. 0x32 - 0x46, which is the part of defined ROM area. Then, the original ROM area is split into two parts - first will be a range from 0x0A - 0x31, and the second from 0x47 - 0x64. . Memory bank-switching . This technique was invented as a workaround for a problem when the address space of a processor was smaller than memory size. In order to overcome this issue, memory was logically split into many regions of size equal to the processor address space. These regions are called &quot;banks&quot;. . Physically, banks could refer to the same memory, but they could be also different memories (e.g. external cartridges), and the bank-switching involved switching the active memory. . Selecting a bank from a programming perspective was usually done by writing some code to some I/O port using some I/O instruction of a CPU. But it can be implemented in various ways, e.g. some memory addresses can be used for selecting a bank. . Also, it was very common that some part of the address space still kept some common memory part which was never switched out. This part is called a &quot;common&quot; part. In emuStudio, common part starts with the Common address (as it can be seen in the Settings dialog image above) and ends till the rest of the CPU address space (or memory end). . To summarize, let&#8217;s consider an example. If a CPU is 8-bit, it means it has address space of size 2^8 - i.e. it can access memory from address 0 to (2^8 - 1). If the memory was larger, CPU just doesn&#8217;t allow to access higher memory cells. So memory bank-switching is coming for the rescue. If the memory has 2 MB, we require 2^log2(2MB) = 2^21 addresses. So, if we won&#8217;t have any common address space, we require ceil(21 / 8) = 3 banks: . bank 0: maps from 0 - (2^8 - 1) . | bank 1: maps from 2^8 - (2^16 - 1) . | bank 2: maps from 2^16 - (2^21 - 1) . | . Configuration file . Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please read the section &quot;Accessing settings of plug-ins&quot; in the user documentation of Main module to see how the settings can be accessed. . The following table shows all the possible settings of Standard operating memory plug-in: . Table 1. Settings of Standard operating memory Name Default value Valid values Description . imageAddress(i) . | N/A . | &gt;= 0 and &lt; mem size . | The i-th memory image load address . | . banksCount . | 0 . | &gt;= 0 . | Number of memory banks . | . commonBoundary . | 0 . | &gt;= 0 and &lt; mem size . | Address from which the banks are shared . | . memorySize . | 65536 . | &gt; 0 . | Memory size in bytes . | . ROMfrom(i) . | N/A . | &gt;= 0 and &lt; mem size . | Start of the i-th ROM area . | . ROMto(i) . | N/A . | &gt;= ROMfrom(i) and &lt; mem size . | End of the i-th ROM area . | . imageName(i) . | N/A . | file path . | The i-th memory image file name. [1] . | . Using memory in custom computers . | This section is for developers of emulators. If you do not plan to create custom virtual computers, you can safely skip this section. In order to get started with developing plug-ins for emuStudio, please read tutorial &quot;Developing emuStudio Plugins&quot;. | . As it was mentioned in the earlier sections, the Standard operating memory plug-in can be used in other computers, too. Besides standard operations which are provided by emulib.plugins.memory.MemoryContext interface, it provides custom context API, enabling to use more features - e.g. bank-switching. . You can obtain the context during the initialize() method of plug-in main class. The context is named net.sf.net.emustudio.memory.standard.StandardMemoryContext: . ... public void initialize(SettingsManager settings) { ... StandardMemoryContext mem = contextPoolImpl.getMemoryContext(pluginID, StandardMemoryContext.class); ... } . The memory context has the following content: . Unresolved directive in standard-mem.adoc - include::{sourcedir}/plugins/mem/standard-mem/src/main/java/net/sf/net.emustudio/memory/standard/StandardMemoryContext.java[lines=20..-1] . . 1. If it ends with .hex suffix, it will be loaded as Intel HEX format, otherwise as binary",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/standard-mem.html",
    "relUrl": "/docs/mits_altair_8800/standard-mem.html"
  }
  ,"32": {
    "title": "CPU z80-cpu",
    "content": "Zilog Z80 CPU emulator . It was possible to upgrade your Altair 8800 computer with a &quot;better&quot; 8-bit processor Zilog Z80. The processor was probably the most used 8-bit processor in 80&#8217;s. It was backward compatible with 8080, and brought many enhancements. It was originally targeted for embedded systems, but very soon it become very popular and used for all kinds of computers - including desktop computers, arcade games, etc. Today the CPU is still used in some MP3 players, see e.g. https://en.wikipedia.org/wiki/S1_MP3_player. . Main features of the emulator include: . Interpretation as emulation technique, . | Correct real timing of instructions, . | Ability to set clock frequency manually at run-time, . | Emulation of all instructions including interrupts, . | Disassembler implementation, . | Ability to &quot;dump&quot; instruction history to console at run-time, . | Support of breakpoints, . | Ability of communication with up to 256 I/O devices, . | Status window shows all registers, flags, and run-time frequency. . | . Dumping executed instructions . The CPU offers a quite unique feature, which is the ability to dump executed instructions as a sequence to the console. When enabled, then each executed instruction - together with content of flags and registers values after the execution are printed. This feature might be extremely useful in two cases: . Reverse engineering of some unknown software . | It allows to net.emustudio.architecture.build tools for automatic checking of register values during the emulation, when performing automatic emulation. . | In order to enable this feature, please see the section Configuration file. . For example, let&#8217;s take one of the examples which computes a reverse text: . Example program for reversing text in Z80 assembly ; Print reversed text org 1000 dec sp ; stack initialization (0FFFFh) ld hl,text1 call putstr ; print text1 ld de,input ; address for string input call getline ; read from keyboard ld bc,input ld d,0 ; chars counter char_loop: ld a, (bc) inc bc ; bc = bc+1 cp 10 ; end of input? jp z, char_end cp 13 jp z, char_end inc d ; d =d+1 jp char_loop char_end: dec bc ; bc = bc-1 dec bc call newline char2_loop: ld a, (bc) call putchar dec bc dec d jp z, char2_end jp char2_loop char2_end: halt include &quot;include getchar.inc&quot; include &quot;include getline.inc&quot; include &quot;include putstr.inc&quot; include &quot;include putchar.inc&quot; include &quot;include newline.inc&quot; text1: db &quot;Reversed text ...&quot;,10,13,&quot;Enter text: &quot;,0 text2: db 10,13,&quot;Reversed: &quot;,0 input: ds 30 . When the program is being run, and the dump instructions feature is turned on, on console you can see the following output: . 0000 | PC=03e8 | dec SP | 3B || regs=00 00 00 00 00 00 00 00 IX=0000 IY=0000 IFF=0 I=00 R=01 | flags= | SP=ffff | PC=03e9 0001 | PC=03e9 | ld HL, 485 | 21 85 04 || regs=00 00 00 00 04 85 00 00 IX=0000 IY=0000 IFF=0 I=00 R=02 | flags= | SP=ffff | PC=03ec 0002 | PC=03ec | call 46D | CD 6D 04 || regs=00 00 00 00 04 85 00 00 IX=0000 IY=0000 IFF=0 I=00 R=03 | flags= | SP=fffd | PC=046d 0002 | PC=046d | ld A, (HL) | 7E || regs=00 00 00 00 04 85 00 52 IX=0000 IY=0000 IFF=0 I=00 R=04 | flags= | SP=fffd | PC=046e 0003 | PC=046e | inc HL | 23 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=05 | flags= | SP=fffd | PC=046f 0003 | PC=046f | cp 0 | FE 00 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=06 | flags= N | SP=fffd | PC=0471 0007 | PC=0471 | ret Z | C8 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=07 | flags= N | SP=fffd | PC=0472 0008 | PC=0472 | out (11),A | D3 11 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=08 | flags= N | SP=fffd | PC=0474 0008 | PC=0474 | jp 46D | C3 6D 04 || regs=00 00 00 00 04 86 00 52 IX=0000 IY=0000 IFF=0 I=00 R=09 | flags= N | SP=fffd | PC=046d 0009 | PC=046d | ld A, (HL) | 7E || regs=00 00 00 00 04 86 00 65 IX=0000 IY=0000 IFF=0 I=00 R=0a | flags= N | SP=fffd | PC=046e 0025 | Block from 0474 to 03EF; count=184 0025 | PC=03ef | ld DE, 4B2 | 11 B2 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=42 | flags= Z N | SP=ffff | PC=03f2 0025 | PC=03f2 | call 428 | CD 28 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=43 | flags= Z N | SP=fffd | PC=0428 0025 | PC=0428 | ld C, 0 | 0E 00 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=44 | flags= Z N | SP=fffd | PC=042a 0026 | PC=042a | in A, 10 | DB 10 || regs=00 00 04 b2 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=45 | flags= Z N | SP=fffd | PC=042c 0026 | PC=042c | and 1 | E6 01 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=46 | flags= ZHP | SP=fffd | PC=042e 0026 | PC=042e | jp Z, 42A | CA 2A 04 || regs=00 00 04 b2 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=47 | flags= ZHP | SP=fffd | PC=042a 0027 | PC=042a | in A, 10 | DB 10 || regs=00 00 04 b2 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=48 | flags= ZHP | SP=fffd | PC=042c 6323 | Block from 042E to 0431; count=1048716 6323 | PC=0431 | in A, 11 | DB 11 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=54 | flags= H | SP=fffd | PC=0433 6323 | PC=0433 | cp D | FE 0D || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=55 | flags= N | SP=fffd | PC=0435 6324 | PC=0435 | jp Z, 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=56 | flags= N | SP=fffd | PC=0438 6324 | PC=0438 | cp A | FE 0A || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=57 | flags= N | SP=fffd | PC=043a 6324 | PC=043a | jp Z, 461 | CA 61 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=58 | flags= N | SP=fffd | PC=043d 6324 | PC=043d | cp 8 | FE 08 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=59 | flags= N | SP=fffd | PC=043f 6324 | PC=043f | jp NZ, 459 | C2 59 04 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5a | flags= N | SP=fffd | PC=0459 6324 | PC=0459 | out (11),A | D3 11 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5b | flags= N | SP=fffd | PC=045b 6324 | PC=045b | ld (DE), A | 12 || regs=00 00 04 b2 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5c | flags= N | SP=fffd | PC=045c 6324 | PC=045c | inc DE | 13 || regs=00 00 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5d | flags= N | SP=fffd | PC=045d 6325 | PC=045d | inc C | 0C || regs=00 01 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5e | flags= | SP=fffd | PC=045e 6325 | PC=045e | jp 42A | C3 2A 04 || regs=00 01 04 b3 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=5f | flags= | SP=fffd | PC=042a 6325 | PC=042a | in A, 10 | DB 10 || regs=00 01 04 b3 04 a5 00 02 IX=0000 IY=0000 IFF=0 I=00 R=60 | flags= | SP=fffd | PC=042c 8683 | Block from 045E to 0461; count=440826 8683 | PC=0461 | ld A, A | 3E 0A || regs=00 04 04 b6 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5a | flags= ZH N | SP=fffd | PC=0463 8683 | PC=0463 | ld (DE), A | 12 || regs=00 04 04 b6 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5b | flags= ZH N | SP=fffd | PC=0464 8683 | PC=0464 | inc DE | 13 || regs=00 04 04 b7 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=5c | flags= ZH N | SP=fffd | PC=0465 8683 | PC=0465 | ld A, D | 3E 0D || regs=00 04 04 b7 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5d | flags= ZH N | SP=fffd | PC=0467 8683 | PC=0467 | ld (DE), A | 12 || regs=00 04 04 b7 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5e | flags= ZH N | SP=fffd | PC=0468 8684 | PC=0468 | inc DE | 13 || regs=00 04 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=5f | flags= ZH N | SP=fffd | PC=0469 8684 | PC=0469 | ld A, 0 | 3E 00 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=60 | flags= ZH N | SP=fffd | PC=046b 8684 | PC=046b | ld (DE), A | 12 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=61 | flags= ZH N | SP=fffd | PC=046c 8684 | PC=046c | ret | C9 || regs=00 04 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=62 | flags= ZH N | SP=ffff | PC=03f5 8684 | PC=03f5 | ld BC, 4B2 | 01 B2 04 || regs=04 b2 04 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=63 | flags= ZH N | SP=ffff | PC=03f8 8684 | PC=03f8 | ld D, 0 | 16 00 || regs=04 b2 00 b8 04 a5 00 00 IX=0000 IY=0000 IFF=0 I=00 R=64 | flags= ZH N | SP=ffff | PC=03fa 8684 | PC=03fa | ld A, (BC) | 0A || regs=04 b2 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=65 | flags= ZH N | SP=ffff | PC=03fb 8684 | PC=03fb | inc BC | 03 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=66 | flags= ZH N | SP=ffff | PC=03fc 8684 | PC=03fc | cp A | FE 0A || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=67 | flags= N | SP=ffff | PC=03fe 8684 | PC=03fe | jp Z, 40A | CA 0A 04 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=68 | flags= N | SP=ffff | PC=0401 8684 | PC=0401 | cp D | FE 0D || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=69 | flags= N | SP=ffff | PC=0403 8685 | PC=0403 | jp Z, 40A | CA 0A 04 || regs=04 b3 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6a | flags= N | SP=ffff | PC=0406 8685 | PC=0406 | inc D | 14 || regs=04 b3 01 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6b | flags= | SP=ffff | PC=0407 8685 | PC=0407 | jp 3FA | C3 FA 03 || regs=04 b3 01 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=6c | flags= | SP=ffff | PC=03fa 8685 | PC=03fa | ld A, (BC) | 0A || regs=04 b3 01 b8 04 a5 00 68 IX=0000 IY=0000 IFF=0 I=00 R=6d | flags= | SP=ffff | PC=03fb 8685 | Block from 0407 to 040A; count=28 8685 | PC=040a | dec BC | 0B || regs=04 b6 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=09 | flags= ZH N | SP=ffff | PC=040b 8685 | PC=040b | dec BC | 0B || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0a | flags= ZH N | SP=ffff | PC=040c 8685 | PC=040c | call 47A | CD 7A 04 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0b | flags= ZH N | SP=fffd | PC=047a 8685 | PC=047a | ld A, A | 3E 0A || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0c | flags= ZH N | SP=fffd | PC=047c 8686 | PC=047c | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0d | flags= ZH N | SP=fffb | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0e | flags= ZH N | SP=fffb | PC=0479 8686 | PC=0479 | ret | C9 || regs=04 b5 04 b8 04 a5 00 0a IX=0000 IY=0000 IFF=0 I=00 R=0f | flags= ZH N | SP=fffd | PC=047f 8686 | PC=047f | ld A, D | 3E 0D || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=10 | flags= ZH N | SP=fffd | PC=0481 8686 | PC=0481 | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=11 | flags= ZH N | SP=fffb | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=12 | flags= ZH N | SP=fffb | PC=0479 8686 | Block from 0481 to 0484; count=2 8686 | PC=0484 | ret | C9 || regs=04 b5 04 b8 04 a5 00 0d IX=0000 IY=0000 IFF=0 I=00 R=14 | flags= ZH N | SP=ffff | PC=040f 8686 | PC=040f | ld A, (BC) | 0A || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=15 | flags= ZH N | SP=ffff | PC=0410 8686 | PC=0410 | call 477 | CD 77 04 || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=16 | flags= ZH N | SP=fffd | PC=0477 8686 | PC=0477 | out (11),A | D3 11 || regs=04 b5 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=17 | flags= ZH N | SP=fffd | PC=0479 8686 | Block from 0410 to 0413; count=2 8686 | PC=0413 | dec BC | 0B || regs=04 b4 04 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=19 | flags= ZH N | SP=ffff | PC=0414 8687 | PC=0414 | dec D | 15 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1a | flags= H N | SP=ffff | PC=0415 8687 | PC=0415 | jp Z, 41B | CA 1B 04 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1b | flags= H N | SP=ffff | PC=0418 8687 | PC=0418 | jp 40F | C3 0F 04 || regs=04 b4 03 b8 04 a5 00 6a IX=0000 IY=0000 IFF=0 I=00 R=1c | flags= H N | SP=ffff | PC=040f 8687 | PC=040f | ld A, (BC) | 0A || regs=04 b4 03 b8 04 a5 00 6f IX=0000 IY=0000 IFF=0 I=00 R=1d | flags= H N | SP=ffff | PC=0410 8687 | Block from 0418 to 041B; count=23 8687 | PC=041b | halt | 76 || regs=04 b1 00 b8 04 a5 00 61 IX=0000 IY=0000 IFF=0 I=00 R=34 | flags= ZH N | SP=ffff | PC=041c . The dump format consists of lines, each line represents one instruction execution. The line is separated by | chars, splitting it into so-called sections. Sections before the sequence || represent state before instruction execution, and sections after it represent the state after instruction execution. Particular sections are described in the following table. . Column Description . 8 . | Program counter after instruction execution . | . 1 . | Timestamp from program start (seconds) . | . 2 . | Program counter before instruction execution . | . 3 . | Disassembled instruction . | . 4 . | Instruction opcodes . | . | Now follows the state after instruction execution . | . 5 . | Register values (B, C, D, E, H, L, reserved (always 0), A) . | . 6 . | Flags . | . 7 . | Stack pointer register (SP) . | . Configuration file . Configuration file of virtual computers contain also settings of all the used plug-ins, including CPUs. Please read the section &quot;Accessing settings of plug-ins&quot; in the user documentation of Main module to see how the settings can be accessed. . The following table shows all the possible settings of Zilog Z80 CPU plug-in: . Table 1. Settings of Zilog Z80 CPU emulator plug-in Name Default value Valid values Description . printCodeUseCache . | false . | true / false . | If printCode is set to true, then a cache will be used which remembers already visited blocks of code so the instruction dump will not be bloated with infinite loops . | . printCode . | false . | true / false . | Whether the emulator should print executed instructions, and its internal state to console (dump) . | .",
    "url": "/documentation/user/0.40/docs/mits_altair_8800/z80-cpu.html",
    "relUrl": "/docs/mits_altair_8800/z80-cpu.html"
  }
  
}