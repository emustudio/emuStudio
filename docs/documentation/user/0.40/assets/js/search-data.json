{
  
  "0": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "/documentation/user/0.40/404.html",
    "relUrl": "/404.html"
  }
  ,"1": {
    "title": "Automation",
    "content": "Automation . Automation, or automatic emulation, is a feature in which user can run the emulation in a non-interactive mode, i.e. without any interruption. The emulation is being run from the command line and user just watches until it finishes. At the end, she/he collects logs and/or output files generated by plugins. Outputs then can be analyzed manually or by some custom script. . The feature has to be supported by individual plugins, so they will respect the settings from command line. Please refer to the documentation of individual plugins for these details. . Automatic emulation requires a source code to be present. The source code is called an “input”. Example of running automatic emulation is as follows: . ./emuStudio --auto --nogui --config config/MITSAltair8800.toml --input example.asm --waitmax 5000 . Command line argument --auto turns on the automatic emulation. If no other argument is provided, emuStudio will start as usual by asking to open a virtual computer. But after this step it will run the emulation with the settings as they appear in the computer configuration file (no source code compilation is performed). . The --nogui argument tells to emuStudio that we don’t want to use GUI (graphical user interface) at all. In that case, we must provide a virtual computer in the command line (using --config argument). . Argument --waitmax 5000 tells emuStudio that the emulation should not last for more than 5 seconds. If it didn’t finish up to this deadline, it is forcibly stopped and marked as failed. . Analyzing the results . An important part of the analysis of result of the automatic emulation is the log saying what happened. By default, each run of automatic emulation creates (overwrites) a log file called automation.log, located in logs/ directory. . The log file is in plaintext format and contains messages which appeared in log during the emulation. The log file format can be customized, see “Logging” chapter for more details. .",
    "url": "/documentation/user/0.40/application/automation",
    "relUrl": "/application/automation"
  }
  ,"2": {
    "title": "emuStudio Application",
    "content": "emuStudio Application . emuStudio is a desktop application which allows emulation of various computers. Besides emulation, it contains source code editor, which can be used to write and then compile programs then to be instantly emulated. Virtual computers, as the emulators are called, are represented by plugins of various type (compiler, memory, CPU and device), combined in a comuter configuration. The computer configuration can be opened during startup. . The application has also command-line interface, which allows executing automatic “load-compile-emulate” workflow, possibly without graphical interface. This workflow is called “automatic emulation” and has its specifics, discussed per virtual computer. . A logger is used by emuStudio which helps debugging of the application and plugins. . Installation and run . At first, please download emuStudio distribution. It is either a TAR or ZIP file in the form emuStudio-[VERSION].zip. For Linux/Mac environments, a TAR variant will be more suitable since it preserves file attributes and execution permissions. Unpack the file where you want to have emuStudio installed. . Before running, Java 11 or later must be installed. Then, emuStudio can be run by executing the following script: . On Linux / Mac &gt; ./emuStudio . | On Windows: &gt; emuStudio.bat . | . NOTE: Currently supported are Linux and Windows. Mac is NOT supported, but it might work to some extent. . Command-line interface . emuStudio accepts several command line arguments. Their description is accessible with --help argument: . $ ./emuStudio --help --auto : run the emulation automation (default: false) --config filename : load configuration with file name --help : output this message (default: true) --input filename : use the source code given by the file name --nogui : try to not show GUI in automation (default: false) --waitmax X : wait for emulation finish max X milliseconds (default: -1) . Most of these arguments are self-explanatory. Some of them have meaning only when emulation automation is turned on (--nogui, --waitmax). .",
    "url": "/documentation/user/0.40/application/",
    "relUrl": "/application/"
  }
  ,"3": {
    "title": "",
    "content": "",
    "url": "/documentation/user/0.40/",
    "relUrl": "/"
  }
  ,"4": {
    "title": "Introduction",
    "content": "Introduction . emuStudio is a toy-computer emulation platform and framework, targeting mainly academic sphere. A platform, because it supports full emulation “life-cycle”. From writing and compiling programs for emulated machine, to running and debugging. A framework, because it provides API and documentation which encourages implementing your custom toy-computer, either real or abstract. . It does not aim to supersede other emulators which try to preserve history (e.g. MAME, or simh), because they do better job, have big community around them and it does not make sense to provide the same goal. Instead, emuStudio focuses on allowing programming the emulated devices - in the style of “write program - load it into computer - emulate”. . History . Project ‘emuStudio’ started in 2006 as a school project, then a master thesis, created by Peter Jakubčo. He had continued to work on it afterwards, giving it less and less spare time he has now. . Supervisor of the school project was Slavomír Šimoňák, who could be understood as the first “product owner”. On a personal note, the original author remembers the times with nostalgy. Lots of good ideas came from discussions between the supervisor and the author. . The main reason why the project started was lack of good but simple emulators which allowed ‘program-load-emulate’ workflow. Back then at Technical University of Košice (Slovakia), during first lessons in assembly language, students were at first introduced to vintage computers. They had to create simple programs for Intel 8080, but they did it by hand on a paper. emuStudio allowed to use computer, and since then it has established as basic tool, extending to multiple programming-like courses at the university. . Now, students are main contributors which extend emuStudio, but from time-to-time some unknown contributors appear as well, from various countries over the world. Original author still keeps maintaining it. .",
    "url": "/documentation/user/0.40/introduction/",
    "relUrl": "/introduction/"
  }
  ,"5": {
    "title": "Logging",
    "content": "Logging . No software is bug-free in these days, and not a person is perfect. Sometimes it might happen that emuStudio is not working as expected, either it does not start (with weird message on screen), or it fails while running. . For that purpose, everything important is being logged. If you encounter some problem and either want to fix it or report it, the logs, except steps to reproduce are the most important thing. By default, logging is written to the standard output (console). In case of a problem it is a good practice to enable file logging. . To enable file logging, open logback.xml file located in the root directory of emuStudio. Find a section named &lt;root ..&gt;, and change appender-ref from STDOUT to FILE as follows: . &lt;root level=&quot;debug&quot;&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt; . The log file is named logs/emuStudio.log. Every new run of emuStudio will append log messages into that file until emuStudio is terminated. . By default, a rolling policy is enabled, which deletes logs older than 2 days and keeps the log in maximum size of 1 MB. It is of course configurable. For more information about how to configure loggers, please look at the logback site. .",
    "url": "/documentation/user/0.40/application/logging",
    "relUrl": "/application/logging"
  }
  ,"6": {
    "title": "Main window",
    "content": "Main window . Main window is the core part of emuStudio application. Users usually spends there most of the time while working with emuStudio. . The content of the window is split into two panels or tabs, placeholders for two actions users can do in emuStudio. The first tab is “Source code editor”, second is “Emulator”, used during computer emulation. . Source code editor . . In the source code editor, users can write programs for emulated computer. However, the most important tool which allows translation of the source code into binary program readable by emulated CPU is a compiler. Therefore, users must use the right compiler. . Input language of a compiler is not limited, it can be either a kind of assembler, or even C or Pascal language. It depends on the compiler implementation, there can be many. The only restriction is that compiler must have output which is compatible with CPU which is currently being emulated. This cannot be checked automatically, users must take care of this. . Source code editor supports only the basic features, such as line numbering and syntax highlighting. Also, there is possibility to search/replace text. . Compilation must be run manually. Compiler output window shows all messages which compiler produces. The content is dependant on the used compiler, but most likely it will contain compilation success or errors messages. . Compiled source code can produce output binary file (for example a HEX file), and it’s automatically loaded into the operating memory. If the emulation is running, user must stop it first manually. . If another program is loaded in memory, it is not removed before loading currently compiled program, but the memory is overwritten at only those locations relevant to the compiled program. All the other content is left unchanged. . Emulator tab . Emulator tab is shown in the following image. It is currently open with MITS Altair8800 computer with Intel 8080 CPU, and several devices: . . The tab contains three main parts. The first one is very useful - listing of operating memory, disassembled into instructions. This part is called a debugger window, or “debugger”. The other part, below the debugger window is a list of all computer devices used (“peripheral devices”). With a double-click user can open GUI window of that particular device, if it supports it. . The last part on the right displays status of the CPU used in this computer. Each CPU has its own implementation of how the status window look and what it displays. . Debugger window . Debugging is a process in which a programmer tries to analyze a program, usually with the intent to find bugs. The adverb “to debug” has a deep history. Very early computers were having of so-called vacuum tubes, which were core elements acting as electrically controlled switches. From time to time a computer stopped working, and the most usual reason was that a bug (real one) came in a vacuum tube. Maintainers of the computer had to go there and manually remove the bug. It happened that often, so that the process of removing bugs got a name - “to de-bug”.] Debugger in emuStudio contains a debugger toolbar and list of few disassembled instructions from memory. In combination with CPU status panel, it’s the most powerful tool for seeing (and checking) all internal behavior of the emulated computer. . Debugger toolbar . Debugger toolbar contains buttons (icons) for controlling the emulation and accessing memory content. Most of these buttons are self-explanatory. If you hover over those icons, a help text is displayed of how to use the icon. . . A: Reset emulation. | B: Set next instruction position to 0. CPU will perform the next instruction from there. | C: Set next instruction position to the (current - 1). This action can completely change displaying of instructions, since the new instruction position does not have to be correct in term of executing the current program. | D: Stop emulation (which is either running or paused). | E: Pause emulation (which is running). | F: Run emulation (which is paused). | G: Run emulation with timer (which is paused). Instructions are executed after elapsing specified time interval. A dialog will appear to enter the time interval. | H: Step emulation (which is paused). CPU will execute only one - the very next - instruction. | I: Jump to location. User will manually specify location (address in memory) for the next instruction to execute. | J: Set/unset breakpoint. User can set or unset a breakpoint on specific memory location. When CPU reaches the breakpoint, it will pause there, waiting for next user action. | K: Show operating memory. If the memory plug-in does not have a GUI, the icon is disabled. | . List of instructions . The largest part of the debugger window a list of few disassembled instructions, so-called instructions window. Around 15 instructions are shown, but it depends on the CPU. They are arranged in a table. The first column is usually interactive, allowing user to set breakpoints. Red strip is pointing to the very next instruction being executed. . The size of disassembled memory (resulting in the number of disassembled instructions) is not configurable. Also, user cannot change instructions in this place. . Sometimes the instructions shown in the debugger do not have to be disassembled correctly. There are two reasons for that: . first, instructions can have various binary sizes (e.g. one byte, two bytes, etc.) | second, memory can contain programs on various locations, and emuStudio doesn’t know where. Well, if it’s just program compiled from the source code editor, it knows. | . The implication is that if emuStudio starts to disassemble instructions at wrong location, the instructions will be disassembled incorrectly, or they can appear as invalid. . However, emuStudio is trying hard to find the nearest program start location at which it’s safe to start disassembling. Usually it’s just few instructions back, so it is a fast process. . Controlling of displaying the instructions . It’s possible to change the current instructions view. The window can be moved in a per-page fashion. The amount of instructions displayed in the window is always preserved. With the toolbar below the list it’s possible to change “pages” of the displayed instructions. . . A: Go to the first page. The very first row corresponds to instruction position 0. | B: Go backwards. User will specify the number of pages for going back. | C: Go to the previous page. | D: Go to the page where current instruction position is. | E: Go to the next page. | F: Go forwards. User will specify the number of pages for going forward. | G: Go to the last page. It can cause incorrectly displaying of instructions. | .",
    "url": "/documentation/user/0.40/application/main-window",
    "relUrl": "/application/main-window"
  }
  ,"7": {
    "title": "Opening a computer",
    "content": "Opening a computer . The first action which emuStudio does is loading a computer to be emulated. Virtual computers are described in abstract schemas, which are stored in configuration files. . Computers can be loaded either from command line, or manually in GUI (by default). The open dialog is the first thing which appears to a user. . . Left part contains a control panel and a list of all available virtual computers. When a user clicks at a computer, it’s abstract schema is displayed on the right. Double-clicking or clicking on the Open button loads selected computer. . Managing virtual computers . . A: Adds new computer. The abstract schema editor will be opened. | B: Deletes selected computer. Be aware of what you are doing - the action cannot be undone. | C: Edits selected computer. The abstract schema editor will be opened. | D: Saves the displayed abstract schema into image file. | .",
    "url": "/documentation/user/0.40/application/opening-computer",
    "relUrl": "/application/opening-computer"
  }
  ,"8": {
    "title": "Computer schema",
    "content": "Computer schema . Computer schema represents real configuration of emulated computer. They are “drawn” in a computer schema editor. Users pick plugins which appear as “boxes” or elements on the screen. Then using connection lines those elements can be connected together to express a relation (that they can “see” each other). . . Description of the control panel follows. . . A: Save the virtual computer. | B: Select a compiler. | C: Select a CPU. | D: Select a memory. | E: Select a device. | F: Use a connection line. The line is bidirectional by default. | G: Set or unset the connection line to be bidirectional. If the line is not bidirectional, the source direction is the first clicked element and the target direction is the second clicked element. | H: Remove an element from the schema. | I: This drop-down list is used for selecting specific plugin (element) in the computer schema. See icons B, C, D, and E. Those names are just file names of plugins. | J: Use / do not use a grid in the editor. Elements are “snapped” to the grid if it is used and it’s easier to draw the schema which looks good. The slider on the right then controls density of the grid. The density is saved in the configuration file of the edited computer. | . Virtual computers in emuStudio are following von-Neumann model of computers. It means that each computer must have a CPU, and memory. Optionally one or more devices, and optionally a compiler. . Connection lines . Connection line represents virtual “connection” between computer components. For the computer schema it’s not important how the connection is realized. It’s safe to say that the connection is similar as if we say that a component “sees” the other component, in the direction of the arrow: . . In the previous image, a CPU “sees” the memory, but not vice-versa. It means, CPU can read/write from/to memory, but memory is not seeing it, it can just answer to CPU requests. This connection makes sense in real-world computers. . Drawing connection lines is very easy. Connection line always connects exactly two elements in the schema. At first, user must click on already existing element in the schema. It’s just a click, not a drag. . Then a grey temporary line is being drawn having its end at the mouse position and moving with the mouse move. If the element is not really close, user can make a “path” by clicking somewhere in the schema. At those locations fixed-points are created. . When a user clicks at the second element, the temporary line disappears, and real connection line is created. . User can find the fixed-points later and move them by dragging. They can be removed by clicking at them with right button of the mouse. .",
    "url": "/documentation/user/0.40/application/computer-schema",
    "relUrl": "/application/computer-schema"
  }
  
}