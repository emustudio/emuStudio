{
  
  "0": {
    "title": "",
    "content": "404 . Page not found :( . The requested page could not be found. .",
    "url": "/documentation/developer/404.html",
    "relUrl": "/404.html"
  }
  ,"1": {
    "title": "Plugin contexts",
    "content": "Plugin contexts . Plugin contexts are answer to the question “how plugins communicate?”. Plugin root classes are seen by emuStudio, but not by plugins. Instead, plugins can register their own custom objects (called “contexts”) in the ContextPool object during plugin instantiation (in the constructor). ContextPool is a shared container of all plugin contexts. Plugins can also obtain contexts of other plugins, during plugin initialization. Then, plugin communicate by calling regular Java methods on the plugin context objects, obtained from context pool. . ContextPool is not thread-safe, so all operations on it should be performed in the same thread which called method Plugin.initialize(). . Each plugin context must implement a Context interface (or it’s derivative). Interfaces which extend Context must be then annotated with PluginContext annotation. There are prepared some standard context interfaces in the API (CompilerContext, MemoryContext, CpuContext and DeviceContext), and those can be used when implementing plugin context class - or they can be further extended to provide customized versions of contexts. . Plugin context objects are registered in ContextPool as key-value pair, where the key is an context interface which the context implements, and value is the context object. A plugin can register none, one or many contexts. Single context object can be registered multiple times, if the keys (context interfaces) are different. . Sample custom context might be created like this: . @PluginContext public interface SampleContext extends CpuContext { // custom methods... } . And the context class might look as follows: . public class SampleContextImpl implements SampleContext { // implementation ... } . Registration of this context might look as follows: . @PluginRoot(type = PLUGIN_TYPE.CPU, title = &quot;Sample CPU emulator&quot;) public class SamplePlugin implements CPU { public SamplePlugin(long pluginID, ApplicationApi emustudio, PluginSettings settings) { ContextPool contextPool = emustudio.getContextPool(); SampleContext context = new SampleContextImpl(); // We will register the same context two times, but by different context interfaces contextPool.register(pluginID, context, CpuContext.class); contextPool.register(pluginID, context, SampleContext.class); } } . If another plugin wants to obtain the context, it should do it in the Plugin.initialize() method: . @PluginRoot(type = PLUGIN_TYPE.DEVICE, title = &quot;Sample device&quot;) public class SampleDevice implements Device { ... @Override public void initialize() throws PluginInitializationException { // If obtaining the context is not vital, catch the exception SampleContext cpuContext = contextPool.getCPUContext(pluginID, SampleContext.class); ... } ... } . If the requested context could not be found, or the plugins were not connected, an exception is thrown. If it is vital for the plugin to obtain the context, it should let it pass to the caller, otherwise it should be catched. .",
    "url": "/documentation/developer/plugin_basics/context",
    "relUrl": "/plugin_basics/context"
  }
  ,"2": {
    "title": "How to contribute",
    "content": "How to contribute . There are basically two options how to contribute. Either you fix or enhance the application or plugins, or you implement completely new computer which can be used with emuStudio. The latter does not really mean to contribute, unless it is included in the original emuStudio repository. . Each contribution “topic” should have a separate issue on GitHub, where can be held discussions. Contributors should fork the repository, and derive their feature branches from development branch. . When you are satisfied with your work, make a pull request to the main repository, into branch development. Then, some reviewer will take a look on the PR, and can suggest some changes, or will merge it. . Commit messages should be in the form of: . [#XXX] Description of commit . where #XXX represents the issue number. Then, the commit will be shown as a comment in the issue and can be properly tracked. . Code style . Code should be “clean”, in terms of sticking to various good practices and principles (e.g. SOLID, GRASP, YAGNI, KISS, DRY, etc.). . Code use 4 spaces. . Definition of DONE . There are some requirements which need to be fulfilled before we can say that the contribution is “done” and can be accepted or released. The list is very simple: . Code should be clean, conforming to the code style | Code must have proper unit tests, if applicable or possible | Documentation should be updated | .",
    "url": "/documentation/developer/getting_started/contributing",
    "relUrl": "/getting_started/contributing"
  }
  ,"3": {
    "title": "Disassembler",
    "content": "Disassembler . Disassembler is not needed for the emulation itself. It is needed for emuStudio to be able to visually show the instructions. You can develop your own disassembler by implementing interface Disassembler from emuLib. Or you can use Edigen, a disassembler generator for emuStudio. . Edigen works similarly as parser generator: developer writes a specification file. Then, Edigen (either from the command line or using Gradle) generates disassembler and decoder of the source code, using predefined templates, bundled in Edigen. . Specification files have .eds file extension. A SSEM CPU specification file looks as follows: . instruction = &quot;JMP&quot;: line(5) ignore8(8) 000 ignore16(16) | &quot;JPR&quot;: line(5) ignore8(8) 100 ignore16(16) | &quot;LDN&quot;: line(5) ignore8(8) 010 ignore16(16) | &quot;STO&quot;: line(5) ignore8(8) 110 ignore16(16) | &quot;SUB&quot;: line(5) ignore8(8) 001 ignore16(16) | &quot;CMP&quot;: 00000 ignore8(8) 011 ignore16(16) | &quot;STP&quot;: 00000 ignore8(8) 111 ignore16(16); line = arg: arg(5); ignore8 = arg: arg(8); ignore16 = arg: arg(16); %% &quot;%s %d&quot; = instruction line(shift_left, shift_left, shift_left, bit_reverse, absolute) ignore8 ignore16; &quot;%s&quot; = instruction ignore8 ignore16; . The specification file might look a bit cryptic at first sight, but it’s quite easy. The content is divided into two sections, separated with two %% chars on a separate line. The first section contains rules which are used for parsing the instruction binary codes and assign labels to the codes. The second section specifies the disassembled string formats for particular rules. . There can exist multiple rules, and rules can include another rules. If the rule includes the same rule recursively, it means it’s a constant. In that case, in the parenthesis after the rule inclusion must be a number of bits which the constant takes. .",
    "url": "/documentation/developer/cpu/disassembler",
    "relUrl": "/cpu/disassembler"
  }
  ,"4": {
    "title": "Documenting",
    "content": "Documenting . There are two types of documentation - user and developer. Each version of emuStudio uses separate Jekyll static site project, for each documentation type. The structure of the documentation is as follows: . _documentation | + developer | | | + 0.39 | | | | | + ... jekyll static site ... | | | + 0.40 | | | | | + ... jekyll static site ... | | | + ... etc. | + user | + 0.39 | | | + ... jekyll static site ... | + 0.40 | | | + ... jekyll static site ... | + ... etc. . Based on which version and documentation type, you can navigate to the right place where to contribute. The documentation is built manually, not by GitHub pages. The reason for having different jekylls is that the documentation uses different template than the main web site, and those cannot be combined easily. . When you update the documentation, please run script: . _documentation/build.sh . which will generate the sites in the correct place, where the main web site will recognize it. Commits should include rendered documentation as well. . User documentation . Plugins are usually part of virtual computers. Therefore, virtual computers are “chapters” in the documentation in a separate directory (e.g. _documentation/user/0.40/altair8800, and plugins are described there, in separate file (e.g. standard-mem.md). The documentation of virtual computer should document all possible configurations, and all possible plugins, even if their use is optional (which should be documented as well). . User documentation should focus on the interaction part with the user of emuStudio, and should not go in details of what’s going under the hood. Keep the information useful. Do not bloat text with obvious. . Structure . Virtual computer documentation should start with short introduction: . How the computer is related to the computer history? | Is it abstract or real? | The purpose of the computer | Possible computer configurations | Comparison of features which are supported vs. features of real computer | . Then, every plug-in should be described, in a separate file, in the following order: . compiler (“programming language” tutorial) | CPU | memory | devices | . Last chapters should be devoted to emulation automation and debugging problems (e.g. how to do some analysis when something doesn’t work). . Developer’s documentation . Developer documentation (as you read this one) focuses on introducing new contributors to emuStudio internals and plugin development. You can contribute by fixing or extending existing one. . Developer documentation of particular plugin is however optional. Specific plugin documentation will not be published online. It is up to the plugin author to choose the documentation format. As for advice, only technical details should be explained, not code structure. Majority of things which the documentation should include are the “why”s instead of “how”s. .",
    "url": "/documentation/developer/getting_started/documenting",
    "relUrl": "/getting_started/documenting"
  }
  ,"5": {
    "title": "Emulator engine",
    "content": "Emulator engine . Emulator engine is the core of the emulator. It interprets binary-encoded instructions stored in a memory (emuStudio assumes it’s a von-Neumann-like CPU). Execution of one instruction involves four basic steps: fetch, decode and execute, and store, executed in order. Those steps can overlap in the implementation. . A pseudo-algorithm for emulator engine can look as follows: . public class EmulatorEngine { private final CPU cpu; private final MemoryContext&lt;Byte&gt; memory; // internal CPU registers private int currentInstruction; EmulatorEngine(MemoryContext&lt;Byte&gt; memory, CPU cpu) { this.memory = Objects.requireNonNull(memory); this.cpu = Objects.requireNonNull(cpu); } CPU.RunState step(CPU.RunState currentRunState) { int instruction = memory.read(currentInstruction); currentInstruction = currentInstruction + 1; switch (instruction) { case 0: // ADD ... return CPU.RunState.STATE_STOPPED_BREAK; case 4: // JMP ... return CPU.RunState.STATE_STOPPED_BREAK; case 99: // HLT return CPU.RunState.STATE_STOPPED_NORMAL; } } CPU.RunState run(CPU.RunState currentRunState) { while (currentRunState == CPU.RunState.STATE_STOPPED_BREAK) { try { if (cpu.isBreakpointSet(currentInstruction)) { return currentRunState; } currentRunState = step(); } catch (...) { currentRunState = CPU.RunState.STATE_STOPPED_XXX; break; } } return currentRunState; } ... } . It uses interpretation emulation technique (the simplest one). Note that breakpoints must be manually handled - after execution of each instruction it should be checked if the current instruction hasn’t a breakpoint, and if yes, return. .",
    "url": "/documentation/developer/cpu/engine",
    "relUrl": "/cpu/engine"
  }
  ,"6": {
    "title": "Git workflow",
    "content": "Git workflow . Since emuStudio is available at GitHub, it using git as the version control system (VCS). . Basic workflow is a much simplified version of the official Git Flow model. The simplifications are as follows: . there is maintained just one version of emuStudio (the not-yet released). Releasing older versions with hotfixes is not supported | there are no “release branches”. Branch development is considered as always-stable branch, from which are performed releases. | . Releases . Release is performed in several steps. . Pre-check everything. Build, documentation, etc. | Merge development branch into master branch | Last commit in the master branch is tagged with tag RELEASE-XXX, where XXX is the released version | Release is edited in GitHub to add release notes, and binary artefacts |",
    "url": "/documentation/developer/getting_started/gitflow",
    "relUrl": "/getting_started/gitflow"
  }
  ,"7": {
    "title": "Writing a compiler",
    "content": "Writing a compiler . A compiler plugin must either implement Compiler interface, or extend more bloat-free AbstractCompiler class. Common practice is to utilize JFLex and Java Cup parser generators, which has direct runtime support in emuStudio. . Sample implementation of a compiler might look as follows (just some methods are implemented): . public class CompilerImpl extends AbstractCompiler { private final static List&lt;SourceFileExtension&gt; SOURCE_FILE_EXTENSIONS = List.of( new SourceFileExtension(&quot;asm&quot;, &quot;Assembler source file&quot;), ); private final LexerImpl lexer; private final ParserImpl parser; private MemoryContext&lt;Short&gt; memory; private int programLocation; public CompilerImpl(long pluginID, ApplicationApi applicationApi, PluginSettings pluginSettings) { super(pluginID, applicationApi, pluginSettings); lexer = new LexerImpl(null); parser = new ParserImpl(lexer, this); } @SuppressWarnings(&quot;unchecked&quot;) @Override public void initialize() { try { ContextPool pool = applicationApi.getContextPool(); memory = pool.getMemoryContext(pluginID, MemoryContext.class); if (memory.getDataType() != Short.class) { throw new InvalidContextException( &quot;Unexpected memory cell type. Expected Short but was: &quot; + memory.getDataType() ); } } catch (ContextNotFoundException | InvalidContextException e) { System.err.println(&quot;Memory context is not available&quot;, e); } } @Override public LexicalAnalyzer getLexer(Reader in) { return new LexerImpl(in); } @Override public boolean compile(String inputFileName, String outputFileName) { try { notifyCompileStart(); IntelHEX hex = compileToHex(inputFileName); hex.generate(outputFileName); programLocation = hex.getProgramLocation(); notifyInfo(&quot;Compilation was successful. n Output file: &quot; + outputFileName); if (memory != null) { hex.loadIntoMemory(memory); notifyInfo(&quot;Compiled file was loaded into memory.&quot;); } else { notifyWarning(&quot;Memory is not available.&quot;); } return true; } catch (Exception e) { notifyError(&quot;Compilation error: &quot; + e.getMessage()); return false; } finally { notifyCompileFinish(); } } @Override public int getProgramLocation() { return programLocation; } @Override public List&lt;SourceFileExtension&gt; getSourceFileExtensions() { return SOURCE_FILE_EXTENSIONS; } private IntelHEX compileToHex(String inputFileName) throws Exception { ... } } . The compiler does not register any context, but when initialized it obtains optional memory context. If the memory is available, it means that after compilation the program will be loaded in there, otherwise not. . Lexer and parser are not shown here, but they are created using mentioned JFlex and Java cup tools. . The compiler utilizes a helper class IntelHEX from emuLib, which generates Intel HEX files. . For more information, see the code of some existing compilers. .",
    "url": "/documentation/developer/compiler/",
    "relUrl": "/compiler/"
  }
  ,"8": {
    "title": "Writing a CPU",
    "content": "Writing a CPU . CPU plugins in emuStudio are not just plain emulators. They must cooperate with emuStudio and provide capabilities allowing debugging and some interaction. . A CPU plugin must implement: . Emulation “engine” It is the CPU emulator itself, and it should be implemented using some emulation technique. In Java there are not many options, so usually either interpretation or threaded dispatch are used, both described e.g. here or here. Disassembler It will be used by emuStudio for creating the list of instructions in the debugger panel. Java Swing GUI panel It should implement the visualization of CPU registers, possibly current frequency and CPU run state. Both disassembler and GUI panel should be instantiated just once. It is good practice to instantiate disassembler during plugin instantiation or initialization, and GUI in the CPU.getStatusPanel() method call. emuStudio application will call the method just once from Swing Event dispatch thread. . Programming a disassembler might be tedious and error-prone. Therefore we encourage to use a tool which can generate the disassembler from a specification file. The tool is called Edigen, an abbreviation for Emulator DIsassembler GENerator. It can be nicely incorporated into Gradle build using edigen-gradle-plugin. .",
    "url": "/documentation/developer/cpu/",
    "relUrl": "/cpu/"
  }
  ,"9": {
    "title": "Writing a device",
    "content": "Writing a device . In emuStudio, plugin root class must either implement Device interface, or can extend more bloat-free AbstractDevice class. . A device in emuStudio has three components: . a device “engine” (device functionality) | optional main GUI window | optional settings GUI window | . Communication with devices is realized through device contexts. A device, as any other plugin, can have none, one or more contexts, which should be registered in plugin root class constructor. Device context should implement a DeviceContext interface. . Sample implementation of a device root class might look as follows: . @PluginRoot( type = PLUGIN_TYPE.DEVICE, title = &quot;Sample device&quot; ) public class DeviceImpl extends AbstractDevice { private final DeviceContext deviceEngine = new DeviceEngine(); private MainWindow mainWindow; private SettingsWindow settingsWindow; public DeviceImpl(long pluginID, ApplicationApi applicationApi, PluginSettings settings) { super(pluginID, applicationApi, settings); try { applicationApi.getContextPool().register(pluginID, deviceEngine, DeviceContext.class); } catch (InvalidContextException | ContextAlreadyRegisteredException e) { applicationApi.getDialogs().showError( &quot;Could not register Sample Device.&quot;, getTitle() ); } } @Override public void showGUI(JFrame parent) { if (mainWindow == null) { mainWindow = new MainWindow(parent); } mainWindow.setVisible(true); } @Override public void showSettings(JFrame parent) { if (settingsWindow == null) { settingsWindow = new SettingsWindow(parent); } settingsWindow.setVisible(true); } @Override public boolean isShowSettingsSupported() { return true; } } .",
    "url": "/documentation/developer/device/",
    "relUrl": "/device/"
  }
  ,"10": {
    "title": "Getting started",
    "content": "Getting started . emuStudio is a Java Swing application which implements editor of virtual computer configuration, source code editor, and emulation “controller” (sometimes known as “debugger”). Emulation controller is used for controlling the emulation, and also supports the interaction in the application GUI. Under the hood, it operates with an instance of so-called “virtual computer”. The virtual computer - or computer emulator - is loaded from the computer configuration, selected by the user in the beginning. . Virtual computer is composed of plugin instances, which can be interconnected, as the computer configuration defines. Each plugin is single, almost self-contained, JAR file. It means that almost all dependencies the plugin uses should be present in the JAR file, except the following, which are bundled with emuStudio and will always be available on the class-path: . emuLib | java cup runtime | SLF4J logging | args4j for command-line parsing | . The application, besides, provides also: . plugin configuration management - implementation of PluginSettings | and runtime API for the communication between plugins and the application - implementation of ApplicationApi | . Plugins get those objects in the constructor. Details are provided in further chapters, but here can be revealed just this: there are four types of plugins. Virtual computer can contain a compiler (which produces code loadable in the emulated computer), one CPU emulator, one operating memory and none, one or more virtual devices. The core concept of a virtual computer is inspired by the von Neumann model. . Each plugin implements API from emuLib, following some predefined rules. Then a plugin is be compiled to a JAR file and put into a proper subdirectory in emuStudio installation. .",
    "url": "/documentation/developer/getting_started/",
    "relUrl": "/getting_started/"
  }
  ,"11": {
    "title": "Writing a memory",
    "content": "Writing a memory . In emuStudio, plugin root class must either implement Memory interface, or can extend more bloat-free AbstractMemory class. . Generally, a memory in an emulator is usually implemented as an array of integers. Indexes to the array represent addresses, and values are the memory cell values. In emuStudio, this kind of implementation is reflected by memory context. Memory context should be a class which either implements MemoryContext interface, or extends AbstractMemoryContext class. The latter provide additional functionality - management of memory “listeners”. . A memory listener (implementing Memory.MemoryListener interface) can observe memory value changes on all address range. But when the emulation is in running state, emuStudio turns off the memory notifications to speed up the emulation. .",
    "url": "/documentation/developer/memory/",
    "relUrl": "/memory/"
  }
  ,"12": {
    "title": "Plugin basics",
    "content": "Plugin basics . Each plug-in is a separate Java module (source code can be in any JVM language however!), compiled into single JAR file. The JAR file is then placed in the proper directory (e.g. compiler/, cpu/, memory/, and device/) in emuStudio installation. . In the source code, plugins are located in plugins/ subdirectory, then branched further by plugin type. . Naming conventions . Plug-in names are derived from JAR file names. A name should be picked by a convention, different by plugin type. General idea is that from the JAR file name it should be clear what the plugin is about. . A plugin JAR file name should be in the form of: . [specific abbreviation]-[plugin type].jar . where [specific abbreviation] means some custom abbreviation of the real world “device” the plugin emulates or is part of, optionally preceded with the manufacturer (e.g. intel-8080, lsi-adm-3A, etc.). Then [plugin type] follows, but in a form as it is shown in the following table: . Plugin type Naming convention Examples . Compiler | [language]-compiler (for compiler of higher language), or as-[cpu type] (for assembler) | as-8080, as-z80, brainc-compiler, ram-compiler | . CPU | [cpu model]-cpu, or [computer type]-cpu | 8080-cpu, z80-cpu, ram-cpu, brainduck-cpu | . Memory | [some feature]-mem, or [computer type]-mem | standard-mem, ram-mem, brainduck-mem | . Device | [device model]-[device type] | 88-disk, adm3a-terminal, simh-pseudo | . Plug-in names can contain digits, small and capital letters (regex: [a-zA-Z0-9]+). Capital letters shall be used only just for word separation (e.g. zilogZ80). . Plugin structure . A plugin must contain a public class which is considered as plugin root. The plugin root is automatically found, then instantiated by emuStudio, then assigned into virtual computer and used. . A class which is to be plugin root, must: . implement some plugin interface (i.e. CPU, Device, Memory or Compiler) | annotate the class with PluginRoot annotation | implement a public constructor with three arguments of types (long, ApplicationApi, PluginSettings) | . A sample plugin root class might look like this: . @PluginRoot(type = PLUGIN_TYPE.CPU, title = &quot;Sample CPU emulator&quot;) public class SamplePlugin implements CPU { public SamplePlugin(long pluginId, ApplicationApi emustudio, PluginSettings settings) { ... } ... } . If there are more classes which implements some plugin interface, just one of them has to be annotated with PluginRoot. If there are more classes like this, the plugin might not work correctly. . The constructor parameters have the following meaning: . pluginId is a unique plugin identification, assigned by emuStudio. Some operations require it as input argument. | emustudio is a runtime API implementation, provided by emuStudio application, to be used by plugins. | settings are plugin’s settings. A plugin can use it for reading/writing its custom or emuStudio settings. Updated settings are saved immediately in the configuration file, in the same thread. | . Third-party dependencies . Each plugin can depend on third-party libraries (or other plugins). In this case, the dependencies should be either bundled with the plugin, or the location should be present in Class-Path attribute in the plugin’s Manifest file. . Some libraries are pre-loaded by emuStudio and those shouldn’t be included in plugin JAR file: . emuLib | java cup runtime | SLF4J logging | args4j for command-line parsing | . Plugins which want to use the dependencies above, should specify them as “provided” in the project. . Incorporating a plugin in emuStudio . New plugin is another Gradle submodule, which should be “registered” in settings.gradle file. . If a plugin is part of a new computer, the new configuration should be created (in TOML format) and put in application/src/main/files/config directory. . Plugin can have static example files, or shell scripts. Plugin must copy them into build directory, e.g. plugins/compiler/as-8080/build/libs/examples or plugins/compiler/as-8080/build/libs/scripts. Then, in application/build.gradle are sections marked with // Examples or // Scripts comments: . ... // Examples [&quot;as-8080&quot;, &quot;as-z80&quot;, &quot;as-ssem&quot;, &quot;brainc-brainduck&quot;, &quot;ramc-ram&quot;, &quot;raspc-rasp&quot;].collect { compiler -&gt; from(examples(&quot;:plugins:compiler:$compiler&quot;)) { into &quot;examples/$compiler&quot; } } // Scripts [&quot;as-8080&quot;, &quot;as-z80&quot;, &quot;as-ssem&quot;, &quot;brainc-brainduck&quot;, &quot;ramc-ram&quot;, &quot;raspc-rasp&quot;].collect { compiler -&gt; from(scripts(&quot;:plugins:compiler:$compiler&quot;)) { into &quot;bin&quot; } } [&quot;88-disk&quot;].collect { device -&gt; from(scripts(&quot;:plugins:device:$device&quot;)) { into &quot;bin&quot; } } ... . It is necessary to put your plugin name in the particular collection. .",
    "url": "/documentation/developer/plugin_basics/",
    "relUrl": "/plugin_basics/"
  }
  ,"13": {
    "title": "",
    "content": "",
    "url": "/documentation/developer/",
    "relUrl": "/"
  }
  ,"14": {
    "title": "Introduction",
    "content": "Introduction . This guide shall help you, the developer, to write your own virtual computer for emuStudio. API is designed for simplicity and tries to save the developer from solving the most common problems. Created emulators can mimic either real or abstract computers. I hope you will have fun! . There exist some sister projects, which will be used by the developer during your programming journey. The following section will provide more information. . emuLib . emuLib is a run-time library used by emuStudio and plugins. It also provides the API to be implemented by plug-ins. Javadoc can be opened here. . edigen . Edigen is CPU instruction decoder and disassembler generator. It takes the burden of the common disassembling/decoding code from the developer when programming emulator. The project website, which includes documentation, is here. . Other documentation . For reference, here are provided some documents for some older emuStudio versions. . Version Year Document or paper .   | 2017 | RASP Abstract Machine Emulator — Extending the emuStudio Platform | .   | 2012 | An instruction decoder and disassembler generator for EmuStudio platform - Proceeding of the Faculty of Electrical Engineering and Informatics of the Technical University of Košice. Page 660-663. ISBN 978-80-553-0890-6 | .   | 2010 | Preserving host independent emulation speed | .   | 2010 | Standardization of computer emulation | .   | 2010 | Communication model of emuStuio emulation platform | . 0.37b | 2009 | User manual (in Slovak) | . 0.37b | 2009 | Plugins’ vade-mecum (in Slovak) | .   | 2008 | Software-based CPU emulation | .",
    "url": "/documentation/developer/introduction/",
    "relUrl": "/introduction/"
  }
  ,"15": {
    "title": "Loading and initialization",
    "content": "Loading and initialization . Instantiating and initializing plugins is done by emuStudio application in one thread. All plugins share one class-loader, which creates a potential risk of naming conflicts. Therefore, each classes and resources should be put in packages with unique name. . Plugin instantiation . Plugin JAR files are unzipped and loaded into memory as one bunch mixed together. The class loader will recognize all found classes and resources. Dependencies explicitly specified in manifest files are recognized and loaded as well. In case of circular dependencies, plugins loading will fail. . This process happens just once in the beginning, so adding another plugin at run-time is not possible. The result of this phase is that all plugin classes are loaded in memory and all plugin roots are instantiated. . What should plugin do in the constructor . Plugin constructor has three arguments - plugin ID, emuStudio API and plugin settings. Here, plugin can for example read its settings, or instantiate some final objects used later. But the most important operation here is to register so-called “plugin contexts” (if a plugin has some) into ContextPool, obtainable from emuStudio API. Note that plugin contexts of connected plugins must NOT be obtained here - in constructor. . Another chapter talks about plugin contexts in more detail. . Plugin initialization . After plugins are instantiated, they are being “initialized”. In fact, it means just that emuStudio will call Plugin.initialize() method on each plugin. The plugin initializations are ordered by plugin type: . Compiler | CPU | Memory | Devices in the order as they are defined in the virtual computer configuration | What should plugin do here . The most important operation what a plugin should do in the Plugin.initialize() method is to obtain “plugin contexts” of another connected plugins. Plugin contexts can be obtained from already mentioned ContextPool class, obtainable from emuStudio API. .",
    "url": "/documentation/developer/plugin_basics/loading",
    "relUrl": "/plugin_basics/loading"
  }
  ,"16": {
    "title": "Plugin Root",
    "content": "Plugin root class . A CPU plugin root class must implement either a CPU interface, or extend AbstractCPU class. . AbstractCPU implements several mechanisms which save developer time, like: . emulation control methods (run, step, stop, pause, reset) are queued for execution in the same thread, and implements run state notification. It means that it is possible to call them from any other thread (e.g. also from Swing Event dispatch thread) | implements notification of run states (see next chapter) | implements breakpoints management | . Sample implementation follows (only core methods are implemented): . @PluginRoot( type = PLUGIN_TYPE.CPU, title = &quot;Sample CPU emulator&quot; ) @SuppressWarnings(&quot;unused&quot;) public class CpuImpl extends AbstractCPU { private final ContextImpl context = new ContextImpl(); private EmulatorEngine engine; private Disassembler disassembler; private StatusPanel statusPanel; public CpuImpl(long pluginID, ApplicationApi applicationApi, PluginSettings settings) { super(pluginID, applicationApi, settings); try { applicationApi.getContextPool().register(pluginID, context, ExtendedContext.class); } catch (InvalidContextException | ContextAlreadyRegisteredException e) { LOGGER.error(&quot;Could not register CPU context&quot;, e); applicationApi.getDialogs().showError( &quot;Could not register CPU Context. Please see log file for details.&quot;, super.getTitle() ); } } @Override public void initialize() throws PluginInitializationException { MemoryContext&lt;Short&gt; memory = contextPool.getMemoryContext(pluginId, MemoryContext.class); if (memory.getDataType() != Short.class) { throw new InvalidContextException( &quot;Unexpected memory cell type. Expected Short but was: &quot; + memory.getDataType() ); } // create disassembler and debug columns this.disassembler = new DisassemblerImpl(memory, new DecoderImpl(memory)); this.engine = new EmulatorEngine(memory, context); } @Override protected void destroyInternal() { context.clearDevices(); } @Override public void resetInternal(int location) { engine.reset(location); } @Override protected RunState stepInternal() throws Exception { return engine.step(); } @Override public JPanel getStatusPanel() { if (statusPanel == null) { statusPanel = new StatusPanel(engine, context); } return statusPanel; } @Override public RunState call() { return engine.run(this); } @Override public Disassembler getDisassembler() { return disassembler; } @Override public int getInstructionLocation() { return engine.PC; } @Override public boolean setInstructionLocation(int position) { if (position &lt; 0) { return false; } engine.PC = position &amp; 0xFFFF; return true; } } . What can be noticed here is: . this CPU register custom context in constructor. The context is custom, because it will allow attaching devices to specific CPU “ports”. | obtaining MemoryContext is vital. If it is not successful, the PluginInitializationException will be propagated to the caller. | actual CPU emulation is implemented in EmulatorEngine class, which requires a memory and CPU context. | classes DisassemblerImpl and DecoderImpl are generated by Edigen | .",
    "url": "/documentation/developer/cpu/rootclass",
    "relUrl": "/cpu/rootclass"
  }
  ,"17": {
    "title": "Run states",
    "content": "Run states . Emulator “life” is a state machine. A state machine reacts on asynchronous events, which make the machine to transition the current state to another state. In emuStudio, whole emulation “state” depends on CPU run state. The run state is a name for the following states: breakpoint (starting state), running, stopped (more variants). . The state machine, how it should work, can be seen in the following diagram: . . The states of the state machine are encoded into an enum CPU.RunState in emuLib: . public static enum RunState { STATE_STOPPED_NORMAL(&quot;stopped&quot;), STATE_STOPPED_BREAK(&quot;breakpoint&quot;), STATE_STOPPED_ADDR_FALLOUT(&quot;stopped (address fallout)&quot;), STATE_STOPPED_BAD_INSTR(&quot;stopped (instruction fallout)&quot;), STATE_RUNNING(&quot;running&quot;); ... } . Implementation of the state machine is a sole responsibility of CPU plugin. emuStudio has some expectations of it, like: . initial run state should be STATE_STOPPED_BREAK | calling reset() should set the run state to STATE_STOPPED_BREAK | calling pause() if the current state is not one of STATE_STOPPED_(how) variant, it should set the run state to STATE_STOPPED_BREAK. Otherwise, do nothing. | calling step() if the current state is one of STATE_STOPPED_(how) (except STATE_STOPPED_BREAK), it should do nothing. Otherwise, it should set the run state to: STATE_STOPPED_BREAK, if the execution of the current instruction did not cause error, or it wasn’t a “halt” instruction. | STATE_STOPPED_(how) state, where (how) should be replaced by: BAD_INSTR - if unknown instruction was encountered | ADDR_FALLOUT - if instruction pointed to unknown or forbidden memory location | NORMAL - if the instruction was “halt” causing CPU to “halt” | . | . | calling run() should set the state to STATE_RUNNING and run instructions “infinitely”, upon external event or some error, in which case it should set the state to: STATE_STOPPED_BREAK - if external call pause() method | STATE_STOPPED_(how) state, where (how) should be replaced by: BAD_INSTR - if unknown instruction was encountered | ADDR_FALLOUT - if instruction pointed to unknown or forbidden memory location | NORMAL - if the instruction was “halt” causing CPU to “halt” | . | . | calling stop() if the current state is one of STATE_STOPPED_(how) (except STATE_STOPPED_BREAK), it should do nothing. Otherwise it should set the state to STATE_STOPPED_NORMAL. | . If the CPU plugin root class implements CPU interface, it is its responsibility to notify CPU run state changes and manage run state “listeners”. But if the plugin root class extends AbstractCPU, it does not have care about listeners and run state notifications, because the class implements it. .",
    "url": "/documentation/developer/cpu/runstate",
    "relUrl": "/cpu/runstate"
  }
  
}